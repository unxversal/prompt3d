<<<

## 9.1 Define points based on directions and distances

``` javascript
function Polar(currentPoint,distance,angleDegToX)
{
    let newPoint = [];
    let angleRad = angleDegToX * Math.PI/180;
    newPoint[0]  = currentPoint[0] + distance * Math.cos(angleRad);
    newPoint[1]  = currentPoint[1] + distance * Math.sin(angleRad);
    return newPoint
}

function PolarX(currentPoint,xdistance,angleDegToX)
{
    let newPoint = [];
    let angleRad = angleDegToX * Math.PI/180;
    newPoint[0]  = currentPoint[0] + xdistance;
    newPoint[1]  = currentPoint[1] + xdistance * Math.tan(angleRad);
    return newPoint
}

function PolarY(currentPoint,ydistance,angleDegToX)
{
    let newPoint = [];
    let angleRad = angleDegToX * Math.PI/180;
    newPoint[0]  = currentPoint[0] + ydistance/Math.tan(angleRad);
    newPoint[1]  = currentPoint[1] + ydistance;
    return newPoint
}
``` 

## 9.2 Circles joined with tangent lines

This function can be used to draw to circle-arcs connected with tangent lines, as an outline for a lever or a droplet. The circle with `radius1` is centered on the origin, the second arc is centered along the x-axis at a distance called `distance`. 


![Creating a drop shape for a lever](https://github.com/raydeleu/ReplicadManual/blob/main/images/droplet1.png)

``` javascript 
function dropView(radius1, radius2, distance)
{
    let sinus_angle = (radius1 - radius2) / distance
    let angle = Math.asin(sinus_angle);

    // points of outer contour of the lever
    let p1 = [radius1 * Math.sin(angle), radius1 * Math.cos(angle)];
    let p2 = [distance + radius2 * Math.sin(angle), radius2 * Math.cos(angle)];
    let p3 = [distance + radius2, 0];
    let p4 = [distance + radius2 * Math.sin(angle), - radius2 * Math.cos(angle)];
    let p5 = [radius1 * Math.sin(angle), - radius1 * Math.cos(angle)];
    let p6 = [- radius1, 0 ];

    let dropDrawing = draw(p1)
                    .lineTo(p2)
                    .threePointsArcTo(p4,p3)
                    .lineTo(p5)
                    .threePointsArcTo(p1,p6)
                    .close();
    
    return dropDrawing}
```


## Create a polar array 

Many CAD programs offer the function to create a polar array of shapes, for example adding holes in a circular pattern. The following script solves this (copied from https://replicad.xyz/docs/recipes/polar-array)

``` javascript
const polarCopies = (shape, count, radius) => {
  const base = shape.translate(0, radius);
  const angle = 360 / count;

  const copies = [];
  for (let i = 0; i < count; i++) {
    copies.push(base.clone().rotate(i * angle));
  }
  return copies;
};
```

The code only works properly if: 

* your original shape is centered at the origin [x,y] = [0,0]
* the circular pattern is located around the origin 

The script works for any shape and therefore both for 2D and 3D shapes. In the case of 3D, it will create the copies in the XY plane (as the default rotation is defined around the z-axis). 


This section describes how to export geometric data, what file types are supported, what are possible pipelines to transfer information from Replicad to STEP to STL or OBJ format. Resolution of tesselation, difference between quality of tesselation produced by different softwares.  

## 10.1 Exporting shapes

Apart from saving the javascript input file, Replicad offers three options to save your work for further modification or 3D printing. These options are: 

* Save the shapes in STL format
* Save the shapes in STEP format
* Save the shapes in JSON format

<img src="https://github.com/raydeleu/ReplicadManual/assets/38007983/17f770fd-730a-470a-952c-a97035e82513" width="500">

Which option is best depends on the purpose of the export. Two scenario's will be discussed in the next sections.

### 10.1.1 Exporting for 3D printing

One of the reasons you might be interested in modelling with Replicad is that you want to create objects with a 3D printer or CNC (computer numerical control) machining. Replicad is perfectly suited for this task as it allows to enter exact dimensions that can be altered slightly if it turns out that your design needs modification, for example because your 3D printer requires larger tolerances or cannot handle the printing overhangs. (An additional advantage is that modelling with a "real" CAD tool often result in less modelling errors such as non-manifold meshes, which are meshes that are not completely enclosing a volume. The concept of a 3D mesh will be discussed below). 

<img src="https://github.com/raydeleu/ReplicadManual/assets/38007983/ee8d77f2-097a-47a0-90ed-f37ae58d7a03" width="800">

In the case of 3D printing you need a file that can be imported by the so-called slicing tool that you use. The most well-known slicing tools are Ultimaker Cura  (https://ultimaker.com/software/ultimaker-cura/) and Prusa Slicer (https://www.prusa3d.com/). These tools mostly require a model in a socalled polygonal format. A polygon is a small flat face, so in a polygonal model the shape is enclosed in little small faces. File formats for polygonal models are the Wavefront OBJ format and the STL (Stereo Lithography) format. (Wafefront was a 3D company, subsequently acquired by Alias which was then acquired by Autodesk). The following image shows the file formats accepted by Cura: 

<img src="https://github.com/raydeleu/ReplicadManual/assets/38007983/da40e7fa-fa52-41dc-8773-8638dddc3e75" width="300">

Replicad can export in the STL format. The STL format describes the model with a mesh of triangle-shaped polygons. It is therefore an approximation of the 3D shape and may be considered a "lossy" format: data is lost in the conversion towards STL and the original format cannot be recovered from this format. As said, to produce a polygonal model of a 3D shape, the shape has to be broken down into small faces. The granularity or resolution of these faces determines the deviation of the exported model from the accurate model in the BRep modelling tool such as Replicad. The larger the resolution, the smaller the difference between the accurate model and the approximate polygonal model. But a larger resolution will also result in longer export times and larger files. Whether the resolution of the produced file is visible in the end-product is determined both by the resolution of the data and the capabilities of the manufacturing tool. For example, a 3D printer always prints in small layers, so having a resolution much smaller than these layers makes no sense.  

The Workbench and Visualizer do not offer the option to adjust the resolution. The settings can be found hidden in de code of Replicad. So if you need to adjust the resolution of your model, you can install Replicad locally (see Appendix B) and adjust the source code. Look for the following piece of code in the source: 

```
blobSTL({ tolerance = 1e-3, angularTolerance = 0.1 }
```
Note that the tolerance is already set quite low, resulting in accurate models for day-to-day use, especially for 3D printing. 

If you are still not satisfied with the STL export produced by Replicad, you can take a detour using other software. In that case you would export your object in a STEP file (see next section), import the STEP file into another software and then perform the export to STL with that software. In a software like 

* Moi3D (https://moi3d.com/) you can adjust the number of faces that is produced for the STL export,
* OnShape (https://onshape.com) offers four settings ranging from fine to coarse,
* CascadeStudio (https://zalo.github.io/CascadeStudio/) allows to set the `MeshRes` from its interface.
* SolidEdge (https://solidedge.siemens.com/en/solutions/users/hobbyists-and-makers/) allows to set the Conversion Tolerance and the Tolerance Units.  

### 10.1.2 Exporting for further modification 

It might be that you want to provide your 3D model to another person to enable him to adapt this model in her/his software of choice. In that case transferring the information in STEP format is preferred. STEP stands for "Standard for the Exchange of Product Data" and is a format defined in ISO 10303. It can describe a shape in terms of curves and faces. Additionally it can contain information on material, tolerances and colour of the object. The STEP format is the most appropriate format to transfer the model to other 3D design software as this file most accurately describes the shape.

The following image shows the import options for Moi3D ((https://moi3d.com/)

<img src="https://github.com/raydeleu/ReplicadManual/blob/main/images/moi_import.png" width="750"> 

When you import the shape into Moi3D you can see that no tesselation (break-up of the object into small faces) has occurred: 

<img src="https://github.com/raydeleu/ReplicadManual/blob/main/images/moi_import_step.png" width="700"> 

And here is the same shape after importing into OnShape: 

<img src="https://github.com/raydeleu/ReplicadManual/blob/main/images/import_step_onshape.png" width="800"> 

Using the 3D programs mentioned above, you can export in many other formats, both accurate formats (STEP, IGES) and polygonal formats (STL, OBJ, WRL, Collada DAE). 

Importing a Replicad object into another software makes sense if not all intended modelling actions such as applying fillets are possible in Replicad. Another reason could be that your object is only a part in a larger assembly which is created in the other software. The following image shows an example where Solid Edge was used to apply some additional fillets that caused a "kernel error" in Replicad. The blue object was exported as a STEP file from Replicad, the green object has the additional fillets. A benefit of this approach is that you do not need to learn the other software completely but can restrict your knowledge to applying fillets or exporting in other formats. 

<img src="https://github.com/raydeleu/ReplicadManual/blob/main/images/slottedlever-render.jpg" width="800"> 

As mentioned in the previous section, some of the programs that are discussed in this section allow to export the shape in a polygonal format and to determine the level of detail of these models. The following two images show the export of an object in OBJ and STL format using Moi3D. 

<img src="https://github.com/raydeleu/ReplicadManual/blob/main/images/moi_export_obj.png" width="400"> 

<img src="https://github.com/raydeleu/ReplicadManual/blob/main/images/moi_export_stl.png" width="400"> 

Notice that the OBJ format allows polygonal faces with more than 3 vertices, whereas the STL model consists completely of triangular faces. Moi3D is known for its nice algorithm for meshing objects, especially in the OBJ format. This is especially beneficial if you want to change the model in a polygonal modelling software such as Blender (https://www.blender.org). 

### 10.1.3 Exporting for visualization

When you want to create a nice rendering of your object you can use both the accurate CAD format as a polygonal format such as STL. In most cases the object will be changed into a polygonal format anyhow by the rendering engine. This is even the case in the Replicad Visualizer and Workbench. Most rendering software uses algorithms to smooth surfaces. Therefore using a model with a very high resolution often makes no sense as it just increases the  size of the model files without any noticeable effect on the rendered result. The examples in this section were all created using the output from Replicad without any enhancement. 

If you are prepared to use commercial software to create a visualization, Solid Edge is a very good choice. The software is available at no cost for "makers and hobbyists" at [solidedge.siemens.com](https://solidedge.siemens.com/en/solutions/users/hobbyists-and-makers/). The software can import the STEP files produced by Replicad and save these as a PAR file, a Parasolid part file. The software package of Solid Edge includes a restriced version of Keyshot (https://www.keyshot.com/) that can import the objects in PAR format and produce a nice rendering without much effort. Just select some materials, apply these to the objects, choose the type of lighting (product design, jewelry et cetera) and press "render". 

<img src="https://github.com/raydeleu/ReplicadManual/blob/main/images/keyshot-screenshot.png" width="800"> 

The result is a realistic product rendering within less than an hour of work (note that if you do not use materials like glass, you can really get a result within a few minutes): 

<img src="https://github.com/raydeleu/ReplicadManual/blob/main/images/keyshot-replicad9.jpg" width="800"> 

A disadvantage of Solid Edge is that you can not use the free version for commercial activities and you never know when the offer to use this software freely ends. Furthermore this software can only be used on the Windows operating system. If you are using MacOS or Linux you would have to install a virtual machine with Windows to run this software. 

An open source alternative that is available on most operating systems is Blender (https://www.blender.org). This software offers the same functionality, but is not easy to use. Things that make life easier, like material libraries and lighting setups, are available for Blender as well but in many cases require a small fee. You can find many of these libraries at https://blendermarket.com/categories/studio-lighting/browse. If you are willing to put in your own time and experiment a lot you can build everything for free. 

<img src="https://github.com/raydeleu/ReplicadManual/blob/main/images/blender-screenshot.png" width="800"> 

>[!NOTE]
>The commercial license to the full package of Keyshot costs around 100 US dollar per month, lower cost plans are available at 39 USD per month. A low cost commercial license to Solid Edge costs around 140 US dollar per month.  This would mean spending a small amount on a material library or studio setup for Blender is still not as costly. 

The more expensive programs like OnShape and Solid Edge can also create accurate drawings from a 3D part, which might be needed to transfer the design information to others. 

<img src="https://github.com/raydeleu/ReplicadManual/blob/main/images/drawing_onshape_v2.png" width="800"> 

>[!NOTE]
>You can also produce drawings with Replicad using the functions described in the documentation, see https://replicad.xyz/docs/examples/projections)






<img src="https://github.com/raydeleu/ReplicadManual/assets/38007983/606b44ca-be24-4533-a0c8-76fd9d5a831b" width ="500"> 

The CAD assistant (https://www.opencascade.com/products/cad-assistant/) allows an export of the shape to polygon formats such as OBJ, WRL, STL but also a format  like IGES that contains all the detail of curves and arcs. 


## 10.2 Importing shapes

This section provides an explanation how to import geometric data, what types of information can be imported, how, what are the options to use the imported shapes for further modification. What are approaches to extract geometric information from other programs if the tools provided by Replicad make modelling tasks difficult.

### 10.2.1 Importing 2D shapes

Replicad currently offers no option to import 2D sketches. Yet this functionality could be practical. Think of the following cases: 

* You are given een 3D-view (side, front, top) of an object with dimensions that assume that you have a so-called constraint based modeller. A constraint based modeller, such as most visual 3D CAD programs, allow to enter the dimensions and relations between drawing segments to end up with a fully defined shape. Without this capability, finding the coordinates of these sketches often involves tedious geometric calculations. An alternative is to seek other ways to create the same shape, to measure the coordinates from the drawing or do some trial and error until the shape looks right. But you could also use one of the freely available tools to create the 2D sketch and import this sketch into Replicad. Examples of freely available tools that support constraint based modelling are `Freecad`  (https://www.freecad.org/), `Solvespace` ([[https://solvespace.com](https://solvespace.com/index.pl)) or `jSketcher` (https://github.com/xibyte/jsketcher).

* It might be the case that you want to use a pattern or logo to embellish you 3D shape. The author of Replicad has implemented a basic functionality in a website called https://blingmything.sgenoud.com/ that contains this functionality. Unfortunately this functionality is (not yet) included in Replicad. 

One option to import 2D shapes from other softwares is to analyze the files and extract the relevant coordinates. As an example take the shape shown in the image below. This shape consist of two arcs, one with radius 32 mm on the right and one with radius 20 on the left. According to the original drawing this shape is based on, the two arcs are connected with a third arc, but the radius of this arc is not given in the drawing. Using a constraint based drawing tool it turns out that by entering the dimensions and constraints given in the drawing, the shape is fully defined. In the example below the drawing at the left (or top) was created in `SolveSpace`, the drawing at the right in `FreeCad` (see above). 

<img src="https://github.com/raydeleu/ReplicadManual/assets/38007983/34734cf8-00d8-4168-aef8-1ab47f3837d3" width="450">

<img src="https://github.com/raydeleu/ReplicadManual/assets/38007983/9adb59d6-a7f9-428d-98d7-7687e6b6f4a1" width="450">

SolveSpace supports the option to export the 2D view. Before exporting the shape you have to hide the construction lines (the green lines in the image) and the dimensions. The resulting SVG file then only contains the path of the shape. The SVG file is in fact a text file that can be opened in any text editor. The definition of the contour can be found by looking for the `path` statements. For the shape above the following path can be found in the SVG file: 

```
<path d='
M5.000 37.000
L97.000,37.000
A32.000,32.000 0 0,0 65.000,5.000
A92.667,92.667 0 0,0 13.991,20.303
A20.000,20.000 0 0,0 5.000,37.000 ' class='s1' />
```
For the purpose of clarity each separate statement is shown on a separate line, but in the actual file the statements are all contained in a single line. The elements of the path are identified by single characters. The following table shows that the drawing functions defined by these characters are very similar to the drawing methods available in Replicad. 

| SVG path command                                      | Replicad command                                            |
|-------------------------------------------------------|-------------------------------------------------------------|
|`M x y`                                                |`.movePointerTo([x,y]) or draw([x,y]) `                      |
|`m dx dy`                                              | no equivalent in Replicad other than starting new drawing   | 
|`L x,y  `                                              |`.lineTo([x,y])`                                             |
|`l dx,dy`                                              |`.line(dx,dy)  `                                             | 
|`v y`                                                  |`.vLine(dy)`                                                 |
|`h x `                                                 |`.hLine(dx)`                                                 |
|`A rx,ry deg-rotation large-arc?,sweep-positive? x,y`  |`.ellipseTo([x,y],rx,ry,deg rotation, long_way?, counter?`   | 
|`C x1 y1 x2 y2 x y`                                    |`.cubicBezierCurveTo([x,y],p1_ctrl_start,p2_ctrl_end)`       |   
|`Q controlX controlY endX endY `                       |`.quadraticBezierCurveTo([x,y],[x_ctrl,y_ctrl])`             |         
|`q dx_control dy_control dx dy `                       |`.quadraticBezierCurve(dx,dy,dx_ctrl,dy_ctrl)`               |
|`Z`                                                    |`.close()`                                                   |


Using this translation, the equivalent Replicad code is: 

```
const {draw}  = replicad

function main()
{
let contour = draw([5,37])
.lineTo([97,37])
.ellipseTo([65,5],32,32,0,false,false)
.ellipseTo([13.991,20.303],92.667,92.667,0,false,false)
.ellipseTo([5,37],20,20,0,false,false)
.close()
.sketchOnPlane("XY")

return contour}
```
The resulting shape in Replicad is shown below. Note that it is drawn upside down and not at the origin, but this can easily be corrected with a rotation and a translation. 

<img src="https://github.com/raydeleu/ReplicadManual/assets/38007983/4598b4a9-7f49-49ba-9c8c-f3fc3a767491" width="500">

In FreeCad you can export the shape in Open CAD format (.oca). The format of this file is very straight forward as for each line two points are given and for each arc three points.  

```
#oca file generated from FreeCAD

# edges
L1=P(-92.0 1.2246467986490979e-15 0.0) P(0.0 0.0 0.0)
C2=ARC P(0.0 0.0 0.0) P(-9.372583002030478 22.627416997969522 0.0) P(-32.0 32.0 0.0)
C3=ARC P(-32.0 32.0 0.0) P(-58.627570729148005 28.091902430493363 0.0) P(-83.0091743119266 16.697247706422022 0.0)
C4=ARC P(-83.0091743119266 16.697247706422022 0.0) P(-89.6094219984435 9.481996460700351 0.0) P(-92.0 1.2246467986490979e-15 0.0)
# faces
```

The approach to use another program to create a sketch does not always work, as in some cases the file will not contain arcs but pieces of straight lines that approximate a curve. In `SolveSpace` this seems the case when the drawing consists of splines or bezier curves instead of circular arcs. In that case converting the SVG is often not practical, as modifications of the resulting shapes with fillets - one of the modifications that cannot be performed in 3D by SolveSpace - often fails on these shapes. In that case you could still use the sketch and determine the location of starting and end points of arcs and curves in the software that you used to create the sketch. 

### 10.2.2 Importing 3D shapes

Replicad offers two basic options to import 3D shapes, namely import of STEP files and import of STL files.

```
let shapeFromSTEP = await importSTEP(blobFile)
let shapeFromSTL  = await importSTL(blobFile)
```

First it should be noted that these functions are preceded by the instruction `await`, as reading the large amount of data takes some time. To make this work within Replicad you have to define the `main` function as an asynchronous function, using the statement `async function main()` instead of the default `function main()`. 
Furthermore, both functions require a blob, a Binary Large Object, as its input. The main issue therefore is how to convert a file into a blob that can be fed to the import functions. 

One of the simplest approaches is to convert the file into a `base64` format. Base64 is an encoding of binary code or ASCII text that reduces the number of allowable characters to a standard set. This way the contents of a file can be converted into a single long string of characters. (Without the `base64` encoding the string would contain spaces and special characters, making it difficult to represent it as a single string of characters). The string of characters is assigned to a variable, which is then in turn decoded and turned into a `blob`.   

Note that on most computers (such as Linux, MacOS and Windows OS) you can encode a file using the terminal command: 

```
openssl base64 -A -in <infile> -out <outfile>
// -A is needed to have a single large string without new lines
```
The complete contents of the resulting file then have to be entered into the Replicad input file, for example using a statement like:

``` javascript
let stepFile = " [complete string of characters from base64 file] "
```

The resulting string can be quite large, as due to the encoding with less characters the size increases with 33%. The next example demonstrates how this works. The code also demonstrates that if everything goes well, the resulting shape can be modified like any other shape. However, if your inputfile contains multiple shapes this might not work.

``` javascript
let {importSTEP} = replicad  

async function main()  
{  

let stepFile = "SVNPLTEwMzAzLTIxOwpIRUFERVI7CkZJTEVfREVTQ1JJUFRJT04oKCdPcGVuIENBU0NBREUgTW9kZWwnKSwnMjsxJyk7CkZJTEVfTkFNRSgnT3BlbiBDQVNDQURFIFNoYXBlIE1vZGVsJywnMjAyMy0xMS0wN1QyMzo1MDoyMycsKCdBdXRob3InKSwoCiAgICAnT3BlbiBDQVNDQURFJyksJ09wZW4gQ0FTQ0FERSBTVEVQIHByb2Nlc3NvciA3LjYnLCdPcGVuIENBU0NBREUgNy42JwogICwnVW5rbm93bicpOwpGSUxFX1NDSEVNQSgoCidBUDI0Ml9NQU5BR0VEX01PREVMX0JBU0VEXzNEX0VOR0lORUVSSU5HX01JTV9MRi4gezEgMCAxMDMwMyA0NDIgMSAxIDQgCn0nKSk7CkVORFNFQzsKREFUQTsKIzEgPSBBUFBMSUNBVElPTl9QUk9UT0NPTF9ERUZJTklUSU9OKCdpbnRlcm5hdGlvbmFsIHN0YW5kYXJkJywKICAnYXAyNDJfbWFuYWdlZF9tb2RlbF9iYXNlZF8zZF9lbmdpbmVlcmluZycsMjAxMywjMik7CiMyID0gQVBQTElDQVRJT05fQ09OVEVYVCgnTWFuYWdlZCBtb2RlbCBiYXNlZCAzZCBlbmdpbmVlcmluZycpOwojMyA9IFNIQVBFX0RFRklOSVRJT05fUkVQUkVTRU5UQVRJT04oIzQsIzEwKTsKIzQgPSBQUk9EVUNUX0RFRklOSVRJT05fU0hBUEUoJycsJycsIzUpOwojNSA9IFBST0RVQ1RfREVGSU5JVElPTignZGVzaWduJywnJywjNiwjOSk7CiM2ID0gUFJPRFVDVF9ERUZJTklUSU9OX0ZPUk1BVElPTignJywnJywjNyk7CiM3ID0gUFJPRFVDVCgnT3BlbiBDQVNDQURFIFNURVAgdHJhbnNsYXRvciA3LjYgMicsCiAgJ09wZW4gQ0FTQ0FERSBTVEVQIHRyYW5zbGF0b3IgNy42IDInLCcnLCgjOCkpOwojOCA9IFBST0RVQ1RfQ09OVEVYVCgnJywjMiwnbWVjaGFuaWNhbCcpOwojOSA9IFBST0RVQ1RfREVGSU5JVElPTl9DT05URVhUKCdwYXJ0IGRlZmluaXRpb24nLCMyLCdkZXNpZ24nKTsKIzEwID0gQURWQU5DRURfQlJFUF9TSEFQRV9SRVBSRVNFTlRBVElPTignJywoIzExLCMxNSksIzQzNyk7CiMxMSA9IEFYSVMyX1BMQUNFTUVOVF8zRCgnJywjMTIsIzEzLCMxNCk7CiMxMiA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sMC4sMC4pKTsKIzEzID0gRElSRUNUSU9OKCcnLCgwLiwwLiwxLikpOwojMTQgPSBESVJFQ1RJT04oJycsKDEuLDAuLC0wLikpOwojMTUgPSBNQU5JRk9MRF9TT0xJRF9CUkVQKCcnLCMxNik7CiMxNiA9IENMT1NFRF9TSEVMTCgnJywoIzE3LCMxMzcsIzIxNiwjMjk5LCMzNzQsIzQyMSwjNDI5KSk7CiMxNyA9IEFEVkFOQ0VEX0ZBQ0UoJycsKCMxOCksIzMyLC5GLik7CiMxOCA9IEZBQ0VfQk9VTkQoJycsIzE5LC5GLik7CiMxOSA9IEVER0VfTE9PUCgnJywoIzIwLCM1NSwjODMsIzExMSkpOwojMjAgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMjEsLlQuKTsKIzIxID0gRURHRV9DVVJWRSgnJywjMjIsIzI0LCMyNiwuVC4pOwojMjIgPSBWRVJURVhfUE9JTlQoJycsIzIzKTsKIzIzID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwwLiwwLikpOwojMjQgPSBWRVJURVhfUE9JTlQoJycsIzI1KTsKIzI1ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwwLiwyMC4pKTsKIzI2ID0gU1VSRkFDRV9DVVJWRSgnJywjMjcsKCMzMSwjNDMpLC5QQ1VSVkVfUzEuKTsKIzI3ID0gTElORSgnJywjMjgsIzI5KTsKIzI4ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwwLiwwLikpOwojMjkgPSBWRUNUT1IoJycsIzMwLDEuKTsKIzMwID0gRElSRUNUSU9OKCcnLCgwLiwwLiwxLikpOwojMzEgPSBQQ1VSVkUoJycsIzMyLCMzNyk7CiMzMiA9IFBMQU5FKCcnLCMzMyk7CiMzMyA9IEFYSVMyX1BMQUNFTUVOVF8zRCgnJywjMzQsIzM1LCMzNik7CiMzNCA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sMC4sMC4pKTsKIzM1ID0gRElSRUNUSU9OKCcnLCgwLiwxLiwwLikpOwojMzYgPSBESVJFQ1RJT04oJycsKDEuLDAuLDAuKSk7CiMzNyA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzM4KSwjNDIpOwojMzggPSBMSU5FKCcnLCMzOSwjNDApOwojMzkgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDAuKSk7CiM0MCA9IFZFQ1RPUignJywjNDEsMS4pOwojNDEgPSBESVJFQ1RJT04oJycsKDAuLC0xLikpOwojNDIgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiM0MyA9IFBDVVJWRSgnJywjNDQsIzQ5KTsKIzQ0ID0gUExBTkUoJycsIzQ1KTsKIzQ1ID0gQVhJUzJfUExBQ0VNRU5UXzNEKCcnLCM0NiwjNDcsIzQ4KTsKIzQ2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiw0MC4sMC4pKTsKIzQ3ID0gRElSRUNUSU9OKCcnLCgxLiwwLiwtMC4pKTsKIzQ4ID0gRElSRUNUSU9OKCcnLCgwLiwtMS4sMC4pKTsKIzQ5ID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjNTApLCM1NCk7CiM1MCA9IExJTkUoJycsIzUxLCM1Mik7CiM1MSA9IENBUlRFU0lBTl9QT0lOVCgnJywoNDAuLDAuKSk7CiM1MiA9IFZFQ1RPUignJywjNTMsMS4pOwojNTMgPSBESVJFQ1RJT04oJycsKDAuLC0xLikpOwojNTQgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiM1NSA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCM1NiwuVC4pOwojNTYgPSBFREdFX0NVUlZFKCcnLCMyNCwjNTcsIzU5LC5ULik7CiM1NyA9IFZFUlRFWF9QT0lOVCgnJywjNTgpOwojNTggPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sMC4sMjAuKSk7CiM1OSA9IFNVUkZBQ0VfQ1VSVkUoJycsIzYwLCgjNjQsIzcxKSwuUENVUlZFX1MxLik7CiM2MCA9IExJTkUoJycsIzYxLCM2Mik7CiM2MSA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sMC4sMjAuKSk7CiM2MiA9IFZFQ1RPUignJywjNjMsMS4pOwojNjMgPSBESVJFQ1RJT04oJycsKDEuLDAuLDAuKSk7CiM2NCA9IFBDVVJWRSgnJywjMzIsIzY1KTsKIzY1ID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjNjYpLCM3MCk7CiM2NiA9IExJTkUoJycsIzY3LCM2OCk7CiM2NyA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sLTIwLikpOwojNjggPSBWRUNUT1IoJycsIzY5LDEuKTsKIzY5ID0gRElSRUNUSU9OKCcnLCgxLiwwLikpOwojNzAgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiM3MSA9IFBDVVJWRSgnJywjNzIsIzc3KTsKIzcyID0gUExBTkUoJycsIzczKTsKIzczID0gQVhJUzJfUExBQ0VNRU5UXzNEKCcnLCM3NCwjNzUsIzc2KTsKIzc0ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg0OS44NDM4NjA5MjExMTksMjUuODE3NTgzMzU5MjYyLDIwLikpOwojNzUgPSBESVJFQ1RJT04oJycsKDAuLDAuLDEuKSk7CiM3NiA9IERJUkVDVElPTignJywoMS4sMC4sLTAuKSk7CiM3NyA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzc4KSwjODIpOwojNzggPSBMSU5FKCcnLCM3OSwjODApOwojNzkgPSBDQVJURVNJQU5fUE9JTlQoJycsKC00OS44NDM4NjA5MjExMSwtMjUuODE3NTgzMzU5MjYpKTsKIzgwID0gVkVDVE9SKCcnLCM4MSwxLik7CiM4MSA9IERJUkVDVElPTignJywoMS4sMC4pKTsKIzgyID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojODMgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjODQsLkYuKTsKIzg0ID0gRURHRV9DVVJWRSgnJywjODUsIzU3LCM4NywuVC4pOwojODUgPSBWRVJURVhfUE9JTlQoJycsIzg2KTsKIzg2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgxMDAuLDAuLDAuKSk7CiM4NyA9IFNVUkZBQ0VfQ1VSVkUoJycsIzg4LCgjOTIsIzk5KSwuUENVUlZFX1MxLik7CiM4OCA9IExJTkUoJycsIzg5LCM5MCk7CiM4OSA9IENBUlRFU0lBTl9QT0lOVCgnJywoMTAwLiwwLiwwLikpOwojOTAgPSBWRUNUT1IoJycsIzkxLDEuKTsKIzkxID0gRElSRUNUSU9OKCcnLCgwLiwwLiwxLikpOwojOTIgPSBQQ1VSVkUoJycsIzMyLCM5Myk7CiM5MyA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzk0KSwjOTgpOwojOTQgPSBMSU5FKCcnLCM5NSwjOTYpOwojOTUgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sMC4pKTsKIzk2ID0gVkVDVE9SKCcnLCM5NywxLik7CiM5NyA9IERJUkVDVElPTignJywoMC4sLTEuKSk7CiM5OCA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzk5ID0gUENVUlZFKCcnLCMxMDAsIzEwNSk7CiMxMDAgPSBQTEFORSgnJywjMTAxKTsKIzEwMSA9IEFYSVMyX1BMQUNFTUVOVF8zRCgnJywjMTAyLCMxMDMsIzEwNCk7CiMxMDIgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sMC4sMC4pKTsKIzEwMyA9IERJUkVDVElPTignJywoLTEuLDAuLDAuKSk7CiMxMDQgPSBESVJFQ1RJT04oJycsKDAuLDEuLDAuKSk7CiMxMDUgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMxMDYpLCMxMTApOwojMTA2ID0gTElORSgnJywjMTA3LCMxMDgpOwojMTA3ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwwLikpOwojMTA4ID0gVkVDVE9SKCcnLCMxMDksMS4pOwojMTA5ID0gRElSRUNUSU9OKCcnLCgwLiwtMS4pKTsKIzExMCA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzExMSA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMxMTIsLkYuKTsKIzExMiA9IEVER0VfQ1VSVkUoJycsIzIyLCM4NSwjMTEzLC5ULik7CiMxMTMgPSBTVVJGQUNFX0NVUlZFKCcnLCMxMTQsKCMxMTgsIzEyNSksLlBDVVJWRV9TMS4pOwojMTE0ID0gTElORSgnJywjMTE1LCMxMTYpOwojMTE1ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwwLiwwLikpOwojMTE2ID0gVkVDVE9SKCcnLCMxMTcsMS4pOwojMTE3ID0gRElSRUNUSU9OKCcnLCgxLiwwLiwwLikpOwojMTE4ID0gUENVUlZFKCcnLCMzMiwjMTE5KTsKIzExOSA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzEyMCksIzEyNCk7CiMxMjAgPSBMSU5FKCcnLCMxMjEsIzEyMik7CiMxMjEgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDAuKSk7CiMxMjIgPSBWRUNUT1IoJycsIzEyMywxLik7CiMxMjMgPSBESVJFQ1RJT04oJycsKDEuLDAuKSk7CiMxMjQgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMxMjUgPSBQQ1VSVkUoJycsIzEyNiwjMTMxKTsKIzEyNiA9IFBMQU5FKCcnLCMxMjcpOwojMTI3ID0gQVhJUzJfUExBQ0VNRU5UXzNEKCcnLCMxMjgsIzEyOSwjMTMwKTsKIzEyOCA9IENBUlRFU0lBTl9QT0lOVCgnJywoNDkuODQzODYwOTIxMTE5LDI1LjgxNzU4MzM1OTI2MiwwLikpOwojMTI5ID0gRElSRUNUSU9OKCcnLCgwLiwwLiwxLikpOwojMTMwID0gRElSRUNUSU9OKCcnLCgxLiwwLiwtMC4pKTsKIzEzMSA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzEzMiksIzEzNik7CiMxMzIgPSBMSU5FKCcnLCMxMzMsIzEzNCk7CiMxMzMgPSBDQVJURVNJQU5fUE9JTlQoJycsKC00OS44NDM4NjA5MjExMSwtMjUuODE3NTgzMzU5MjYpKTsKIzEzNCA9IFZFQ1RPUignJywjMTM1LDEuKTsKIzEzNSA9IERJUkVDVElPTignJywoMS4sMC4pKTsKIzEzNiA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzEzNyA9IEFEVkFOQ0VEX0ZBQ0UoJycsKCMxMzgpLCMxMDAsLkYuKTsKIzEzOCA9IEZBQ0VfQk9VTkQoJycsIzEzOSwuRi4pOwojMTM5ID0gRURHRV9MT09QKCcnLCgjMTQwLCMxNDEsIzE2NCwjMTk1KSk7CiMxNDAgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjODQsLlQuKTsKIzE0MSA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMxNDIsLlQuKTsKIzE0MiA9IEVER0VfQ1VSVkUoJycsIzU3LCMxNDMsIzE0NSwuVC4pOwojMTQzID0gVkVSVEVYX1BPSU5UKCcnLCMxNDQpOwojMTQ0ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgxMDAuLDQwLiwyMC4pKTsKIzE0NSA9IFNVUkZBQ0VfQ1VSVkUoJycsIzE0NiwoIzE1MCwjMTU3KSwuUENVUlZFX1MxLik7CiMxNDYgPSBMSU5FKCcnLCMxNDcsIzE0OCk7CiMxNDcgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sMC4sMjAuKSk7CiMxNDggPSBWRUNUT1IoJycsIzE0OSwxLik7CiMxNDkgPSBESVJFQ1RJT04oJycsKDAuLDEuLDAuKSk7CiMxNTAgPSBQQ1VSVkUoJycsIzEwMCwjMTUxKTsKIzE1MSA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzE1MiksIzE1Nik7CiMxNTIgPSBMSU5FKCcnLCMxNTMsIzE1NCk7CiMxNTMgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLC0yMC4pKTsKIzE1NCA9IFZFQ1RPUignJywjMTU1LDEuKTsKIzE1NSA9IERJUkVDVElPTignJywoMS4sMC4pKTsKIzE1NiA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzE1NyA9IFBDVVJWRSgnJywjNzIsIzE1OCk7CiMxNTggPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMxNTkpLCMxNjMpOwojMTU5ID0gTElORSgnJywjMTYwLCMxNjEpOwojMTYwID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg1MC4xNTYxMzkwNzg4ODEsLTI1LjgxNzU4MzM1OTI2KSk7CiMxNjEgPSBWRUNUT1IoJycsIzE2MiwxLik7CiMxNjIgPSBESVJFQ1RJT04oJycsKDAuLDEuKSk7CiMxNjMgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMxNjQgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMTY1LC5GLik7CiMxNjUgPSBFREdFX0NVUlZFKCcnLCMxNjYsIzE0MywjMTY4LC5ULik7CiMxNjYgPSBWRVJURVhfUE9JTlQoJycsIzE2Nyk7CiMxNjcgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sNDAuLDAuKSk7CiMxNjggPSBTVVJGQUNFX0NVUlZFKCcnLCMxNjksKCMxNzMsIzE4MCksLlBDVVJWRV9TMS4pOwojMTY5ID0gTElORSgnJywjMTcwLCMxNzEpOwojMTcwID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgxMDAuLDQwLiwwLikpOwojMTcxID0gVkVDVE9SKCcnLCMxNzIsMS4pOwojMTcyID0gRElSRUNUSU9OKCcnLCgwLiwwLiwxLikpOwojMTczID0gUENVUlZFKCcnLCMxMDAsIzE3NCk7CiMxNzQgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMxNzUpLCMxNzkpOwojMTc1ID0gTElORSgnJywjMTc2LCMxNzcpOwojMTc2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg0MC4sMC4pKTsKIzE3NyA9IFZFQ1RPUignJywjMTc4LDEuKTsKIzE3OCA9IERJUkVDVElPTignJywoMC4sLTEuKSk7CiMxNzkgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMxODAgPSBQQ1VSVkUoJycsIzE4MSwjMTg5KTsKIzE4MSA9IFNVUkZBQ0VfT0ZfTElORUFSX0VYVFJVU0lPTignJywjMTgyLCMxODcpOwojMTgyID0gQl9TUExJTkVfQ1VSVkVfV0lUSF9LTk9UUygnJywzLCgjMTgzLCMxODQsIzE4NSwjMTg2KSwKICAuVU5TUEVDSUZJRUQuLC5GLiwuRi4sKDQsNCksKDAuLDEuKSwuUElFQ0VXSVNFX0JFWklFUl9LTk9UUy4pOwojMTgzID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgxMDAuLDQwLiwwLikpOwojMTg0ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg5Mi4wOTQzMDU4NDk1NzksNDcuOTA1Njk0MTUwNDIxLDAuKSk7CiMxODUgPSBDQVJURVNJQU5fUE9JTlQoJycsKDcxLjE4MDMzOTg4NzQ5OSw2MC4sMC4pKTsKIzE4NiA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwwLikpOwojMTg3ID0gVkVDVE9SKCcnLCMxODgsMS4pOwojMTg4ID0gRElSRUNUSU9OKCcnLCgtMC4sLTAuLC0xLikpOwojMTg5ID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMTkwKSwjMTk0KTsKIzE5MCA9IExJTkUoJycsIzE5MSwjMTkyKTsKIzE5MSA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sMC4pKTsKIzE5MiA9IFZFQ1RPUignJywjMTkzLDEuKTsKIzE5MyA9IERJUkVDVElPTignJywoMC4sLTEuKSk7CiMxOTQgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMxOTUgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMTk2LC5GLik7CiMxOTYgPSBFREdFX0NVUlZFKCcnLCM4NSwjMTY2LCMxOTcsLlQuKTsKIzE5NyA9IFNVUkZBQ0VfQ1VSVkUoJycsIzE5OCwoIzIwMiwjMjA5KSwuUENVUlZFX1MxLik7CiMxOTggPSBMSU5FKCcnLCMxOTksIzIwMCk7CiMxOTkgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sMC4sMC4pKTsKIzIwMCA9IFZFQ1RPUignJywjMjAxLDEuKTsKIzIwMSA9IERJUkVDVElPTignJywoMC4sMS4sMC4pKTsKIzIwMiA9IFBDVVJWRSgnJywjMTAwLCMyMDMpOwojMjAzID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMjA0KSwjMjA4KTsKIzIwNCA9IExJTkUoJycsIzIwNSwjMjA2KTsKIzIwNSA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sMC4pKTsKIzIwNiA9IFZFQ1RPUignJywjMjA3LDEuKTsKIzIwNyA9IERJUkVDVElPTignJywoMS4sMC4pKTsKIzIwOCA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzIwOSA9IFBDVVJWRSgnJywjMTI2LCMyMTApOwojMjEwID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMjExKSwjMjE1KTsKIzIxMSA9IExJTkUoJycsIzIxMiwjMjEzKTsKIzIxMiA9IENBUlRFU0lBTl9QT0lOVCgnJywoNTAuMTU2MTM5MDc4ODgxLC0yNS44MTc1ODMzNTkyNikpOwojMjEzID0gVkVDVE9SKCcnLCMyMTQsMS4pOwojMjE0ID0gRElSRUNUSU9OKCcnLCgwLiwxLikpOwojMjE1ID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojMjE2ID0gQURWQU5DRURfRkFDRSgnJywoIzIxNyksIzE4MSwuRi4pOwojMjE3ID0gRkFDRV9CT1VORCgnJywjMjE4LC5GLik7CiMyMTggPSBFREdFX0xPT1AoJycsKCMyMTksIzIyMCwjMjQ1LCMyNzYpKTsKIzIxOSA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMxNjUsLlQuKTsKIzIyMCA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMyMjEsLlQuKTsKIzIyMSA9IEVER0VfQ1VSVkUoJycsIzE0MywjMjIyLCMyMjQsLlQuKTsKIzIyMiA9IFZFUlRFWF9QT0lOVCgnJywjMjIzKTsKIzIyMyA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwyMC4pKTsKIzIyNCA9IFNVUkZBQ0VfQ1VSVkUoJycsIzIyNSwoIzIzMCwjMjM3KSwuUENVUlZFX1MxLik7CiMyMjUgPSBCX1NQTElORV9DVVJWRV9XSVRIX0tOT1RTKCcnLDMsKCMyMjYsIzIyNywjMjI4LCMyMjkpLAogIC5VTlNQRUNJRklFRC4sLkYuLC5GLiwoNCw0KSwoMC4sMS4pLC5QSUVDRVdJU0VfQkVaSUVSX0tOT1RTLik7CiMyMjYgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sNDAuLDIwLikpOwojMjI3ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg5Mi4wOTQzMDU4NDk1NzksNDcuOTA1Njk0MTUwNDIxLDIwLikpOwojMjI4ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg3MS4xODAzMzk4ODc0OTksNjAuLDIwLikpOwojMjI5ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg2MC4sNjAuLDIwLikpOwojMjMwID0gUENVUlZFKCcnLCMxODEsIzIzMSk7CiMyMzEgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMyMzIpLCMyMzYpOwojMjMyID0gTElORSgnJywjMjMzLCMyMzQpOwojMjMzID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwtMjAuKSk7CiMyMzQgPSBWRUNUT1IoJycsIzIzNSwxLik7CiMyMzUgPSBESVJFQ1RJT04oJycsKDEuLDAuKSk7CiMyMzYgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMyMzcgPSBQQ1VSVkUoJycsIzcyLCMyMzgpOwojMjM4ID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMjM5KSwjMjQ0KTsKIzIzOSA9IEJfU1BMSU5FX0NVUlZFX1dJVEhfS05PVFMoJycsMywoIzI0MCwjMjQxLCMyNDIsIzI0MyksCiAgLlVOU1BFQ0lGSUVELiwuRi4sLkYuLCg0LDQpLCgwLiwxLiksLlBJRUNFV0lTRV9CRVpJRVJfS05PVFMuKTsKIzI0MCA9IENBUlRFU0lBTl9QT0lOVCgnJywoNTAuMTU2MTM5MDc4ODgxLDE0LjE4MjQxNjY0MDczOCkpOwojMjQxID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg0Mi4yNTA0NDQ5Mjg0NiwyMi4wODgxMTA3OTExNTkpKTsKIzI0MiA9IENBUlRFU0lBTl9QT0lOVCgnJywoMjEuMzM2NDc4OTY2MzgsMzQuMTgyNDE2NjQwNzM4KSk7CiMyNDMgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwLjE1NjEzOTA3ODg4MSwzNC4xODI0MTY2NDA3MzgpKTsKIzI0NCA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzI0NSA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMyNDYsLkYuKTsKIzI0NiA9IEVER0VfQ1VSVkUoJycsIzI0NywjMjIyLCMyNDksLlQuKTsKIzI0NyA9IFZFUlRFWF9QT0lOVCgnJywjMjQ4KTsKIzI0OCA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwwLikpOwojMjQ5ID0gU1VSRkFDRV9DVVJWRSgnJywjMjUwLCgjMjU0LCMyNjEpLC5QQ1VSVkVfUzEuKTsKIzI1MCA9IExJTkUoJycsIzI1MSwjMjUyKTsKIzI1MSA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwwLikpOwojMjUyID0gVkVDVE9SKCcnLCMyNTMsMS4pOwojMjUzID0gRElSRUNUSU9OKCcnLCgwLiwwLiwxLikpOwojMjU0ID0gUENVUlZFKCcnLCMxODEsIzI1NSk7CiMyNTUgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMyNTYpLCMyNjApOwojMjU2ID0gTElORSgnJywjMjU3LCMyNTgpOwojMjU3ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgxLiwwLikpOwojMjU4ID0gVkVDVE9SKCcnLCMyNTksMS4pOwojMjU5ID0gRElSRUNUSU9OKCcnLCgwLiwtMS4pKTsKIzI2MCA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzI2MSA9IFBDVVJWRSgnJywjMjYyLCMyNzApOwojMjYyID0gU1VSRkFDRV9PRl9MSU5FQVJfRVhUUlVTSU9OKCcnLCMyNjMsIzI2OCk7CiMyNjMgPSBCX1NQTElORV9DVVJWRV9XSVRIX0tOT1RTKCcnLDMsKCMyNjQsIzI2NSwjMjY2LCMyNjcpLAogIC5VTlNQRUNJRklFRC4sLkYuLC5GLiwoNCw0KSwoMC4sMS4pLC5QSUVDRVdJU0VfQkVaSUVSX0tOT1RTLik7CiMyNjQgPSBDQVJURVNJQU5fUE9JTlQoJycsKDYwLiw2MC4sMC4pKTsKIzI2NSA9IENBUlRFU0lBTl9QT0lOVCgnJywoNDQuMTg4NjExNjk5MTU4LDYwLiwwLikpOwojMjY2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgyLjkwNDUwNDkxMDkwNUUtMTUsNTUuODExMzg4MzAwODQyLDAuKSk7CiMyNjcgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDQwLiwwLikpOwojMjY4ID0gVkVDVE9SKCcnLCMyNjksMS4pOwojMjY5ID0gRElSRUNUSU9OKCcnLCgtMC4sLTAuLC0xLikpOwojMjcwID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMjcxKSwjMjc1KTsKIzI3MSA9IExJTkUoJycsIzI3MiwjMjczKTsKIzI3MiA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sMC4pKTsKIzI3MyA9IFZFQ1RPUignJywjMjc0LDEuKTsKIzI3NCA9IERJUkVDVElPTignJywoMC4sLTEuKSk7CiMyNzUgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMyNzYgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMjc3LC5GLik7CiMyNzcgPSBFREdFX0NVUlZFKCcnLCMxNjYsIzI0NywjMjc4LC5ULik7CiMyNzggPSBTVVJGQUNFX0NVUlZFKCcnLCMyNzksKCMyODQsIzI5MSksLlBDVVJWRV9TMS4pOwojMjc5ID0gQl9TUExJTkVfQ1VSVkVfV0lUSF9LTk9UUygnJywzLCgjMjgwLCMyODEsIzI4MiwjMjgzKSwKICAuVU5TUEVDSUZJRUQuLC5GLiwuRi4sKDQsNCksKDAuLDEuKSwuUElFQ0VXSVNFX0JFWklFUl9LTk9UUy4pOwojMjgwID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgxMDAuLDQwLiwwLikpOwojMjgxID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg5Mi4wOTQzMDU4NDk1NzksNDcuOTA1Njk0MTUwNDIxLDAuKSk7CiMyODIgPSBDQVJURVNJQU5fUE9JTlQoJycsKDcxLjE4MDMzOTg4NzQ5OSw2MC4sMC4pKTsKIzI4MyA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwwLikpOwojMjg0ID0gUENVUlZFKCcnLCMxODEsIzI4NSk7CiMyODUgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMyODYpLCMyOTApOwojMjg2ID0gTElORSgnJywjMjg3LCMyODgpOwojMjg3ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwwLikpOwojMjg4ID0gVkVDVE9SKCcnLCMyODksMS4pOwojMjg5ID0gRElSRUNUSU9OKCcnLCgxLiwwLikpOwojMjkwID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojMjkxID0gUENVUlZFKCcnLCMxMjYsIzI5Mik7CiMyOTIgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMyOTMpLCMyOTgpOwojMjkzID0gQl9TUExJTkVfQ1VSVkVfV0lUSF9LTk9UUygnJywzLCgjMjk0LCMyOTUsIzI5NiwjMjk3KSwKICAuVU5TUEVDSUZJRUQuLC5GLiwuRi4sKDQsNCksKDAuLDEuKSwuUElFQ0VXSVNFX0JFWklFUl9LTk9UUy4pOwojMjk0ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg1MC4xNTYxMzkwNzg4ODEsMTQuMTgyNDE2NjQwNzM4KSk7CiMyOTUgPSBDQVJURVNJQU5fUE9JTlQoJycsKDQyLjI1MDQ0NDkyODQ2LDIyLjA4ODExMDc5MTE1OSkpOwojMjk2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgyMS4zMzY0Nzg5NjYzOCwzNC4xODI0MTY2NDA3MzgpKTsKIzI5NyA9IENBUlRFU0lBTl9QT0lOVCgnJywoMTAuMTU2MTM5MDc4ODgxLDM0LjE4MjQxNjY0MDczOCkpOwojMjk4ID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojMjk5ID0gQURWQU5DRURfRkFDRSgnJywoIzMwMCksIzI2MiwuRi4pOwojMzAwID0gRkFDRV9CT1VORCgnJywjMzAxLC5GLik7CiMzMDEgPSBFREdFX0xPT1AoJycsKCMzMDIsIzMwMywjMzI4LCMzNTEpKTsKIzMwMiA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMyNDYsLlQuKTsKIzMwMyA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMzMDQsLlQuKTsKIzMwNCA9IEVER0VfQ1VSVkUoJycsIzIyMiwjMzA1LCMzMDcsLlQuKTsKIzMwNSA9IFZFUlRFWF9QT0lOVCgnJywjMzA2KTsKIzMwNiA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sNDAuLDIwLikpOwojMzA3ID0gU1VSRkFDRV9DVVJWRSgnJywjMzA4LCgjMzEzLCMzMjApLC5QQ1VSVkVfUzEuKTsKIzMwOCA9IEJfU1BMSU5FX0NVUlZFX1dJVEhfS05PVFMoJycsMywoIzMwOSwjMzEwLCMzMTEsIzMxMiksCiAgLlVOU1BFQ0lGSUVELiwuRi4sLkYuLCg0LDQpLCgwLiwxLiksLlBJRUNFV0lTRV9CRVpJRVJfS05PVFMuKTsKIzMwOSA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwyMC4pKTsKIzMxMCA9IENBUlRFU0lBTl9QT0lOVCgnJywoNDQuMTg4NjExNjk5MTU4LDYwLiwyMC4pKTsKIzMxMSA9IENBUlRFU0lBTl9QT0lOVCgnJywoMi45MDQ1MDQ5MTA5MDVFLTE1LDU1LjgxMTM4ODMwMDg0MiwyMC4pKTsKIzMxMiA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sNDAuLDIwLikpOwojMzEzID0gUENVUlZFKCcnLCMyNjIsIzMxNCk7CiMzMTQgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMzMTUpLCMzMTkpOwojMzE1ID0gTElORSgnJywjMzE2LCMzMTcpOwojMzE2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwtMjAuKSk7CiMzMTcgPSBWRUNUT1IoJycsIzMxOCwxLik7CiMzMTggPSBESVJFQ1RJT04oJycsKDEuLDAuKSk7CiMzMTkgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMzMjAgPSBQQ1VSVkUoJycsIzcyLCMzMjEpOwojMzIxID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMzIyKSwjMzI3KTsKIzMyMiA9IEJfU1BMSU5FX0NVUlZFX1dJVEhfS05PVFMoJycsMywoIzMyMywjMzI0LCMzMjUsIzMyNiksCiAgLlVOU1BFQ0lGSUVELiwuRi4sLkYuLCg0LDQpLCgwLiwxLiksLlBJRUNFV0lTRV9CRVpJRVJfS05PVFMuKTsKIzMyMyA9IENBUlRFU0lBTl9QT0lOVCgnJywoMTAuMTU2MTM5MDc4ODgxLDM0LjE4MjQxNjY0MDczOCkpOwojMzI0ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgtNS42NTUyNDkyMjE5NjEsMzQuMTgyNDE2NjQwNzM4KSk7CiMzMjUgPSBDQVJURVNJQU5fUE9JTlQoJycsKC00OS44NDM4NjA5MjExMSwyOS45OTM4MDQ5NDE1OCkpOwojMzI2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgtNDkuODQzODYwOTIxMTEsMTQuMTgyNDE2NjQwNzM4KSk7CiMzMjcgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMzMjggPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMzI5LC5GLik7CiMzMjkgPSBFREdFX0NVUlZFKCcnLCMzMzAsIzMwNSwjMzMyLC5ULik7CiMzMzAgPSBWRVJURVhfUE9JTlQoJycsIzMzMSk7CiMzMzEgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDQwLiwwLikpOwojMzMyID0gU1VSRkFDRV9DVVJWRSgnJywjMzMzLCgjMzM3LCMzNDQpLC5QQ1VSVkVfUzEuKTsKIzMzMyA9IExJTkUoJycsIzMzNCwjMzM1KTsKIzMzNCA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sNDAuLDAuKSk7CiMzMzUgPSBWRUNUT1IoJycsIzMzNiwxLik7CiMzMzYgPSBESVJFQ1RJT04oJycsKDAuLDAuLDEuKSk7CiMzMzcgPSBQQ1VSVkUoJycsIzI2MiwjMzM4KTsKIzMzOCA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzMzOSksIzM0Myk7CiMzMzkgPSBMSU5FKCcnLCMzNDAsIzM0MSk7CiMzNDAgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEuLDAuKSk7CiMzNDEgPSBWRUNUT1IoJycsIzM0MiwxLik7CiMzNDIgPSBESVJFQ1RJT04oJycsKDAuLC0xLikpOwojMzQzID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojMzQ0ID0gUENVUlZFKCcnLCM0NCwjMzQ1KTsKIzM0NSA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzM0NiksIzM1MCk7CiMzNDYgPSBMSU5FKCcnLCMzNDcsIzM0OCk7CiMzNDcgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDAuKSk7CiMzNDggPSBWRUNUT1IoJycsIzM0OSwxLik7CiMzNDkgPSBESVJFQ1RJT04oJycsKDAuLC0xLikpOwojMzUwID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojMzUxID0gT1JJRU5URURfRURHRSgnJywqLCosIzM1MiwuRi4pOwojMzUyID0gRURHRV9DVVJWRSgnJywjMjQ3LCMzMzAsIzM1MywuVC4pOwojMzUzID0gU1VSRkFDRV9DVVJWRSgnJywjMzU0LCgjMzU5LCMzNjYpLC5QQ1VSVkVfUzEuKTsKIzM1NCA9IEJfU1BMSU5FX0NVUlZFX1dJVEhfS05PVFMoJycsMywoIzM1NSwjMzU2LCMzNTcsIzM1OCksCiAgLlVOU1BFQ0lGSUVELiwuRi4sLkYuLCg0LDQpLCgwLiwxLiksLlBJRUNFV0lTRV9CRVpJRVJfS05PVFMuKTsKIzM1NSA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwwLikpOwojMzU2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg0NC4xODg2MTE2OTkxNTgsNjAuLDAuKSk7CiMzNTcgPSBDQVJURVNJQU5fUE9JTlQoJycsKDIuOTA0NTA0OTEwOTA1RS0xNSw1NS44MTEzODgzMDA4NDIsMC4pKTsKIzM1OCA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sNDAuLDAuKSk7CiMzNTkgPSBQQ1VSVkUoJycsIzI2MiwjMzYwKTsKIzM2MCA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzM2MSksIzM2NSk7CiMzNjEgPSBMSU5FKCcnLCMzNjIsIzM2Myk7CiMzNjIgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDAuKSk7CiMzNjMgPSBWRUNUT1IoJycsIzM2NCwxLik7CiMzNjQgPSBESVJFQ1RJT04oJycsKDEuLDAuKSk7CiMzNjUgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMzNjYgPSBQQ1VSVkUoJycsIzEyNiwjMzY3KTsKIzM2NyA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzM2OCksIzM3Myk7CiMzNjggPSBCX1NQTElORV9DVVJWRV9XSVRIX0tOT1RTKCcnLDMsKCMzNjksIzM3MCwjMzcxLCMzNzIpLAogIC5VTlNQRUNJRklFRC4sLkYuLC5GLiwoNCw0KSwoMC4sMS4pLC5QSUVDRVdJU0VfQkVaSUVSX0tOT1RTLik7CiMzNjkgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwLjE1NjEzOTA3ODg4MSwzNC4xODI0MTY2NDA3MzgpKTsKIzM3MCA9IENBUlRFU0lBTl9QT0lOVCgnJywoLTUuNjU1MjQ5MjIxOTYxLDM0LjE4MjQxNjY0MDczOCkpOwojMzcxID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgtNDkuODQzODYwOTIxMTEsMjkuOTkzODA0OTQxNTgpKTsKIzM3MiA9IENBUlRFU0lBTl9QT0lOVCgnJywoLTQ5Ljg0Mzg2MDkyMTExLDE0LjE4MjQxNjY0MDczOCkpOwojMzczID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojMzc0ID0gQURWQU5DRURfRkFDRSgnJywoIzM3NSksIzQ0LC5GLik7CiMzNzUgPSBGQUNFX0JPVU5EKCcnLCMzNzYsLkYuKTsKIzM3NiA9IEVER0VfTE9PUCgnJywoIzM3NywjMzc4LCMzOTksIzQwMCkpOwojMzc3ID0gT1JJRU5URURfRURHRSgnJywqLCosIzMyOSwuVC4pOwojMzc4ID0gT1JJRU5URURfRURHRSgnJywqLCosIzM3OSwuVC4pOwojMzc5ID0gRURHRV9DVVJWRSgnJywjMzA1LCMyNCwjMzgwLC5ULik7CiMzODAgPSBTVVJGQUNFX0NVUlZFKCcnLCMzODEsKCMzODUsIzM5MiksLlBDVVJWRV9TMS4pOwojMzgxID0gTElORSgnJywjMzgyLCMzODMpOwojMzgyID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiw0MC4sMjAuKSk7CiMzODMgPSBWRUNUT1IoJycsIzM4NCwxLik7CiMzODQgPSBESVJFQ1RJT04oJycsKDAuLC0xLiwtMC4pKTsKIzM4NSA9IFBDVVJWRSgnJywjNDQsIzM4Nik7CiMzODYgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMzODcpLCMzOTEpOwojMzg3ID0gTElORSgnJywjMzg4LCMzODkpOwojMzg4ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwtMjAuKSk7CiMzODkgPSBWRUNUT1IoJycsIzM5MCwxLik7CiMzOTAgPSBESVJFQ1RJT04oJycsKDEuLDAuKSk7CiMzOTEgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMzOTIgPSBQQ1VSVkUoJycsIzcyLCMzOTMpOwojMzkzID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMzk0KSwjMzk4KTsKIzM5NCA9IExJTkUoJycsIzM5NSwjMzk2KTsKIzM5NSA9IENBUlRFU0lBTl9QT0lOVCgnJywoLTQ5Ljg0Mzg2MDkyMTExLDE0LjE4MjQxNjY0MDczOCkpOwojMzk2ID0gVkVDVE9SKCcnLCMzOTcsMS4pOwojMzk3ID0gRElSRUNUSU9OKCcnLCgwLiwtMS4pKTsKIzM5OCA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzM5OSA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMyMSwuRi4pOwojNDAwID0gT1JJRU5URURfRURHRSgnJywqLCosIzQwMSwuRi4pOwojNDAxID0gRURHRV9DVVJWRSgnJywjMzMwLCMyMiwjNDAyLC5ULik7CiM0MDIgPSBTVVJGQUNFX0NVUlZFKCcnLCM0MDMsKCM0MDcsIzQxNCksLlBDVVJWRV9TMS4pOwojNDAzID0gTElORSgnJywjNDA0LCM0MDUpOwojNDA0ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiw0MC4sMC4pKTsKIzQwNSA9IFZFQ1RPUignJywjNDA2LDEuKTsKIzQwNiA9IERJUkVDVElPTignJywoMC4sLTEuLC0wLikpOwojNDA3ID0gUENVUlZFKCcnLCM0NCwjNDA4KTsKIzQwOCA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzQwOSksIzQxMyk7CiM0MDkgPSBMSU5FKCcnLCM0MTAsIzQxMSk7CiM0MTAgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDAuKSk7CiM0MTEgPSBWRUNUT1IoJycsIzQxMiwxLik7CiM0MTIgPSBESVJFQ1RJT04oJycsKDEuLDAuKSk7CiM0MTMgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiM0MTQgPSBQQ1VSVkUoJycsIzEyNiwjNDE1KTsKIzQxNSA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzQxNiksIzQyMCk7CiM0MTYgPSBMSU5FKCcnLCM0MTcsIzQxOCk7CiM0MTcgPSBDQVJURVNJQU5fUE9JTlQoJycsKC00OS44NDM4NjA5MjExMSwxNC4xODI0MTY2NDA3MzgpKTsKIzQxOCA9IFZFQ1RPUignJywjNDE5LDEuKTsKIzQxOSA9IERJUkVDVElPTignJywoMC4sLTEuKSk7CiM0MjAgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiM0MjEgPSBBRFZBTkNFRF9GQUNFKCcnLCgjNDIyKSwjMTI2LC5GLik7CiM0MjIgPSBGQUNFX0JPVU5EKCcnLCM0MjMsLkYuKTsKIzQyMyA9IEVER0VfTE9PUCgnJywoIzQyNCwjNDI1LCM0MjYsIzQyNywjNDI4KSk7CiM0MjQgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMTEyLC5ULik7CiM0MjUgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMTk2LC5ULik7CiM0MjYgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMjc3LC5ULik7CiM0MjcgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMzUyLC5ULik7CiM0MjggPSBPUklFTlRFRF9FREdFKCcnLCosKiwjNDAxLC5ULik7CiM0MjkgPSBBRFZBTkNFRF9GQUNFKCcnLCgjNDMwKSwjNzIsLlQuKTsKIzQzMCA9IEZBQ0VfQk9VTkQoJycsIzQzMSwuVC4pOwojNDMxID0gRURHRV9MT09QKCcnLCgjNDMyLCM0MzMsIzQzNCwjNDM1LCM0MzYpKTsKIzQzMiA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCM1NiwuVC4pOwojNDMzID0gT1JJRU5URURfRURHRSgnJywqLCosIzE0MiwuVC4pOwojNDM0ID0gT1JJRU5URURfRURHRSgnJywqLCosIzIyMSwuVC4pOwojNDM1ID0gT1JJRU5URURfRURHRSgnJywqLCosIzMwNCwuVC4pOwojNDM2ID0gT1JJRU5URURfRURHRSgnJywqLCosIzM3OSwuVC4pOwojNDM3ID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgzKSAKR0xPQkFMX1VOQ0VSVEFJTlRZX0FTU0lHTkVEX0NPTlRFWFQoKCM0NDEpKSBHTE9CQUxfVU5JVF9BU1NJR05FRF9DT05URVhUCigoIzQzOCwjNDM5LCM0NDApKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCdDb250ZXh0ICMxJywKICAnM0QgQ29udGV4dCB3aXRoIFVOSVQgYW5kIFVOQ0VSVEFJTlRZJykgKTsKIzQzOCA9ICggTEVOR1RIX1VOSVQoKSBOQU1FRF9VTklUKCopIFNJX1VOSVQoLk1JTExJLiwuTUVUUkUuKSApOwojNDM5ID0gKCBOQU1FRF9VTklUKCopIFBMQU5FX0FOR0xFX1VOSVQoKSBTSV9VTklUKCQsLlJBRElBTi4pICk7CiM0NDAgPSAoIE5BTUVEX1VOSVQoKikgU0lfVU5JVCgkLC5TVEVSQURJQU4uKSBTT0xJRF9BTkdMRV9VTklUKCkgKTsKIzQ0MSA9IFVOQ0VSVEFJTlRZX01FQVNVUkVfV0lUSF9VTklUKExFTkdUSF9NRUFTVVJFKDEuRS0wNyksIzQzOCwKICAnZGlzdGFuY2VfYWNjdXJhY3lfdmFsdWUnLCdjb25mdXNpb24gYWNjdXJhY3knKTsKIzQ0MiA9IFBST0RVQ1RfUkVMQVRFRF9QUk9EVUNUX0NBVEVHT1JZKCdwYXJ0JywkLCgjNykpOwpFTkRTRUM7CkVORC1JU08tMTAzMDMtMjE7Cg=="

// function to convert base64 to blob
const base64ToBlob = async (base64, type = 'text/html') => 
  fetch(`data:${type};base64,${base64}`)
  .then(res => res.blob())

// create blob from string above
const blobFile = await base64ToBlob(stepFile)

let shape = await importSTEP(blobFile)
console.log(shape) // check that result is DS_Solid
let shapeRounded = shape.clone().fillet(8).mirror("XZ",10)

return [shape,shapeRounded]}
```

## 9.1 Define points based on directions and distances

``` javascript
function Polar(currentPoint,distance,angleDegToX)
{
    let newPoint = [];
    let angleRad = angleDegToX * Math.PI/180;
    newPoint[0]  = currentPoint[0] + distance * Math.cos(angleRad);
    newPoint[1]  = currentPoint[1] + distance * Math.sin(angleRad);
    return newPoint
}

function PolarX(currentPoint,xdistance,angleDegToX)
{
    let newPoint = [];
    let angleRad = angleDegToX * Math.PI/180;
    newPoint[0]  = currentPoint[0] + xdistance;
    newPoint[1]  = currentPoint[1] + xdistance * Math.tan(angleRad);
    return newPoint
}

function PolarY(currentPoint,ydistance,angleDegToX)
{
    let newPoint = [];
    let angleRad = angleDegToX * Math.PI/180;
    newPoint[0]  = currentPoint[0] + ydistance/Math.tan(angleRad);
    newPoint[1]  = currentPoint[1] + ydistance;
    return newPoint
}
``` 

## 9.2 Circles joined with tangent lines

This function can be used to draw to circle-arcs connected with tangent lines, as an outline for a lever or a droplet. The circle with `radius1` is centered on the origin, the second arc is centered along the x-axis at a distance called `distance`. 


![Creating a drop shape for a lever](https://github.com/raydeleu/ReplicadManual/blob/main/images/droplet1.png)

``` javascript 
function dropView(radius1, radius2, distance)
{
    let sinus_angle = (radius1 - radius2) / distance
    let angle = Math.asin(sinus_angle);

    // points of outer contour of the lever
    let p1 = [radius1 * Math.sin(angle), radius1 * Math.cos(angle)];
    let p2 = [distance + radius2 * Math.sin(angle), radius2 * Math.cos(angle)];
    let p3 = [distance + radius2, 0];
    let p4 = [distance + radius2 * Math.sin(angle), - radius2 * Math.cos(angle)];
    let p5 = [radius1 * Math.sin(angle), - radius1 * Math.cos(angle)];
    let p6 = [- radius1, 0 ];

    let dropDrawing = draw(p1)
                    .lineTo(p2)
                    .threePointsArcTo(p4,p3)
                    .lineTo(p5)
                    .threePointsArcTo(p1,p6)
                    .close();
    
    return dropDrawing}
```


## Create a polar array 

Many CAD programs offer the function to create a polar array of shapes, for example adding holes in a circular pattern. The following script solves this (copied from https://replicad.xyz/docs/recipes/polar-array)

``` javascript
const polarCopies = (shape, count, radius) => {
  const base = shape.translate(0, radius);
  const angle = 360 / count;

  const copies = [];
  for (let i = 0; i < count; i++) {
    copies.push(base.clone().rotate(i * angle));
  }
  return copies;
};
```

The code only works properly if: 

* your original shape is centered at the origin [x,y] = [0,0]
* the circular pattern is located around the origin 

The script works for any shape and therefore both for 2D and 3D shapes. In the case of 3D, it will create the copies in the XY plane (as the default rotation is defined around the z-axis). 


## D.1 Three arm bracket

This is the shape from Solidworks Model Mania 2020. I had to make some adjustments to the model to make it work. The largest difference is that the cutout in each arm does end 1 mm before reaching the cylindrical part in the middle. 

![image](https://github.com/sgenoud/replicad/assets/38007983/101065c2-4504-4bcc-a2fd-a462ac15cdf8)

The model files can be found here: 
https://blogs.solidworks.com/tech/wp-content/uploads/sites/4/Model-Mania-2020-Phase1-drawing.png
https://blogs.solidworks.com/tech/wp-content/uploads/sites/4/Model-Mania-2020-Phase2-drawing.png

As usual the fillets posed the biggest challenge. I solved this by rounding the cutout first before subtracting it from the main shape. Furthermore I cut the holes after filleting the shape to avoid the need to select the edges explicitly. 

The code below contains some failed fillet experiments. The red shape shows the part that I used to create the cutouts in each arm. The green box shows a selection box that I tried to select only a few edges. Strangely enough this failed, whereas filleting the whole shape and then cutting the holes that should not be rounded succeeded. Note that I still had to restrict the rounding within a box (using the `e.InBox` method to avoid rounding the bottom of the shape. 

``` javascript
// Three arm as created for Model Mania 2020
// https://blogs.solidworks.com/tech/wp-content/uploads/sites/4/Model-Mania-2020-Phase1-drawing.png
// https://blogs.solidworks.com/tech/wp-content/uploads/sites/4/Model-Mania-2020-Phase2-drawing.png
// free interpretation as not all fillets were possible in Replicad
// and cutout up to central cylinder posed a problem

function main({Sketcher, 
sketchCircle,Lever,
makeCylinder,
makeBaseBox},{})
{

let r1  = 11;
let r2  = 6;
let d   = 35;
let t   = 3;
let h   = 22;
let fl  = 30;
let bb = 16/2; 
let sb = 4.5/2;
let cb = 8/2; 

// function to create a lever consisting of two circles connected with tangent lines 
// 
// radius1 = radius of circle that is located around the origin
// radius2 = radius of circle that is located at distance D along x-axis
// distance = distance between the two circles
// leverheight = distance over which lever is extruded in z-direction
// 
// note that this function creates a closed shape. If you want holes you have to create two cylinders at 
// the correct position, extrude these a bit more than the leverheight and subtract these from the shape.  

function Lever(radius1, radius2, distance, leverHeight)
{
    let sinus_angle = (radius1 - radius2) / distance
    let angle = Math.asin(sinus_angle);

    // points of outer contour of the lever
    let p1 = [radius1 * Math.sin(angle), radius1 * Math.cos(angle)];
    let p2 = [distance + radius2 * Math.sin(angle), radius2 * Math.cos(angle)];
    let p3 = [distance + radius2, 0];
    let p4 = [distance + radius2 * Math.sin(angle), - radius2 * Math.cos(angle)];
    let p5 = [radius1 * Math.sin(angle), - radius1 * Math.cos(angle)];
    let p6 = [- radius1, 0 ];

    let sketchLever = new Sketcher("XY").movePointerTo(p1)
                    .lineTo(p2)
                    .threePointsArcTo(p4,p3)
                    .lineTo(p5)
                    .threePointsArcTo(p1,p6)
                    .close();
              
    let leverBody = sketchLever.extrude(leverHeight);
       
    return leverBody
}


// function to create lever with holes with standard wallthickness around the holes
// radii refer to outer radii, the holes will be radius - wallThickness
// uses the function lever to create the basic shape 

function leverHoles(radius1,radius2,distance,leverHeight,wallThickness)
{ 
    let leverBody = Lever(radius1,radius2,distance,leverHeight);

    let orig_hole  = sketchCircle(radius1-wallThickness).extrude(leverHeight + 10);
    let dist_hole =  sketchCircle(radius2-wallThickness).extrude(leverHeight + 10).translate([distance,0,0]);
    let lever   = leverBody.cut(orig_hole)
    lever       = lever.cut(dist_hole);
    return lever
}

// function to cut part out of lever to make it lighter
// generally the size of the radii is equal to the size of the holes in the lever


function cutLever(r1,r2,d,h,ts,th)
{
    let cLever = Lever(r1-ts,r2,d,h).translate([0,0,th]);
    cLever=cLever.cut(makeCylinder(r1+ts,h+2*th,[0,0,0],[0,0,1]));
    cLever=cLever.cut(makeCylinder(r2+ts,h+2*th,[d,0,0],[0,0,1]));
    return cLever
}

// create three arms, fuse them together and round the edges in z-direction

let arm1 = Lever(r1,r2,d,h);
let arm2 = Lever(r1,r2,d,h).rotate(120,[0,0,0],[0,0,1])
let arm3 = Lever(r1,r2,d,h).rotate(240,[0,0,0],[0,0,1])
let threeArm = arm1.fuse(arm2);
threeArm = threeArm.fuse(arm3).fillet(fl,(e)=>e.inDirection("Z"));

// cut the three arms so that they slope with 22 degrees towards the end

let side = new Sketcher("XZ").movePointerTo([41,6])
.lineTo([50,6]).lineTo([50,30]).lineTo([0,30])
.lineTo([0,22]).lineTo([11,22]).lineTo([11,6+(30*Math.sin(22*Math.PI/180))])
.close()

let sideCutter = side.revolve()
// NOTE: sideCutter is rotated to avoid edge over first arm!!!
sideCutter = sideCutter.rotate(60,[0,0,0],[0,0,1]);
threeArm = threeArm.cut(sideCutter,false,false)

// fillet the top edges, leaving out the central axle
threeArm = threeArm.fillet(1,(e)=>e.inBox([50,50,2],[-50,-50,20]));

// Phase 2: make arms lighter, note that fillet is applied in this stage already
let cutLever1 = cutLever(bb+1,cb,d,h,3,4).fillet(1);
let cutLever2 = cutLever(bb+1,cb,d,h,3,4).rotate(120,[0,0,0],[0,0,1]).fillet(1);
let cutLever3 = cutLever(bb+1,cb,d,h,3,4).rotate(240,[0,0,0],[0,0,1]).fillet(1);
threeArm = threeArm.cut(cutLever1);
threeArm = threeArm.cut(cutLever2);
threeArm = threeArm.cut(cutLever3);

let selBox = makeBaseBox(5,20,12).translate([22.5,0,9])
// experiments to round edges
//threeArm = threeArm.fillet(0.4,(e)=>e.inBox([20,10,3],[25,0,15]));
//threeArm = threeArm.fillet(0.7,(e)=>e.inDirection("Z"));
//threeArm = threeArm.fillet(0.7,(e)=>e.inPlane("XY"));
threeArm = threeArm.fillet(1,(e)=>e.inBox([50,50,2],[-50,-50,21]))

let smallBore1 = makeCylinder(sb,h,[0,0,0],[0,0,1]).translate([35,0,-5]).rotate(120,[0,0,0],[0,0,1])
let smallBore2 = makeCylinder(sb,h,[0,0,0],[0,0,1]).translate([35,0,-5]).rotate(240,[0,0,0],[0,0,1])
let smallBore3 = makeCylinder(sb,h,[0,0,0],[0,0,1]).translate([35,0,-5]).rotate(360,[0,0,0],[0,0,1])
threeArm = threeArm.cut(smallBore1)
threeArm = threeArm.cut(smallBore2)
threeArm = threeArm.cut(smallBore3)

let counterBore1 = makeCylinder(cb,h,[0,0,0],[0,0,1]).translate([35,0,4])
let counterBore2 = makeCylinder(cb,h,[0,0,0],[0,0,1]).translate([35,0,4]).rotate(120,[0,0,0],[0,0,1])
let counterBore3 = makeCylinder(cb,h,[0,0,0],[0,0,1]).translate([35,0,4]).rotate(240,[0,0,0],[0,0,1])
threeArm = threeArm.cut(counterBore1)
threeArm = threeArm.cut(counterBore2)
threeArm = threeArm.cut(counterBore3)

// create holes for axles
let bigBore = sketchCircle(8).extrude(40).translate([0,0,-10]);
threeArm = threeArm.cut(bigBore);

let shapeArray =[{shape: threeArm, color: "steelblue"}
//,{shape: sideCutter, color:"grey", opacity:0.5}
,{shape: cutLever1, color:"red", opacity:0.5}
,{shape: selBox, color:"green", opacity:0.5}
]

return shapeArray;

}

```

## D.2 Angled bracket

I created the angled bracket defined for the SolidWorks Model Mania 2001 challenge. It was indeed a challenge to model this with Replicad. I started out with combining shapes like cylinders and boxes,  but finally returned to an approach with drawings (sketches). As Solidworks supports constrained-based modelling the dimensions provided in the drawing https://blogs.solidworks.com/tech/wp-content/uploads/sites/4/Model-Mania-2001-Phase-1.jpg are not suited to create a drawing. Therefore I created three functions that allow to define points using angles and distances, either the polar distance or one of the X or Y distances. Using this function I defined points around the contour of each drawing. 

The following drawing created in SolveSpace illustrates the drawing that I needed to recreate in Replicad. The part is called "flange" in the code below.

![mm20012-side](https://github.com/sgenoud/replicad/assets/38007983/b3f4abfa-0c16-4d79-9f92-3499b5bccfb0)

I did not solve the following issues: 

* The rib, shown in the drawing below, is defined by a height of 26 mm, following the curve of the flange and then a curve with radius 55 mm to join towards the base of the shape. I used the `tangentArc` for this curve, but this does not allow to define a radius. I eyeballed the length of the straight segment between the two curves and used this to define the point where the `tangentArc` starts. I plan to define some functions to take the tedious math out of these problems. 

![mm20012-rib](https://github.com/sgenoud/replicad/assets/38007983/e4e2dbca-fde3-4219-9190-df573f4df005)

* After many attempts I was not able to create the fillets between the base block, the flange and the rib. The site https://github.com/alexneufeld/FreeCAD_modelmania/tree/main/2001 shows that it should be possible with FreeCad (based on OpenCascade), so I must be doing something wrong. 

Here is my end-result: 

![mm2001-rc-v2](https://github.com/sgenoud/replicad/assets/38007983/ae7ee1ea-ca23-4fae-85a1-ccd0cdf84baf)

And here is the code: 

```javascript
const {draw,makeCylinder,makeBaseBox} = replicad

// Number of functions to make drawing easier
function Polar(currentPoint,distance,angleDegToX)
{
    let newPoint = [];
    let angleRad = angleDegToX * Math.PI/180;
    newPoint[0]  = currentPoint[0] + distance * Math.cos(angleRad);
    newPoint[1]  = currentPoint[1] + distance * Math.sin(angleRad);
    return newPoint
}

function PolarX(currentPoint,xdistance,angleDegToX)
{
    let newPoint = [];
    let angleRad = angleDegToX * Math.PI/180;
    newPoint[0]  = currentPoint[0] + xdistance;
    newPoint[1]  = currentPoint[1] + xdistance * Math.tan(angleRad);
    return newPoint
}

function PolarY(currentPoint,ydistance,angleDegToX)
{
    let newPoint = [];
    let angleRad = angleDegToX * Math.PI/180;
    newPoint[0]  = currentPoint[0] + ydistance/Math.tan(angleRad);
    newPoint[1]  = currentPoint[1] + ydistance;
    return newPoint
}

function main()
{
// Model Mania 2001 part 1

// break part apart into several components

// cylinder
let startPoint = [-146,0,64];
let cylinderAngleDeg = 45
let cylinderAngle = cylinderAngleDeg*Math.PI/180;
let cylinderDirection = [Math.cos(cylinderAngle),0,Math.sin(cylinderAngle)]
let cylinderHeight = 32; 
let cylinderOuterRadius = 52/2;
let cylinderInnerRadius = 32/2

let cylinderOuter = makeCylinder(cylinderOuterRadius,
cylinderHeight+1,startPoint,cylinderDirection) 
// add millimeter to intrude into the flange
let cylinderInner = makeCylinder(cylinderInnerRadius,
cylinderHeight*2,startPoint,cylinderDirection)
cylinderOuter = cylinderOuter.cut(cylinderInner.clone())
// clone the inner cylinder as we want to re-use it to cut the flange

// base
let baseHeight = 20;
let baseWidth = 96;
let baseLength = 64;
let baseBlock = makeBaseBox(baseHeight,baseWidth,baseLength)
.translate([-baseHeight/2,0,0])

// flange
let flangeWidth = 64;
let flangeRoundingTop = 64/2;
let flangeThickness = 12;
let flangeRounding = 15;
let flangeLength = 146
let pStart = [startPoint[0],startPoint[2]] // 2D representation

let p1 = Polar(pStart,cylinderHeight,cylinderAngleDeg)   // middle of cylinder
let p2 = Polar(p1,flangeRoundingTop,cylinderAngleDeg+90) // clockwise around
let p3 = Polar(p2,flangeThickness,cylinderAngleDeg)
let p4 = PolarY(p3,-p3[1]+baseLength,cylinderAngleDeg-90)   // note that Dy is negative! 
let p5 = [-10,baseLength]
let p6 = [-10,baseLength-flangeThickness]
let p7 = PolarY(p1,-p1[1]+(baseLength-flangeThickness),cylinderAngleDeg-90)

let flange = draw(p1)
.lineTo(p2)
.lineTo(p3)
.lineTo(p4)
.customCorner(flangeRounding)
.lineTo(p5)
.lineTo(p6)
.lineTo(p7)
.customCorner(flangeRounding+flangeThickness)
.close()
.sketchOnPlane("XZ")
.extrude(flangeWidth)
.translate([0,flangeWidth/2,0])
.fillet(31.99,(e)=>e.atAngleWith("X",45).ofLength(flangeThickness))

// rib 
let ribHeight = 26;
let ribRounding = 55;

let r1 = Polar(pStart,cylinderHeight-ribHeight,45)
let r2 = PolarY(r1,-r1[1]+(64-12-26),-45)
let r8 = Polar(r1,ribHeight,45)
let r3 = [r2[0]+25,r2[1]]
let r4 = [-20,0]
let r5 = [-10,0]
let r6 = [-10,52]
let r7 = PolarY(r8,+52-r8[1],-45)

let rib = draw(r1)
.lineTo(r2)
.customCorner(53)
.lineTo(r3)
.tangentArcTo(r4)  // not possible to enter a ribRounding, depends on r3[1]
.lineTo(r5)
.lineTo(r6)
.lineTo(r7)
.customCorner(27)
.lineTo(r8)
.close()
.sketchOnPlane("XZ")
.extrude(12)
.translate([0,6,0])

// M6 outer 11,20mm depth 6mm dia 6.8 mm
let holeSpacing = 60;
let holeMarginSide = 18;
let holeRadius = 6/2;
let holeOuterRadius = 10/2;
let holeMarginFront = 32;

let holeCutter = makeCylinder(holeRadius,baseHeight*4,[0,-holeSpacing/2,holeMarginFront],[-1,0,0])
let holeCutter2 = holeCutter.clone().translate([0,holeSpacing,0])
baseBlock = baseBlock.cut(holeCutter).cut(holeCutter2) 

let counterCutter = makeCylinder(holeOuterRadius,baseHeight*4,[-14,-holeSpacing/2,holeMarginFront],[-1,0,0])
let counterCutter2 = counterCutter.clone().translate([0,holeSpacing,0])
baseBlock = baseBlock.cut(counterCutter).cut(counterCutter2) 

baseBlock = baseBlock.fuse(flange).fuse(rib).fuse(cylinderOuter)
baseBlock = baseBlock.cut(cylinderInner)
.fillet(2,(e)=>e.inDirection("X"))
//.fillet(2,(e)=>e.inDirection("Y"))
.fillet(2,(e)=>e.atAngleWith("X",45))
//.fillet(1,(e)=>e.inBox([0,-10,50],[-40,10,60]))
.rotate(90,[0,0,0],[0,1,0])

return [{shape:baseBlock, color: "steelblue"}]
}
```

## D.3 Plunge watering can

<img width="539" alt="plunge-v6" src="https://user-images.githubusercontent.com/38007983/174858404-ee5f39ba-4d5c-4db0-8d36-e536db95e295.png">

I created this "Plunge" water carafe for plants designed by Robert Bronwasser (see https://www.robertbronwasser.com/project/spring/) in Replicad. It is not an exact copy but demonstrates the capabilities and partly also the limitations of the library. The model consists of three main parts which I called the "body", the "filler" and the "spout". The cone-like body is created as a body of revolution. The filler is built as a loft between three wires, where the middle wire coincides with the top of the body. The spout is a small cylinder at an angle. The shapes are combined in a boolean fuse operation and then filleted. I tried to create a hollow shape by identifying the filler opening and the spout opening, but I could not get that to work. So in the end I created a shell by removing only the opening of the spout. The filler was then opened using a "cutter". 

The code and some remarks regarding kernel errors are shown below"


```` javascript
 // Model of the Plunge watering carafe designed by Robert Bronwasser

function main({
                Sketcher,
                sketchCircle,
                sketchFaceOffset,
                makeCylinder,
                sketchRectangle,
                FaceFinder,
            })
{

// side profile of the bottom of the carafe
let p0 = [0,0]
let p1 = [20,0]
let p2 = [30,5]
let p3 = [30,8]
let p4 = [8,100]   // radius of the top at 100 mm is 8 mm
let p5 = [0,100]

let sideview = new Sketcher("XZ")
.lineTo(p1)
.lineTo(p2)
.lineTo(p3)
.lineTo(p4)
.lineTo(p5)
.close()

// sketch is created on XZ plane, revolve is per default around z-axis
let body = sideview.revolve()

// create cross sections of the filler for the carafe
//          used a workaround to rotate and translate the sketch to the required position
let fillHole = sketchCircle(12).face().rotate(-20,[0,0,0],[0,1,0]).translate([-35,0,135])
fillHole = sketchFaceOffset(fillHole,0);
let topBody = sketchCircle(8).face().translate([0,0,100]);   // radius 8 at 100 mm 
topBody = sketchFaceOffset(topBody,0); 
let fillBottom = sketchCircle(9).face().rotate(20,[0,0,0],[0,1,0]).translate([0,0,80]); 
fillBottom = sketchFaceOffset(fillBottom,0); 

// filler shape is created as a loft between the three wires
let filler    = fillHole.loftWith([topBody,fillBottom],{ruled: false});

// create spout, a cylinder with radius 5, length "lengthSpout"
let angleSpout = 45
let lengthSpout = 70
let spout = makeCylinder(5,lengthSpout,[0,0,0],[0,0,1]).rotate(angleSpout,[0,0,0],[0,1,0]).translate([0,0,100])

// // union the main body with the filler and fillet the junction with radius 30
let plunge = body.fuse(filler);
plunge = plunge.fillet(30,(e)=>e.inPlane("XY",100)) 

// union the shape with the sprout and fillet the junction with radius 10
plunge = plunge.fuse(spout).fillet(10,(e)=>e.inBox([20,20,100],[-20,-20,120]));

// Create a shell 
let pointFiller = [-35,0,135]
let spoutOpening = []
spoutOpening[0] = Math.cos(angleSpout*Math.PI/180)*lengthSpout
spoutOpening[1] = 0
spoutOpening[2] = 100 + Math.sin(angleSpout*Math.PI/180)*lengthSpout

const orifices = new FaceFinder().either([
    (f) => f.containsPoint(pointFiller),
    (f) => f.containsPoint(spoutOpening)]);

// plunge = plunge.shell(-0.5,(f)=>f.inBox([20,20,130],[[-20,-20,155]])); // Kernel Error
// plunge = plunge.shell(-0.5,(f)=>f.containsPoint(pointFiller)); // works!
// plunge = plunge.shell(-0.5,orifices); // Kernel Error
plunge = plunge.shell(-1,(f)=>f.containsPoint(spoutOpening)); // works!

// create cutter boxes 
//      approach to open up another face by subtracting a box from the shape
let cutterFiller = sketchRectangle(40,30).extrude(20).rotate(-20,[0,0,0],[0,1,0]).translate([-30,0,135])
// let cutterSpout = sketchRectangle(40,30).extrude(20).rotate(10,[0,0,0],[0,1,0]).translate([48,0,145])

plunge = plunge.cut(cutterFiller)
// plunge = plunge.cut(cutterSpout)  // resulted in Kernel error without the shell command

// let plungeInner = makeOffset(plunge,-1)  // resulted in Kernel error
// let hollowPlunge = plunge.cut(plungeInner)  // not possible as makeOffset failed

let shapeArray = [
{shape: plunge, name: "plunge", color:"steelblue"}, 
// {shape: fillHole, color:"black"},   // note that after the loft these sketches are deleted? 
// {shape: topBody, color:"black"},
// {shape: fillBottom, color: "black"},
// {shape: filler, color: "yellow"},
// {shape: sprout, color: "blue"},
// {shape: cutterFiller},
// {shape:cutterSpout},
// {shape: test}
]

return shapeArray
}

````


<img width="337" alt="plunge_parts_2,png" src="https://user-images.githubusercontent.com/38007983/175698315-75023470-fa37-4d2c-853d-b06dadee22d1.png">

Using the new option to display a part with opacity I created this image that illustrates some parts that were used to construct the final shape. This option can be very useful to understand how parts are overlapping and why a boolean operation between the shapes could fail. The code above was adapted like this: 

```` javascript 
let shapeArray = [
//{shape: plunge, name: "plunge", color:"steelblue", opacity: 0.5}, 
// {shape: fillHole, color:"black"},   // note that after the loft these sketches are deleted? 
// {shape: topBody, color:"black"},
// {shape: fillBottom, color: "black"},
{shape: body, color: "orange",opacity:0.5},
{shape: filler, color: "red"},
{shape: spout, color: "blue"},
{shape: cutterFiller, color: "green", opacity: 0.5},
// {shape:cutterSpout},
// {shape: test}
]
````
## D.4 Slotted lever

This slotted lever was created using the design from Solidworks Model Mania, https://blogs.solidworks.com/tech/wp-content/uploads/sites/4/Model-Mania-2008-Phase-1.jpg.  

![image](https://github.com/sgenoud/replicad/assets/38007983/d1bb8b31-f6dd-4b1d-9bfd-d51d0de9765f)

I used an intersection of drawings to create the circular slot. The slot is based on an intersection between to circles and a circle-segment. The keyway for the main axle, called `axleHoleShape` is created by fusing two drawings. The shape is missing some fillets as OpenCascade was not able to create these without error. The code still contains two lines for fillets. By uncommenting one of the lines you can check the result, adding both fillets at the same time results in a kernel error.  

``` javascript
const { draw, drawCircle, drawRectangle} = replicad;

const main = () => {

// dimensions of slotted lever
let axleHoleRadius = 22/2;
let axleRadius = 35/2;
let keySlotHeight = 6;
let keySlotWidth  = 2.50;  
let axleWidth = 30;
let dist = 100;
let slotOuterRadius = 12
let slotAngle = 30/180*Math.PI
let dh = axleRadius - slotOuterRadius
let minAngle = Math.asin(-dh/dist);
let maxAngle = minAngle + slotAngle;
let startPoint = [Math.cos(minAngle)*(dist+slotOuterRadius),Math.sin(minAngle)*(dist+slotOuterRadius)]
let endPoint = [Math.cos(maxAngle)*(dist+slotOuterRadius),Math.sin(maxAngle)*(dist+slotOuterRadius)]
let startPointCircle = [Math.cos(minAngle)*(dist),Math.sin(minAngle)*(dist)]
let endPointCircle = [Math.cos(maxAngle)*(dist),Math.sin(maxAngle)*(dist)]

let axle = drawCircle(axleRadius)
.sketchOnPlane("XZ").extrude(axleWidth);

let plate = draw()
.movePointerTo([0,-axleRadius+6])
.lineTo([0,-axleRadius])
.lineTo([100,-axleRadius])
.lineTo([90,-axleRadius+6])
.lineTo([38,-axleRadius+6])
.tangentArc(-5,30)
.tangentArc(50,28)
.polarLineTo([100,33.5])
.ellipseTo([0,axleRadius],175,175)
.lineTo([0,axleRadius-6])
.ellipseTo([0,-axleRadius+6],11,11)
.close().sketchOnPlane("XZ",3).extrude(14)

let slotOuter = drawCircle(dist+slotOuterRadius)
let slotInner = drawCircle(dist-slotOuterRadius)
let segment = draw().lineTo(startPoint).line(0,50).lineTo(endPoint).close()
let slotRing = slotOuter.cut(slotInner)  
let slotSegment = slotRing.intersect(segment)
let slotRoundStart = drawCircle(slotOuterRadius).translate(startPointCircle)
let slotRoundEnd = drawCircle(slotOuterRadius).translate(endPointCircle)
slotSegment = slotSegment.fuse(slotRoundStart)
slotSegment = slotSegment.fuse(slotRoundEnd)
let slotSegmentInner = slotSegment.offset(-6)
let slotSegmentOuter = slotSegment.cut(slotSegmentInner).sketchOnPlane("XZ",2).extrude(16)

let axleHole = drawCircle(axleHoleRadius)
let keySlot  = drawRectangle(2*keySlotWidth,keySlotHeight)
.translate(-axleHoleRadius,0)
let axleHoleShape = axleHole.fuse(keySlot).sketchOnPlane("XZ",-10)
let axleCutter = axleHoleShape.extrude(30+20)
axle = axle.cut(axleCutter)

axle = axle.fuse(slotSegmentOuter)
axle = axle.fuse(plate).fillet(0.8,(e)=>e.inPlane("XZ",2))
axle = axle.fillet(0.8,(e)=>e.inPlane("XZ",2+16))
//axle = axle.fillet(1,e=>e.containsPoint([0,-17,17.5]))
//axle = axle.fillet(1,e=>e.containsPoint([0,3,17.5]))

return [
//{shape: axleCutter, color: "silver", opacity: 0.6},
{shape: axle, color: "steelblue"}
];
};
```



## D.5 Holder for GPS receiver

After almost losing my GNS  receiver, I decided to design a simple holder to hang the receiver on a lanyard. 

<img width="690" alt="image" src="https://github.com/sgenoud/replicad/assets/38007983/011d9314-ed00-4d82-a30d-57a29113cd21">

The code is: 

``` javascript

const defaultParams = {             
    // dimensions of GNS3000 GPS receiver
    gnsLength:     79.25,
    gnsWidth:      45.25,
    gnsHeight:      11.4,
    fit:            1.0,  // tolerance to fit receiver in holder
    thickness:      2.0,  // thickness of holder around receiver
    portionTop:     0.8, // height of holder compared to height of receiver, max 0.87    
    portionSide:    0.85,  // percentage of side cutout compared to length
    assimSide:      0    // asymmetry of side cutout (and increase in length)
    }

const r = replicad

function main(
   {  },   // functions used in main, can be empty if r.function notation is used
   { gnsLength, gnsWidth, gnsHeight, fit, 
   thickness, portionTop, portionSide,assimSide} )  // parameters to adjust the model

  { 
      let length = gnsLength + fit + assimSide;
      let width  = gnsWidth + fit;
      let height = gnsHeight + fit;
      let radius = gnsHeight/2;

    // create shape of GNS3000 receiver  
    let receiverBody = r.makeBaseBox(length,width,height)
    .fillet(radius,(e)=>e.inDirection("X"));
    
    // create holder by adding thickness to the shape of the GNS receiver
    let holder = r.makeBaseBox(length+2*thickness,width+2*thickness,height+2*thickness)
    .fillet(radius+thickness,(e)=>e.inDirection("X"))
    .translate(0,0,-thickness)
      
    // number of shapes to create cut-outs in the holder  
    let cutterTop = r.makeBaseBox(length+4*thickness, width+4*thickness, height)
    .translate(0,0,portionTop*height)
    let cutterSide= r.makeBaseBox(length*portionSide, width+4*thickness, height)
    .translate(assimSide,0,4)
    let cutterBottom = r.makeBaseBox(length,width*0.8,height)
    .fillet(3,(e)=>e.inDirection("X"))
    .translate(length/2,0,2.0)

    // create two holes for a lanyard
    let cylLength = thickness*10  // length of drill for lanyard holes
    let cylRad    = 2             // radius of drill for lanyard holes 
    let holeDist = 7             // distance between lanyard holes
    holeDist = holeDist/2        // half distance for symmetrical holes
    let cutterLanyardL = r.makeCylinder(cylRad,cylLength,[-length/2-cylLength/2,holeDist,5],[1,0,0])
    let cutterLanyardR = r.makeCylinder(cylRad,cylLength,[-length/2-cylLength/2,-holeDist,5],[1,0,0])
    let cutterLanyard = r.makeCompound([cutterLanyardL,cutterLanyardR])

    
    holder = holder.cut(receiverBody)
    holder = holder.cut(cutterTop)
    holder = holder.cut(cutterSide)
    holder = holder.cut(cutterBottom)
    holder = holder.cut(cutterLanyard)
    holder = holder.fillet(2.5,(e)=>e.inBox([length/2-5,50,3],[-length/2+5,-50,3+height]).inDirection("Y"))
    holder = holder.fillet(0.5)
    holder = holder.translate(0,0,thickness)

    let shapeArray = [
        {shape: receiverBody, name:"receiver", color:"grey" },
        {shape: cutterTop, name:"cutterTop", color: "green" , opacity: 0.5},
        {shape: cutterSide, name:"cutterSide", color: "green", opacity:0.5},
        {shape: cutterBottom, name:"cutterBottom", color: "green", opacity:0.5},
        {shape: cutterLanyard, name:"cutterLanyard", color: "green", opacity:0.5},
        {shape: holder, name:"holder", opacity: 1.0},
    ]   

    return  shapeArray
   }

```

I tried the model earlier in CascadeStudio as I am a little bit more familiar with that environment. 

![image](https://github.com/sgenoud/replicad/assets/38007983/dafaa572-68c3-493c-bed1-9732fcbb10dc)

As I struggled with creating nice rounded edges on the top of the holder, I took the opportunity to remodel the part in Replicad. Although initially I had more success, selecting edges in Replicad was also difficult. I used the  ```inBox``` edge selection together with the ```inDirection``` statement for the edges on the side. At the end I rounded all edges with a small radius. 
However, I wonder how in Replicad a selection of just the outer edge would work. See the example in CascadeStudio  below: 

![image](https://github.com/sgenoud/replicad/assets/38007983/71e7d709-83dd-4041-b1bb-1e8f20f53928)

The new WorkBench supports the display of edge identifiers, but the ```inList``` does not seem to work for rounding edges. I still have to experiment whether the ```containsPoint``` would work. 

<img width="540" alt="image" src="https://github.com/sgenoud/replicad/assets/38007983/899e9b08-81fe-4a9d-adc8-62614d46b426">

Here is a second model for a holder for the GPS receiver. The first model required some force to click the receiver into the holder. In this second version the idea is that the receiver can slide into the holder from the top. I removed the top part from the holder so that the holder can be printed on a 3D printer without any supports. Furthermore having an unobstructed topside might aid the reception of the GPS signal. 

![image](https://github.com/sgenoud/replicad/assets/38007983/6df8aca1-b8a1-4207-a4ec-d2f9721462c5)

The code is listed below. Note that I experimented with several `Edgefinders` to create fillets. I used `inDirection`, `inPlane`, `containsPoint`, which all seem to work fine. The option `containsPoint` only works if the location of a point on the edge is known very accurately. Just using the coordinates displayed in the workbench upon highlighting a specific edge does not always work. The better approach is to pick a point that can be derived directly from the dimensions entered by the user. 

``` javascript


const r = replicad

const main = () => {

  let lx = 45.25    // width of gns receiver
  let ly = 79.25;   // length of gns receiver
  let lz = 11.4;    // thickness of gns receiver
  let lt = 0.5 ;    // tolerance for fit around the receiver    
  let th = 2   ;    // thickness of holder around the receiver
  
  let wholder = 20  ;    // width of lanyard holder
  let yholder = 10  ;    // amount that holder sticks out of body
  let rlanhol = 2   ;    // radius of lanyard hole
  let ycut   = 0.6  ; // portion of side length to be cut
  let rlandist = 7  ; // distance between two holes for lanyard, set to 0 for single hole  

  // add tolerances to the dimensions of object to be held
  lx = lx + lt; 
  ly = ly + lt;
  lz = lz + lt; 

  // shape of GNS receiver
  let receiver = r.makeBaseBox(lx,ly,lz)
  .fillet(((lz-lt)/2),(e)=>e.inDirection("Y"))
  .translate([0,0,th])

  // shape of object to be held, length increased to cut upper part
  let hollow = r.makeBaseBox(lx,ly+2*th,lz)
  .fillet(((lz-lt)/2),(e)=>e.inDirection("Y"))
  .translate([0,th,th])

  // shape of holder
  let shape = r.makeBaseBox(lx+2*th,ly+2*th,lz+2*th)
  .fillet((lz+2*th-lt)/2,(e)=>e.inDirection("Y"))

  let lanyardholder = r.makeBaseBox(wholder,ly+(2*th),th).translate([0,yholder,0])
  shape = shape.fuse(lanyardholder)
  
  // define two objects to cut away parts of the holder
  let cutter = r.makeBaseBox(lx*1.2,ly*ycut,lz*2).translate([0,0,2*th])
  cutter = cutter.fillet(5,(e)=>e.inDirection("X"))
  let cutterTop = r.makeBaseBox(lx*1.2,ly*1.2,lz).translate([0,0,(lz+2*th)*0.87])

  // create hollow holder with cutout on side
  let shape1 = shape.cut(hollow)
  let shapeUnrounded = shape1.cut(cutter)

  // now round the outer edge of the cutout
  // do this first as in this state you can select a complete loop with one point
  let shapeRounded = shapeUnrounded
  .fillet(1.0,(e)=>e.containsPoint([0, ly*ycut/2 , lz+2*th]))

  // to round the holder for the lanyard we combine two finders 
  // selecting first the edges in the z direction and the out of 
  // these only select the ones at the proper distance
  shapeRounded = shapeRounded.fillet(0.8*wholder/2,(e)=>e.inDirection("Z").inPlane("XZ",-(((ly+2*th)/2)+yholder)))
 
  let lanyardCutterL = r.makeCylinder(rlanhol,th*4,[rlandist/2,ly/2+yholder/2+th,-2*th],[0,0,1])
  let lanyardCutterR = r.makeCylinder(rlanhol,th*4,[-rlandist/2,ly/2+yholder/2+th,-2*th],[0,0,1])
  shapeRounded = shapeRounded.cut(lanyardCutterL)
  shapeRounded = shapeRounded.cut(lanyardCutterR)

  // now cut the top part of the holder 
  // as this overhang is difficult for the 3D printer,
  // then  round all remaining edges with a smaller radius
  shapeRounded = shapeRounded.cut(cutterTop).fillet(0.6)

  let shapeArray = 
  [ 
  {shape: receiver, name: "receiver", color: "dimgrey", opacity: 0.8},   
  {shape: shapeRounded, name: "holder", color: "steelblue", opacity: 1.0},
  ]
    
return shapeArray
  }
```

As I wanted to create a honeycomb pattern in my model for a GPS holder, I tried different approaches: 
* using a modifier in PrusaSlicer
* using the blingmything app
* using the library presented above

The modifier approach worked fine but did not allow me to achieve a nice symmetrical pattern. Furthermore it allowed only limited control over the geometry of the pattern. The pattern just replicates what would otherwise be the fill pattern for the 3D print. 
The app at blingmything creates a nice symmetrical pattern and also allows to adjust the dimensions of the pattern. But it works on complete faces. The library presented above has the same drawback. 
As I was not able to figure out how I could modify the library, I went the hard way:  

![image](https://github.com/sgenoud/replicad/assets/38007983/f3d35f28-4895-4c06-89d2-8d1e7220c5f7)

This model is created by using a hexagonal column to create a hole, each time intersecting this column with a retangular volume before subtracing it from the shape. The result is as I wanted, but it takes some time to calculate. Using the method of the library the result appears much faster, so there is probably a way to combine the shapes first and then subtracting it in a single operation. 

The code to the shape above is: 

``` javascript
// Experiment to create a holder for GPS Receiver
// added code to create honeycomb pattern 
// within a rectangular shape

const r = replicad

const main = () => {

  // Dimensions of the GPS receiver
  let lx = 45.25;      // width of gns receiver
  let ly = 79.25;      // length of gns receiver
  let lz = 11.4;       // thickness of gns receiver
  let lt = 0.5 ;       // tolerance for fit around the receiver    
  
  let th = 2   ;       // thickness of holder around the receiver
  let wholder = 20  ;    // width of lanyard holder
  let yholder = 10  ;    // amount that holder sticks out of body

  let rlanhol = 2   ;    // radius of lanyard hole
  let ycut    = 0.6  ; // portion of side length to be cut

  let rlandist = 0  ; // distance between two holes for lanyard, set to 0 for single hole  
  
  // code to create a hexagon face 
  function Hexagon(size)
  { 
    let sketchHexagon 
    for(let i = 0 ; i <= 5 ; i += 1)
    {
        const angle = i * 2 * Math.PI / 6
        const xvalue = size * Math.cos(angle);
        const yvalue = size * Math.sin(angle);
        const point = [xvalue,yvalue];

        if (i === 0){
            sketchHexagon = new r.Sketcher("XY",-1).movePointerTo(point)
        }
        else {
            sketchHexagon.lineTo(point)
        }    
    }
    return sketchHexagon.close()
    }

    // code to create a hexagonal column, adding height to hexagon face
    function hexColumn(size,height)
    {
      return Hexagon(size).extrude(height);
    }

  // add tolerances to the dimensions of object to be held
  lx = lx + lt; 
  ly = ly + lt;
  lz = lz + lt; 

  // shape of GNS receiver
  let receiver = r.makeBaseBox(lx,ly,lz)
  .fillet(((lz-lt)/2),(e)=>e.inDirection("Y"))
  .translate([0,0,th])

  // shape of object to be held, length increased to cut upper part
  let hollow = r.makeBaseBox(lx,ly+2*th,lz)
  .fillet(((lz-lt)/2),(e)=>e.inDirection("Y"))
  .translate([0,th,th])

  // shape of holder, selected only top edges for filleting
  // so that the bottom is flat, which is better for 3D printing without supports
  let shape = r.makeBaseBox(lx+2*th,ly+2*th,lz+2*th)
  .fillet((lz+2*th-lt)/2,(e)=>e.inDirection("Y").inPlane("XY",lz+2*th))

  // create a lip on the holder to attach it to a lanyard
  let lanyardholder = r.makeBaseBox(wholder,ly+(2*th),th).translate([0,yholder,0])
  shape = shape.fuse(lanyardholder)
  
  // define two objects to cut away parts of the holder
  let cutter = r.makeBaseBox(lx*1.2,ly*ycut,lz*2).translate([0,0,2*th])
  cutter = cutter.fillet(5,(e)=>e.inDirection("X"))
  let cutterTop = r.makeBaseBox(lx*1.2,ly*1.2,lz).translate([0,0,(lz+2*th)*0.87])

  // create hollow holder with cutout on side
  let shape1 = shape.cut(hollow)
  let shapeUnrounded = shape1.cut(cutter)

  // now round the outer edge of the cutout
  // do this first as in this state you can select a complete loop with one point
  let shapeRounded = shapeUnrounded
  .fillet(1.0,(e)=>e.containsPoint([0, ly*ycut/2 , lz+2*th]))

  // to round the lip for the lanyard we combine two finders 
  // selecting first the edges in the z direction,  out of 
  // these only select the ones at the proper distance
  shapeRounded = shapeRounded.fillet(8,(e)=>e.inDirection("Z").inPlane("XZ",-(((ly+2*th)/2)+yholder)))
 
  // punch two holes in the lip, with distance rlanhol 0 it becomes one hole
  let lanyardCutterL = r.makeCylinder(rlanhol,th*4,[rlandist/2,ly/2+yholder/2+th,-2*th],[0,0,1])
  let lanyardCutterR = r.makeCylinder(rlanhol,th*4,[-rlandist/2,ly/2+yholder/2+th,-2*th],[0,0,1])
  shapeRounded = shapeRounded.cut(lanyardCutterL)
  shapeRounded = shapeRounded.cut(lanyardCutterR)

  // now cut the top part of the holder 
  // as a closed shape is difficult for the 3D printer,
  // then  round all remaining edges with a smaller radius
  // used a chamfer(0.4) instead of fillet(0.6)
  shapeRounded = shapeRounded.cut(cutterTop).fillet(0.6)

  // dimensions of honeycomb grid 
  let hc_width  = 35;
  let hc_length = 65;
  let hc_depth  = 10;  
  // note that hexagons are defined at plane XY, -1

  // number of rows and columns from center of rectangle 
  let rowNumber = 5;
  let colNumber = 2;
  // cellsize and wallthickness of honeycomb 
  let wallThickness = 1;
  let cellSize = 5;
    
  let deg30 = Math.PI / 6
  let delta_x = (1+Math.sin(deg30)) * cellSize + wallThickness*Math.cos(deg30)
  let delta_y = 0.5*wallThickness + Math.cos(deg30)*cellSize

 
  let point = [];
  let cutColumn;
  
  for(let rowCount = 1 ; rowCount <= rowNumber; rowCount += 1)
    {
      for (let colCount = 1 ;  colCount <= colNumber ; colCount += 1)
          {
          // two cells are defined and then replicated in each quadrant 
          // around the center of the grid, so 8 holes are defined each time 
          // This way the grid is always nicely symmetrical. 
          point[1] = [(colCount-1) * 2 * delta_x,(rowCount-1) * delta_y * 2 ,0];
          point[2] = [-(colCount-1) * 2 * delta_x,(rowCount-1) * delta_y * 2 ,0];
          point[3]= [(colCount-1) * 2 * delta_x,-(rowCount-1) * delta_y * 2 ,0];
          point[4] = [-(colCount-1) * 2 * delta_x,-(rowCount-1) * delta_y * 2 ,0];
          point[5] = [(((colCount-1)*2)+1) * delta_x, (rowCount-1)*delta_y*2+delta_y,0];  
          point[6] = [(((colCount-1)*2)+1) * -delta_x, (rowCount-1)*delta_y*2+delta_y,0];
          point[7] = [(((colCount-1)*2)+1) * delta_x, -(rowCount-1)*delta_y*2+delta_y,0];
          point[8] = [(((colCount-1)*2)+1) * -delta_x, -(rowCount-1)*delta_y*2+delta_y,0];
          for (let j=1; j<=8; j+=1)
            { 
              cutColumn = hexColumn(cellSize,5*th).translate(point[j]);
              // the defined column is intersected with a box to limit the grid 
              // within a rectangular shape
              cutColumn = cutColumn.intersect(r.makeBaseBox(hc_width,hc_length,hc_depth)) 
              shapeRounded = shapeRounded.cut(cutColumn);
            }
          }
    }
  
  let shapeArray = 
  [ 
  {shape: receiver, name: "receiver", color: "dimgrey", opacity: 0.8},   
  {shape: shapeRounded, name: "holder", color: "steelblue", opacity: 1.0}
  ]
    
return shapeArray
  
}

```


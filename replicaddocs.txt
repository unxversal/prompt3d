Skip to main content
Replicad Logo
replicad
Documentation
API
Workbench
GitHub

Introduction
Getting Started
The workbench
Drawing
Planes and Sketches
Adding depth
Transformations
Combinations
Finders
Modifications
Sharing models
Making a watering can
Recipes
Examples
replicad as a library
Other ressources
Replicad API

Getting StartedThe workbench
The workbench
So let's use the workbench!

A first example
Let's draw using a basic replicad script. Do not worry about the details for now.

Open the workbench in a new tab and copy this:

const { drawEllipse } = replicad;
const main = () => {
  return drawEllipse(20, 30).sketchOnPlane().extrude(50).fillet(2);
};


You should see something like that:

Your first 3D model

Congratulations, you have built your first model with replicad!

tip
You can click on the Open in workbench button in most code samples to see (and edit them) within the workbench.

The workbench button
Direct links
You can even open a model directly in the workbench if you click on the Open in workbench button next to the copy button!

Working with local files
If you prefer to use your editor of choice it is also possible.

Create a file (model1.js for instance) somewhere on your disk, and then you can point the workbench to that file using the reload menu (left of the menu bar of the editor).

Unfortunately, in order to have all the file reloading abilities you will need to use Chrome (or Edge). The load from disk button does not appear in Firefox and Safari.

Edit this page
Previous
Introduction
Next
Drawing
A first example
Direct links
Working with local files
Docs
Documentation
API
More
ReplicadManual by raydeleu
GitHub
Copyright © 2025 QuaroTech.

Drawing
tip
You can click on the Open in workbench button in most code samples to see (and edit them) within the workbench.

The workbench button
Let's start in two dimensions only, we will add the third one soon enough. replicad provides some classes and functions to draw in the plane.

Let's start with the powerful draw API.

The draw function and the Drawing API
With the drawing API you can draw straight lines and several types of curves. It currently supports:

straight lines
arcs of circles
arcs of ellipses
bezier curves
And for each of these categories it provides a set of functions that should help you draw stuff quickly - or give you as much power as you need. Have a look at the detailed API documentation to see what it can do

A simple drawing
Let's draw something simple:

const { draw } = replicad;
const main = () => {
  return draw().hLine(25).halfEllipse(0, 40, 5).hLine(-25).close();
};


A simple drawing

What have we done?

We start drawing (at the origin, for instance draw([10, 10]) would start at another point.
We then draw an horizontal line of 25 millimeters of length.
Then, we draw an half ellipse, from the last point of the line, moving, by 0 horizontally and by 40 vertically - but drawing an arc of an ellipse with an axis length of 5.
We then go back of 25 horizontally
We finally close the drawing, going from the current last point to the first point with a straight line.
Let's play with the drawing
To understand what the different parameters do, let's play with them:

close with a mirror instead of a straight line with .closeWithMirror instead of close
replace the second horizontal line by a sagitta line (an arc or circle) .hSagittaArc(-25, 10)
change the origin to another point (with draw([10, 10]) for instance).
Drawing functions
In addition to the draw API, replicad provides some drawing functions to draw common and useful shapes. You can for instance:

draw a rectangle drawRoundedRectangle
draw a polygon drawPolysides
circle drawCircle or ellipse drawEllipse
draw some text in a ttf font drawText
draw based on a parametric function drawParametricFunction, with an example here
They are documented in the API

Practicing with the watering can tutorial
You can have a look at a practical example of using the drawing API with the watering can tutorial

replicad
Drawing
DrawingPen
drawRectangle
draw
drawCircle
drawEllipse
drawFaceOutline
drawParametricFunction
drawPointsInterpolation
drawPolysides
drawProjection
drawRoundedRectangle
drawSingleCircle
drawSingleEllipse
drawText
Import
importSTEP
importSTL
Finders
EdgeFinder
FaceFinder
combineFinderFilters
Solids
makeBox
makeCylinder
makeEllipsoid
makeSolid
makeSphere
Measure
measureArea
measureDistanceBetween
measureLength
measureVolume
Other
_1DShape
_3DShape
AssemblyExporter
BaseSketcher2d
Blueprint
Blueprints
BoundingBox
BoundingBox2d
Compound
CompoundBlueprint
CompoundSketch
CompSolid
CornerFinder
Curve
Curve2D
DistanceQuery
DistanceTool
Drawing
Edge
Face
LinearPhysicalProperties
Plane
ProjectionCamera
Shape
Shell
Sketches
Solid
Surface
SurfacePhysicalProperties
Transformation
Vector
Vertex
VolumePhysicalProperties
Wire
WrappingObj
BSplineApproximationConfig
CurveLike
DrawingInterface
ExtrusionProfile
FaceTriangulation
GenericSweepConfig
LoftConfig
ShapeMesh
SketchInterface
AnyShape
ChamferRadius
Corner
CubeFace
CurveType
FilletRadius
FilterFcn
PlaneName
Point
Point2D
ProjectionPlane
RadiusConfig
ScaleMode
Shape2D
Shape3D
SimplePoint
SplineConfig
SupportedUnit
SurfaceType
DEG2RAD
HASH_CODE_MAX
makeCompound
RAD2DEG
addHolesInFace
asDir
asPnt
assembleWire
axis2d
basicFaceExtrusion
cast
complexExtrude
compoundShapes
createAssembly
createNamedPlane
cut2D
cutBlueprints
downcast
exportSTEP
fuse2D
fuseBlueprints
GCWithObject
GCWithScope
genericSweep
getFont
getOC
intersect2D
intersectBlueprints
isPoint
isProjectionPlane
isShape3D
isWire
iterTopo
loadFont
localGC
loft
lookFromPlane
makeAx1
makeAx2
makeAx3
makeBaseBox
makeBezierCurve
makeBSplineApproximation
makeCircle
makeDirection
makeEllipse
makeEllipseArc
makeFace
makeHelix
makeLine
makeNewFaceWithinFace
makeNonPlanarFace
makeOffset
makePlane
makePlaneFromFace
makePolygon
makeProjectedEdges
makeTangentArc
makeThreePointArc
makeVertex
measureShapeLinearProperties
measureShapeSurfaceProperties
measureShapeVolumeProperties
mirror
organiseBlueprints
polysideInnerRadius
polysidesBlueprint
revolution
rotate
roundedRectangleBlueprint
scale
setOC
shapeType
sketchText
supportExtrude
textBlueprints
translate
twistExtrude
weldShellsAndFaces
Sketching
BlueprintSketcher
FaceSketcher
Sketch
Sketcher
GenericSketcher
sketchCircle
sketchEllipse
sketchFaceOffset
sketchHelix
sketchParametricFunction
sketchPolysides
sketchRectangle
sketchRoundedRectangle

Planes and Sketches
We have so far drawn on the 2D plane. But we want to put these drawings in 3D space. For this we will need to define a plane and sketch the drawing into it.

Sketching
In order to show the planes we will need to sketch on them.

const { drawRoundedRectangle } = replicad;

const main = () => {
  return drawRoundedRectangle(100, 50).sketchOnPlane();
};


By default this sketches on the XY plane.

Planes
Now that we know what sketching is, we can see the way to create planes.

Standard planes
There are a bunch of standard planes defined as a string

const { drawRoundedRectangle, makePlane } = replicad;

const main = () => {
  const rect = drawRoundedRectangle(100, 50);
  return [
    { shape: rect.sketchOnPlane(makePlane("XY")), name: "XY", color: "blue" },
    { shape: rect.sketchOnPlane(makePlane("XZ")), name: "XZ", color: "green" },
    { shape: rect.sketchOnPlane(makePlane("YZ")), name: "YZ", color: "red" },
  ];
};


The standard planes

Planes parallel to the standard one
There are a bunch of standard planes defined as a string

const { drawRoundedRectangle, makePlane } = replicad;

const main = () => {
  const rect = drawRoundedRectangle(100, 50);
  return [
    { shape: rect.sketchOnPlane(makePlane("XY")), name: "At 0", color: "blue" },
    {
      shape: rect.sketchOnPlane(makePlane("XY", 20)),
      name: "At 20",
      color: "green",
    },
    {
      shape: rect.sketchOnPlane(makePlane("XY", -20)),
      name: "At -20",
      color: "red",
    },
  ];
};


Sketching shortcut
As these are common ways to sketch a drawing, we have implemented a shortcut within the sketchOnPlane method.

const { drawRoundedRectangle } = replicad;

const main = () => {
  return drawRoundedRectangle(100, 50).sketchOnPlane("XZ", 10);
};


Opposite standard planes
In addition to the standard planes there are their opposite (YX is the opposite of XY). These are the same planes, but with their axis inverted – which also means top and bottom are inverted.

An example will make it more concrete

const { drawRoundedRectangle, makePlane } = replicad;

const main = () => {
  const rect = drawRoundedRectangle(100, 50);
  return [
    { shape: rect.sketchOnPlane("XY", 20), name: "XY at 20", color: "green" },
    { shape: rect.sketchOnPlane("YX", 20), name: "YX at 20", color: "red" },
  ];
};


Opposite planes

We can see that the rectangle has been rotated to match the axis, but also that the direction of the plane is reversed.

Transforming planes
We might want to use planes more different than translations of the origin along the normal of a plane. Note that the order in which you apply these transformations might change the final result.

Translations
We might want to translate the origin of an arbitrary position. Note that the general direction of the plane is the same. Only the origin point has been changed.

const { drawRoundedRectangle, makePlane } = replicad;

const main = () => {
  const plane = makePlane("XZ").translate(-50, 50, 20);
  return drawRoundedRectangle(100, 50).sketchOnPlane(plane);
};


Pivot
We might want to give an angle to our plane. In order to do this, we can pivot the plane around its origin and an axis (which can be a standard direction X, Y, Z, or a generic direction ([1, 1, 0])

const { drawRoundedRectangle, makePlane } = replicad;

const main = () => {
  const plane = makePlane("XY").pivot(30, "Y");
  return drawRoundedRectangle(100, 50).sketchOnPlane(plane);
};


Axes rotation
There is a last operation that can be done on a plane - it is the rotation of its axes around the origin.

const { drawRoundedRectangle, makePlane } = replicad;

const main = () => {
  const plane = makePlane("XY").rotate2DAxes(30, "Y");
  return drawRoundedRectangle(100, 50).sketchOnPlane(plane);
};


Summary
You can look at the different operations with the same base plane and drawing.

const { drawRoundedRectangle, makePlane } = replicad;

const main = () => {
  const rect = drawRoundedRectangle(100, 50);

  const plane = makePlane("XY", 10);
  return [
    { shape: rect.sketchOnPlane(plane), name: "Base", opacity: 0.5 },
    {
      shape: rect.sketchOnPlane(plane.translateY(-70)),
      name: "Translated",
      opacity: 0.5,
      color: "green",
    },
    {
      shape: rect.sketchOnPlane(plane.pivot(30)),
      name: "Pivoted",
      opacity: 0.5,
      color: "orange",
    },
    {
      shape: rect.sketchOnPlane(plane.rotate2DAxes(30)),
      name: "Rotated",
      opacity: 0.5,
      color: "purple",
    },
  ];
};


Practicing with the watering can tutorial
You can have a look at a practical example of using the drawing API with the watering can tutorial

Adding depth
Once you have a sketch, you want to add some depth to it. replicad offers all the standard methods to do this.

You can find the detailed API documentation here

Extrusion
The sketch extruded

The simplest way to "add depth" is to take the face that we have and add thickness, to extrude it in other words.

const { draw } = replicad;
const main = () => {
  return draw()
    .hLine(25)
    .halfEllipse(0, 40, 5)
    .hLine(-25)
    .close()
    .sketchOnPlane("XZ")
    .extrude(10);
};


This is exactly what we have done, but added a depth of 10mm.

Variations on the extrusion
We can play a bit with the extrusion as well, in addition to the extrusion length we can change:

the direction of the extrusion (by default normal to the sketching plane), .extrude(10, { extrusionDirection: [0, 1, 0.5] })
add a twisting motion to the shape (angle in degrees) .extrude(10, { twistAngle: 10 })
Revolution
The sketch revolved

Let's make this shape rotate on an axis, which is, by default the Z axis

const { draw } = replicad;
const main = () => {
  return draw()
    .hLine(25)
    .halfEllipse(0, 40, 5)
    .hLine(-25)
    .close()
    .sketchOnPlane("XZ")
    .revolve();
};


Loft
A loft between two sketches

With a loft we make a smooth transition between two sketches (simple ones, different from the one we had before).

const { drawRoundedRectangle, drawCircle } = replicad;
const main = () => {
  const rect = drawRoundedRectangle(5, 10).sketchOnPlane();
  const circle = drawCircle(3).sketchOnPlane("XY", 10);
  return rect.loftWith(circle);
};


Variations on the loft
You can also play a bit with the loft.

By adding a point at the end (or the start) of the loft:
const { drawRoundedRectangle, drawCircle } = replicad;
const main = () => {
  const rect = drawRoundedRectangle(5, 10).sketchOnPlane();
  const circle = drawCircle(3).sketchOnPlane("XY", 10);

  return rect.loftWith(circle, { endPoint: [2, 2, 15] });
};


By having multiple lofted sketches
const { drawRoundedRectangle, drawCircle } = replicad;
const main = () => {
  const rect = drawRoundedRectangle(5, 10).sketchOnPlane();
  const circle = drawCircle(3).sketchOnPlane("XY", 10);
  const rect2 = drawRoundedRectangle(5, 10, 1).sketchOnPlane("XY", 20);

  return rect.loftWith([circle, rect2]);
};


Practicing with the watering can tutorial
You can have a look at a practical example of using the drawing API with the watering can tutorial

Transformations
Now that we have a 3D shape it is time to move it around. Note that usually you will transform a shape in order to align it with another shape, for instance, or to have different versions of a same basic shape.

For this part of the tutorial we will create a weird, non symmetrical shape:

const { draw } = replicad;
const main = () => {
  const shape = draw()
    .movePointerTo([50, 50])
    .hLine(-120)
    .vSagittaArc(-80, -20)
    .sagittaArc(100, 20, 60)
    .close()
    .sketchOnPlane()
    .extrude(100, { extrusionProfile: { profile: "linear", endFactor: 0.5 } });

  return shape;
};


A weird shape to transform

Let's move stuff around
This is fairly straightforward. We have a shape, we translate it on the axes (or on a vector)

return shape.translateZ(20);

You can see the 2cm between the base of the shape and the grid

Let's rotate this thing
return shape.rotate(45, [0, 0, 0], [1, 0, 0]);

The shape is rotated 45 degrees around an axis going through the origin and in the X direction. Try to move these points around to see what is going on.

Finally mirroring
return shape.mirror("XZ");

The mirror image of the shape!

Combinations
It is now time to introduce a way to combine shapes together, the main operations of constructive geometry, also known as the boolean operations.

We will play with two shapes, a box and a cylinder.

Pasting shapes together
This is what we call the fuse operation:

const { drawRoundedRectangle, drawCircle } = replicad;
const main = () => {
  const cylinder = drawCircle(20).sketchOnPlane().extrude(50);
  const box = drawRoundedRectangle(60, 90).sketchOnPlane().extrude(25);

  return box.fuse(cylinder);
};


the box and cylinder fused

Cutting one shape with another
This is what we call the cut operation:

const { drawRoundedRectangle, drawCircle } = replicad;
const main = () => {
  const cylinder = drawCircle(20).sketchOnPlane().extrude(50);
  const box = drawRoundedRectangle(60, 90).sketchOnPlane().extrude(25);

  return box.cut(cylinder);
};


the cylinder cut into the box

Intersecting two shapes
For the intersection we will intersect the cylinder with itself. This creates a fun shape:

const { drawRoundedRectangle, drawCircle } = replicad;
const main = () => {
  const cylinder = drawCircle(20).sketchOnPlane().extrude(50);
  const sideCylinder = cylinder.clone().rotate(90, [0, 0, 20], [1, 0, 0]);

  return sideCylinder.intersect(cylinder);
};


the cylinder intersecting itself

Finders
When using a visual interface to draw in 3D, selecting a face or an edge is trivial - the user just needs to click it.

In the case of code CAD, this is a more complicated operation - we need to find these as features. This is what finders are for.

For this tutorial we will use this relatively complex shape (a simple house):

const { draw, drawCircle, drawRoundedRectangle } = replicad;
const main = () => {
  let house = draw()
    .hLine(50)
    .vLine(60)
    .line(-50, 20)
    .closeWithMirror()
    .sketchOnPlane("XZ")
    .extrude(30);

  const window = drawCircle(10)
    .sketchOnPlane("XZ")
    .extrude(30)
    .translate([10, 0, 50]);

  const door = drawRoundedRectangle(20, 30)
    .sketchOnPlane("XZ")
    .extrude(30)
    .translate([-20, -5, 15]);

  house = house.cut(window).fuse(door);
  return house;
};


We will use a feature of the viewer, where you can highlight programatically some faces (or edges).

the house

Basic finders usage
Finding faces
In order to find faces, we create a face finder object. Let's say we want to find the face of the door

const main = () => {
  let house = draw();
  //...

  return {
    shape: house,
    highlightFace: (f) => f.inPlane("XZ", 35),
  };
};

This was fairly easy, the door is the face parallel to the plane XZ, at the coordinate 35.

There are many different types of filters like inPlane that allow you to specify precisely which face you are interested in. For instance you can look for faces that:

have a certain type of surface f.ofSurfaceType("CYLINDRE") will return the inside of the window.
contain a certain point f.containsPoint([0, -15, 80]) will return both sides of the roof
and other methods you can find in the API documentation

Finding edges
To find edges, it works in the same way, you just work with an EdgeFinder instead of a face finder and use the methods that are documented here.

For instance, to find the top of the roof

  let house = draw()
  //...

  const findRooftop = new EdgeFinder()

  return {
    shape: house,
    highlightEdge: e => e.containsPoint([0, -15, 80])
  };
};

Combinating filters
By default you can chain different filter conditions. Only the shapes that follow all the conditions will be found. For instance, to find the window of the back of the house:

  let house = draw()
  //...

  return {
    shape: house,
    highlightEdge: e => e.ofCurveType("CIRCLE").inPlane("XZ")
  };
};

If you only use one of the filters you will see more edges highlighted.

Combinating with an either condition
In some cases you might want to combine elements with an OR condition, to find faces that fit either one condition or the other. For instance if we want to find both side faces:

(f) => f.either([(f) => f.inPlane("YZ", 50), (f) => f.inPlane("YZ", -50)]);

Negating a condition
You might also want to specify the inverse of a condition, that is what not is for. For instance, we can select the front window by just adding a not to the finder we created earlier

const frontWindow = (e) => e.ofCurveType("CIRCLE").not((f) => f.inPlane("XZ"));

Note that it works because there are only two edges that are circles in the house.

Finding faces and edges
We have created finders so far and used them to highlight faces and edges

but what are they really useful for.
This will be mostly clear in the next chapter with modifications that can make a lot of use of finders.

You can also find a specific face. For instance, we might want to have only the front face of the house. For this you will need to use the FaceFinder and EdgeFinder objects directly (instead of within a function that already declared it).

const { draw, drawCircle, drawRoundedRectangle, FaceFinder } = replicad;
const main = () => {
  let house = draw()
    .hLine(50)
    .vLine(60)
    .line(-50, 20)
    .closeWithMirror()
    .sketchOnPlane("XZ")
    .extrude(30);

  const window = drawCircle(10)
    .sketchOnPlane("XZ")
    .extrude(30)
    .translate([10, 0, 50]);

  const door = drawRoundedRectangle(20, 30)
    .sketchOnPlane("XZ")
    .extrude(30)
    .translate([-20, -5, 15]);

  house = house.cut(window).fuse(door);

  return new FaceFinder().inPlane("XZ", 30).find(house);
};

Modifications
In addition to the shape transformations and shape combinations, it is also possible to apply some advanced modifications to shapes. These modifications use finders to filter out which face or edges they need.

Fillet and chamfer
Adding fillet (rounded edges) and chamfers (beveled edges) is a very common operation when modelling in 3D. These operations are mainly configured by their radius.

const { drawRoundedRectangle } = replicad;
const main = () => {
  return drawRoundedRectangle(30, 50).sketchOnPlane().extrude(20).fillet(2);
};


When configuring a fillet with a number, all the edges of the shape will be filleted.

If you want to target specific edges you will need to configure a finder within a filter configuration. For instance to fillet only the top edges:

const { drawRoundedRectangle } = replicad;
const main = () => {
  return drawRoundedRectangle(30, 50)
    .sketchOnPlane()
    .extrude(20)
    .fillet(2, (e) => e.inPlane("XY", 20));
};


Multiple radii
What if you want to apply different radii for different edges? You can use a function that will combine filter configurations.

In this case we want to have a bigger fillet on the sides of the box and a small one at the top. You might have been able to do this with two different fillet operations, but in some cases the kernel has more difficulties finding a good solution with multiple operations.

const { drawRoundedRectangle, EdgeFinder, combineFinderFilters } = replicad;
const main = () => {
  const [filters] = combineFinderFilters([
    {
      filter: new EdgeFinder().inPlane("XY", 20),
      radius: 2,
    },
    {
      filter: new EdgeFinder().inDirection("Z"),
      radius: 9,
    },
  ]);

  return drawRoundedRectangle(30, 50)
    .sketchOnPlane()
    .extrude(20)
    .fillet(filters);
};


Asymmetric chamfer
By default chamfer operations will use a radius, the same distance on both sides of a edge. If you want to use a different distance on each side and create an asymmetric chamfer, you can use a custom radius:

const { makeBaseBox, EdgeFinder } = replicad;

export default function main() {
  let base = makeBaseBox(30, 50, 10);
  return base.chamfer(
    {
      distances: [5, 2],
      selectedFace: (f) => f.inPlane("YZ", 15),
    },
    (e) => e.inPlane("XY", 10)
  );
}


The selected face corresponds to the face on which the first distance will be applied.

Fillet with radius evolution
You can also have a fillet vary along the edge. This is done by using an array of two numbers. The first number is the radius at the start of the edge, and the second number is the radius at the end of the edge.

const { makeBaseBox } = replicad;

export default function main() {
  let base = makeBaseBox(30, 50, 10);
  return base.fillet([4, 1], (e) => e.inPlane("YZ", 15).inDirection("Y"));
}


Shell
With a shell you can hollow out a full shape (keeping a wall of a certain thickness). You need to specify a face that will be hollow, and you configure a finder for this.

const { drawRoundedRectangle } = replicad;
const main = () => {
  return drawRoundedRectangle(30, 50)
    .sketchOnPlane()
    .extrude(20)
    .shell(5, (f) => f.inPlane("XY", 20));
};

Introduction
Do you like to follow steps to learn? This tutorial is for you - it allows you to build this plunge watering can by using the replicad APIs.


Note that this model is inspired by Robert Bronwasser's watering can. The original implementation comes from our community.

If you want to follow along you can click on the workbench icon (next to copy!) in the code examples!

Drawing the body profile
tip
You can click on the Open in workbench button in most code samples to see (and edit them) within the workbench.

The workbench button
So let's start by the body of our can. We will take the general approach of drawing a profile that will then be revolved.

Let's start with our basic shape:

const { draw } = replicad;

const main = () => {
  return draw()
    .hLine(20)
    .line(10, 5)
    .vLine(3)
    .lineTo([8, 100])
    .hLine(-8)
    .close();
};


We drew a simple shape following the profile using only straight lines. We generally went for relative positioning. For instance with hLine(20) which draws an horizontal line of 20mm of length). An line(10, 5) which draws a line by going 10 horizontally and 5 vertically. But we also used lineTo([8, 100]) which moves us to the point [8, 100] - this is using absolute coordinates.

Filleting angles
The bottom of the can is rounded. We could use different methods for that. First, we will use round the corners of the previous shape (using filleting)

const { draw } = replicad;

const main = () => {
  return draw()
    .hLine(20)
    .customCorner(2)
    .line(10, 5)
    .customCorner(3)
    .vLine(3)
    .customCorner(3)
    .lineTo([8, 100])
    .hLine(-8)
    .close();
};


Arcs of circles
We can also draw arcs of a circle directly.

const { draw } = replicad;

const main = () => {
  return draw().hLine(20).tangentArc(10, 10).lineTo([8, 100]).hLine(-8).close();
};


This is not the best use of these here, but I wanted to show you for the example.

Bézier curves
Better would be to use Bézier curves with the smoothSpline method.

const { draw } = replicad;

const main = () => {
  return draw([0, 100])
    .hLine(8)
    .lineTo([30, 8])
    .smoothSpline(-10, -8, { endTangent: [-1, 0], startFactor: 2 })
    .lineTo([0, 0])
    .close();
};


We reoriented the drawing to start from the top (and to not have to compute the direction of the end tangent ourselves). By varying the startFactor we can reach a shape that we like.

Comparing the different cases
Here a just a comparison of the different profiles we achieved.

const { draw } = replicad;

const main = () => {
  // just lines
  const s1 = draw()
    .hLine(20)
    .line(10, 5)
    .vLine(3)
    .lineTo([8, 100])
    .hLine(-8)
    .close();

  // Using bezier curves
  const s2 = draw([0, 100])
    .hLine(8)
    .lineTo([30, 8])
    .smoothSpline(-10, -8, { endTangent: [-1, 0], startFactor: 2 })
    .lineTo([0, 0])
    .close();

  // Straight lines and fillets
  const s3 = draw()
    .hLine(20)
    .customCorner(10)
    .line(10, 5)
    .customCorner(3)
    .vLine(3)
    .customCorner(3)
    .lineTo([8, 100])
    .hLine(-8)
    .close();

  // Arcs
  const s4 = draw()
    .hLine(20)
    .tangentArc(10, 10)
    .lineTo([8, 100])
    .hLine(-8)
    .close();

  return [
    { shape: s1, color: "blue", name: "Straight lines" },
    { shape: s4, color: "orange", name: "Arcs" },
    { shape: s2, color: "green", name: "Bézier" },
    { shape: s3, color: "red", name: "Rounded corners" },
  ];
};


Using planes for the filler
tip
You can click on the Open in workbench button in most code samples to see (and edit them) within the workbench.

The workbench button
In order to build the filler we will need to place three circles (that will be lofted later on).

We will approach this by drawing on three different planes. The first one is simple, it corresponds to the plane parallel to the XY plane, but at a certain distance from the origin.

const { drawCircle, makePlane } = replicad;
const main = () => {
  const middlePlane = makePlane("XY", 100);
  return drawCircle(8).sketchOnPlane(middlePlane);
};


Note that sketching on a plane parallel to a standard one (XY, XZ or YZ is a common operation and you can use the shortcut

const { drawCircle } = replicad;
const main = () => {
  return drawCircle(8).sketchOnPlane("XY", 100);
};


Plane translations
What we have done here could also be done with a plane translation.

const { drawCircle, makePlane } = replicad;
const main = () => {
  const middlePlane = makePlane("XY").translateZ(100);
  return drawCircle(8).sketchOnPlane(middlePlane);
};


A translation changes the origin point of a plane (not its orientation).

Plane pivots
What if you want a plane that is not parallel to one of the standard ones? You can pivot it on it's origin following a direction.

const { drawCircle, makePlane } = replicad;
const main = () => {
  const topPlane = makePlane().pivot(-20, "Y");
  return drawCircle(12).sketchOnPlane(topPlane);
};


The circle is drawn with an angle of 20 degrees along the Y axis.

Putting it all together to build the filler
With the filler we want 3 circles, some of them pivoted. We put it all together like this:

const { drawCircle, makePlane } = replicad;

const main = () => {
  const topPlane = makePlane().pivot(-20, "Y").translate([-35, 0, 135]);
  const topCircle = drawCircle(12).sketchOnPlane(topPlane);

  const middleCircle = drawCircle(8).sketchOnPlane("XY", 100);

  const bottomPlane = makePlane().pivot(20, "Y").translateZ(80);
  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);

  return [
    { shape: topCircle, name: "Top Circle" },
    { shape: middleCircle, name: "Middle Circle" },
    { shape: bottomCircle, name: "Bottom Circle" },
  ];
};


We will want to use all these circles with a "loft" operation later on.

Edit this page


Creating the 3D shapes
tip
You can click on the Open in workbench button in most code samples to see (and edit them) within the workbench.

The workbench button
We now have the basic drawing to create our 3D shapes:

the can body for which we have a profile drawing
the filler for which we have three well positioned circles
the spout which is a simple cylinder
The spout cylinder
Creation of a cylinder
We have two different approaches we could take to create a cylinder:

draw a circle and extrude it
creating the cylinder with a direct function
Extrusion
To create a cylinder we can draw a circle, sketch it in 3D space, and then a extrude it.

const { drawCircle } = replicad;
const main = () => {
  return drawCircle(5).sketchOnPlane().extrude(70);
};


We have seen the first step in the previous page. We draw a circle and sketch it in the 3D space on a plane (here the default XY plane).

We extrude it, making a copy of itself in a certain direction and filling the sides.

using a direct creation method
const { makeCylinder } = replicad;
const main = () => {
  return makeCylinder(5, 70);
};


Positioning the shape
In the case of a circle that we extrude, we could place the plane to sketch on and then position it.

We have seen how to position a plane in 3D space, but we might want to position a 3D shape.

The operations are similar for a shape as for a plane. First, translations are identical.

const { makeCylinder } = replicad;
const main = () => {
  return makeCylinder(5, 70).translateZ(100);
};


Rotations are similar to pivots for planes - but as shapes do not have an origin point by default, we need to specify it.

const { makeCylinder } = replicad;
const main = () => {
  return makeCylinder(5, 70).translateZ(100).rotate(45, [0, 0, 100], [0, 1, 0]);
};


In order to make things more readable, we might want to rotate before we translate (with a different origin).

The can body
To create the can body we will use the profile we drew, sketch it on the XZ plane and rotate it around the Z axis:

const { draw } = replicad;

const main = () => {
  const profile = draw()
    .hLine(20)
    .line(10, 5)
    .vLine(3)
    .lineTo([8, 100])
    .hLine(-8)
    .close();

  return profile.sketchOnPlane("XZ").revolve([0, 0, 1]);
};


The filler
After extrusion and revolution, the filler uses a third method of 3D shape creation: lofting. We can create shapes by defining sections through which an object will pass trough.

We have defined our three circles and now we create a shape that passes through them all.

const { makePlane, drawCircle } = replicad;

const main = () => {
  const topPlane = makePlane().pivot(-20, "Y").translate([-35, 0, 135]);
  const topCircle = drawCircle(12).sketchOnPlane(topPlane);

  const middleCircle = drawCircle(8).sketchOnPlane("XY", 100);

  const bottomPlane = makePlane().pivot(20, "Y").translateZ(80);
  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);

  return topCircle.loftWith([middleCircle, bottomCircle], { ruled: false });
};


Putting it all together
Let's show all the pieces we have built so far together

const { makePlane, makeCylinder, draw, drawCircle } = replicad;

const main = () => {
  // Building the body
  const profile = draw()
    .hLine(20)
    .line(10, 5)
    .vLine(3)
    .lineTo([8, 100])
    .hLine(-8)
    .close();

  const body = profile.sketchOnPlane("XZ").revolve([0, 0, 1]);

  // Building the spout
  const topPlane = makePlane().pivot(-20, "Y").translate([-35, 0, 135]);
  const topCircle = drawCircle(12).sketchOnPlane(topPlane);

  const middleCircle = drawCircle(8).sketchOnPlane("XY", 100);

  const bottomPlane = makePlane().pivot(20, "Y").translateZ(80);
  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);

  const filler = topCircle.loftWith([middleCircle, bottomCircle], {
    ruled: false,
  });

  const spout = makeCylinder(5, 70)
    .translateZ(100)
    .rotate(45, [0, 0, 100], [0, 1, 0]);

  return [
    { shape: body, color: "blue", opacity: 0.5 },
    { shape: filler, color: "red", opacity: 0.5 },
    { shape: spout, color: "green" },
  ];
};

Combining the shapes
tip
You can click on the Open in workbench button in most code samples to see (and edit them) within the workbench.

The workbench button
Now that we have our three bodies we want to put them together (and smooth the corners it creates).

Fusing shapes together is easy:

const { makePlane, makeCylinder, draw, drawCircle } = replicad;

const main = () => {
  // Building the body
  const profile = draw()
    .hLine(20)
    .line(10, 5)
    .vLine(3)
    .lineTo([8, 100])
    .hLine(-8)
    .close();

  const body = profile.sketchOnPlane("XZ").revolve([0, 0, 1]);

  // Building the spout
  const topPlane = makePlane().pivot(-20, "Y").translate([-35, 0, 135]);
  const topCircle = drawCircle(12).sketchOnPlane(topPlane);

  const middleCircle = drawCircle(8).sketchOnPlane("XY", 100);

  const bottomPlane = makePlane().pivot(20, "Y").translateZ(80);
  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);

  const filler = topCircle.loftWith([middleCircle, bottomCircle], {
    ruled: false,
  });

  return body.fuse(filler);
};


The relevant line is just body.fuse(filler).

Selection and filleting
We want to smooth the transition between the two bodies we just merged, we will use a fillet. But for this we need to select the edges that will need to be smoothed.

const { makePlane, makeCylinder, draw, drawCircle } = replicad;

const main = () => {
  // Building the body
  const profile = draw()
    .hLine(20)
    .line(10, 5)
    .vLine(3)
    .lineTo([8, 100])
    .hLine(-8)
    .close();

  const body = profile.sketchOnPlane("XZ").revolve([0, 0, 1]);

  // Building the spout
  const topPlane = makePlane().pivot(-20, "Y").translate([-35, 0, 135]);
  const topCircle = drawCircle(12).sketchOnPlane(topPlane);

  const middleCircle = drawCircle(8).sketchOnPlane("XY", 100);

  const bottomPlane = makePlane().pivot(20, "Y").translateZ(80);
  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);

  const filler = topCircle.loftWith([middleCircle, bottomCircle], {
    ruled: false,
  });

  const fused = body.fuse(filler);

  return {
    shape: fused,
    highlightEdge: (e) => e.inPlane("XY", 100),
  };
};


Once we have found the edges we are concerned about using the finder API, we can fillet them like this:

const { makePlane, makeCylinder, draw, drawCircle } = replicad;

const main = () => {
  // Building the body
  const profile = draw()
    .hLine(20)
    .line(10, 5)
    .vLine(3)
    .lineTo([8, 100])
    .hLine(-8)
    .close();

  const body = profile.sketchOnPlane("XZ").revolve([0, 0, 1]);

  // Building the spout
  const topPlane = makePlane().pivot(-20, "Y").translate([-35, 0, 135]);
  const topCircle = drawCircle(12).sketchOnPlane(topPlane);

  const middleCircle = drawCircle(8).sketchOnPlane("XY", 100);

  const bottomPlane = makePlane().pivot(20, "Y").translateZ(80);
  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);

  const filler = topCircle.loftWith([middleCircle, bottomCircle], {
    ruled: false,
  });

  const fused = body.fuse(filler).fillet(30, (e) => e.inPlane("XY", 100));

  return {
    shape: fused,
  };
};


And then repeat the operation for the spout:

const { makePlane, makeCylinder, draw, drawCircle } = replicad;

const main = () => {
  // Building the body
  const profile = draw()
    .hLine(20)
    .line(10, 5)
    .vLine(3)
    .lineTo([8, 100])
    .hLine(-8)
    .close();

  const body = profile.sketchOnPlane("XZ").revolve([0, 0, 1]);

  // Building the spout
  const topPlane = makePlane().pivot(-20, "Y").translate([-35, 0, 135]);
  const topCircle = drawCircle(12).sketchOnPlane(topPlane);

  const middleCircle = drawCircle(8).sketchOnPlane("XY", 100);

  const bottomPlane = makePlane().pivot(20, "Y").translateZ(80);
  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);

  const filler = topCircle.loftWith([middleCircle, bottomCircle], {
    ruled: false,
  });

  const spout = makeCylinder(5, 70)
    .translateZ(100)
    .rotate(45, [0, 0, 100], [0, 1, 0]);

  return body
    .fuse(filler)
    .fillet(30, (e) => e.inPlane("XY", 100))
    .fuse(spout)
    .fillet(10, (e) => e.inBox([20, 20, 100], [-20, -20, 120]));
};


Creating an hollow shape
For now, we still have a full shape. We need to make it hollow - to be able to put water in it. Remember we are building a watering can.

This is similar to how we fillet, but instead of selecting edges we select the faces that will be hollowed out, and give the thickness of the walls.

We need to do a little bit of maths to find the coordinates of the end of the spout.

const { makePlane, makeCylinder, draw, drawCircle } = replicad;

const main = () => {
  // Building the body
  const profile = draw()
    .hLine(20)
    .line(10, 5)
    .vLine(3)
    .lineTo([8, 100])
    .hLine(-8)
    .close();

  const body = profile.sketchOnPlane("XZ").revolve([0, 0, 1]);

  // Building the filler
  const topPlane = makePlane().pivot(-20, "Y").translate([-35, 0, 135]);
  const topCircle = drawCircle(12).sketchOnPlane(topPlane);

  const middleCircle = drawCircle(8).sketchOnPlane("XY", 100);

  const bottomPlane = makePlane().pivot(20, "Y").translateZ(80);
  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);

  const filler = topCircle.loftWith([middleCircle, bottomCircle], {
    ruled: false,
  });

  // Building the spout
  const spout = makeCylinder(5, 70)
    .translateZ(100)
    .rotate(45, [0, 0, 100], [0, 1, 0]);

  let wateringCan = body
    .fuse(filler)
    .fillet(30, (e) => e.inPlane("XY", 100))
    .fuse(spout)
    .fillet(10, (e) => e.inBox([20, 20, 100], [-20, -20, 120]));

  const spoutOpening = [
    Math.cos((45 * Math.PI) / 180) * 70,
    0,
    100 + Math.sin((45 * Math.PI) / 180) * 70,
  ];

  wateringCan = wateringCan.shell(-1, (face) =>
    face.either([
      (f) => f.containsPoint(spoutOpening),
      (f) => f.inPlane(topPlane),
    ])
  );

  return {
    shape: wateringCan,
    name: "Watering Can",
  };
};


We are done!
The previous shape was the final one we were looking for! You can play with it, change some parameters and so on to create your own version!

Why recipes?
There are some operations using replicad (or any CAD tool) that are at the same time very common - but have many different configurations and edge cases.

In tools with a UI, this translates to very complex configuration boxes with multiple options that do not work well together most of the time.

In a code CAD tool like replicad, this would translate to a function with a very complex signature.

In some cases - the basic logic behind this functionality is fairly simple – but the different tweaks possible add the complexity.

Instead of offering these as a standard library with a complex interface, I propose a recipe book of code that can be easily copied and tweaked to your particular needs.

Polar array
Sometimes you want to copy a shape with a circular pattern. This is fairly easy to do with a little bit of javascript.

const polarCopies = (shape, count, radius) => {
  const base = shape.translate(0, radius);
  const angle = 360 / count;

  const copies = [];
  for (let i = 0; i < count; i++) {
    copies.push(base.clone().rotate(i * angle));
  }
  return copies;
};

For the optimal use, take into account that we assume

that your original shape is centered at the origin
that you want to rotate around the origin
that you want to go all around the circle
Let's show an example

const { drawCircle } = replicad;

const polarCopies = (shape, count, radius) => {
  const base = shape.translate(0, radius);
  const angle = 360 / count;

  const copies = [];
  for (let i = 0; i < count; i++) {
    copies.push(base.clone().rotate(i * angle));
  }
  return copies;
};

function main() {
  return polarCopies(drawCircle(5), 5, 12);
}


Note that this code works for both 2D and 3D cases. In the case of 3D, it will do the copies in the XY plane.

const { drawCircle } = replicad;

const polarCopies = (shape, count, radius) => {
  const base = shape.translate(0, radius);
  const angle = 360 / count;

  const copies = [];
  for (let i = 0; i < count; i++) {
    copies.push(base.clone().rotate(i * angle));
  }
  return copies;
};

function main() {
  return polarCopies(drawCircle(5).sketchOnPlane().extrude(2), 5, 12);
}

Swept profile box
Let's say you want to start designing with a box. Simple extrusion is good if you do not have a complex profile. A way to work with a more complex shape is to draw the profile in 2D, and then sweep it along a base sketch.

const { makeSolid, makeFace, assembleWire, EdgeFinder, genericSweep, Plane } =
  replicad;

function profileBox(inputProfile, base) {
  const start = inputProfile.blueprint.firstPoint;
  const profile = inputProfile.translate(-start[0], -start[1]);

  const end = profile.blueprint.lastPoint;

  const baseSketch = base.sketchOnPlane();

  // We create the side of the box
  const side = baseSketch.clone().sweepSketch(
    (plane) => {
      return profile.sketchOnPlane(plane);
    },
    {
      withContact: true,
    }
  );

  // We put all the pieces together
  return makeSolid([
    side,
    // The face generated by sweeping the end of the profile
    makeFace(assembleWire(new EdgeFinder().inPlane("XY", end[1]).find(side))),
    // The face generated by the base
    baseSketch.face(),
  ]);
}

This code assumes some things about its input:

the input profile is a single open line
the base is a single closed line
there is only one profile point at the coordinate of the end of the profile
The box will have its base in the XY plane.

Let's build an example

const { makeSolid, makeFace, assembleWire, EdgeFinder, genericSweep, Plane } =
  replicad;

function profileBox(inputProfile, base) {
  const start = inputProfile.blueprint.firstPoint;
  const profile = inputProfile.translate(-start[0], -start[1]);

  const end = profile.blueprint.lastPoint;

  const baseSketch = base.sketchOnPlane();

  // We create the side of the box
  const side = baseSketch.clone().sweepSketch(
    (plane) => {
      return profile.sketchOnPlane(plane);
    },
    {
      withContact: true,
    }
  );

  // We put all the pieces together
  return makeSolid([
    side,
    // The face generated by sweeping the end of the profile
    makeFace(assembleWire(new EdgeFinder().inPlane("XY", end[1]).find(side))),
    // The face generated by the base
    baseSketch.face(),
  ]);
}

const { draw, drawRoundedRectangle } = replicad;

function main() {
  const base = drawRoundedRectangle(30, 20, 5);

  const profile = draw()
    .line(5, 5)
    .line(2, 3)
    .hLine(-2)
    .vLine(-1)
    .bulgeArcTo([0, 1], 0.2)
    .done();

  return profileBox(profile, base);
}

Fuse All
You might find yourself in a situation where you have an array of shapes (2D or 3D) and you just want to fuse (or intersect) them all together. The following snippet just does this

const fuseAll = (shapes) => {
  let result = shapes[0];
  shapes.slice(1).forEach((shape) => {
    result = result.fuse(shape);
  });
  return result;
};

Let's show an example (also using polar copies).

const { drawCircle } = replicad;

const polarCopies = (shape, count, radius) => {
  const base = shape.translate(0, radius);
  const angle = 360 / count;

  const copies = [];
  for (let i = 0; i < count; i++) {
    copies.push(base.clone().rotate(i * angle));
  }
  return copies;
};

const fuseAll = (shapes) => {
  let result = shapes[0];
  shapes.slice(1).forEach((shape) => {
    result = result.fuse(shape);
  });
  return result;
};

function main() {
  return fuseAll(polarCopies(drawCircle(5), 5, 7));
}

replicad as a library
At its core, replicad is just a library. You can then create your own viewer, editor, configurator on top of it.

In order to show what can be done in the most simple way, you can find a sample app here: https://sample-app.replicad.xyz.

Display of the model
With replicad you can easily export an STL (or STEP) file to be opened in another application. Nevertheless displaying a model in your page tends to be nicer.

For this you will need to use a 3D library. For instance, replicad has helpers to integrate with threejs.

opencascade.js and webassembly
Most of the complexity in using replicad as a library is that it depends on a webassembly module, opencascadejs, and the tooling around WASM is not always easy to use.

Additionally, you should load the webassembly code from opencascadejs (or the replicad custom build) in a webworker. The model computation can take some time and the parallelism of a worker will allow you to offer a reactive interface during the computation.

Injecting opencascadejs
The important bit you need to do to have replicad work is that you need to inject an instance of opencascadejs at initialisation.

You can have a look at the initialisation in the sample app:

let loaded = false;
const init = async () => {
  if (loaded) return Promise.resolve(true);

  const OC = await opencascade({
    locateFile: () => opencascadeWasm,
  });

  loaded = true;
  setOC(OC);

  return true;
};
const started = init();

In addition to the opencascadejs boilerplate, we use the setOC function. This will inject the instance of the opencascade library into replicad.

Once this is done, replicad will work.



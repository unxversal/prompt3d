export const REPLICAD_DOCS = "Skip to main content\nReplicad Logo\nreplicad\nDocumentation\nAPI\nWorkbench\nGitHub\n\nIntroduction\nGetting Started\nThe workbench\nDrawing\nPlanes and Sketches\nAdding depth\nTransformations\nCombinations\nFinders\nModifications\nSharing models\nMaking a watering can\nRecipes\nExamples\nreplicad as a library\nOther ressources\nReplicad API\n\nGetting StartedThe workbench\nThe workbench\nSo let's use the workbench!\n\nA first example\nLet's draw using a basic replicad script. Do not worry about the details for now.\n\nOpen the workbench in a new tab and copy this:\n\nconst { drawEllipse } = replicad;\nconst main = () => {\n  return drawEllipse(20, 30).sketchOnPlane().extrude(50).fillet(2);\n};\n\n\nYou should see something like that:\n\nYour first 3D model\n\nCongratulations, you have built your first model with replicad!\n\ntip\nYou can click on the Open in workbench button in most code samples to see (and edit them) within the workbench.\n\nThe workbench button\nDirect links\nYou can even open a model directly in the workbench if you click on the Open in workbench button next to the copy button!\n\nWorking with local files\nIf you prefer to use your editor of choice it is also possible.\n\nCreate a file (model1.js for instance) somewhere on your disk, and then you can point the workbench to that file using the reload menu (left of the menu bar of the editor).\n\nUnfortunately, in order to have all the file reloading abilities you will need to use Chrome (or Edge). The load from disk button does not appear in Firefox and Safari.\n\nEdit this page\nPrevious\nIntroduction\nNext\nDrawing\nA first example\nDirect links\nWorking with local files\nDocs\nDocumentation\nAPI\nMore\nReplicadManual by raydeleu\nGitHub\nCopyright © 2025 QuaroTech.\n\nDrawing\ntip\nYou can click on the Open in workbench button in most code samples to see (and edit them) within the workbench.\n\nThe workbench button\nLet's start in two dimensions only, we will add the third one soon enough. replicad provides some classes and functions to draw in the plane.\n\nLet's start with the powerful draw API.\n\nThe draw function and the Drawing API\nWith the drawing API you can draw straight lines and several types of curves. It currently supports:\n\nstraight lines\narcs of circles\narcs of ellipses\nbezier curves\nAnd for each of these categories it provides a set of functions that should help you draw stuff quickly - or give you as much power as you need. Have a look at the detailed API documentation to see what it can do\n\nA simple drawing\nLet's draw something simple:\n\nconst { draw } = replicad;\nconst main = () => {\n  return draw().hLine(25).halfEllipse(0, 40, 5).hLine(-25).close();\n};\n\n\nA simple drawing\n\nWhat have we done?\n\nWe start drawing (at the origin, for instance draw([10, 10]) would start at another point.\nWe then draw an horizontal line of 25 millimeters of length.\nThen, we draw an half ellipse, from the last point of the line, moving, by 0 horizontally and by 40 vertically - but drawing an arc of an ellipse with an axis length of 5.\nWe then go back of 25 horizontally\nWe finally close the drawing, going from the current last point to the first point with a straight line.\nLet's play with the drawing\nTo understand what the different parameters do, let's play with them:\n\nclose with a mirror instead of a straight line with .closeWithMirror instead of close\nreplace the second horizontal line by a sagitta line (an arc or circle) .hSagittaArc(-25, 10)\nchange the origin to another point (with draw([10, 10]) for instance).\nDrawing functions\nIn addition to the draw API, replicad provides some drawing functions to draw common and useful shapes. You can for instance:\n\ndraw a rectangle drawRoundedRectangle\ndraw a polygon drawPolysides\ncircle drawCircle or ellipse drawEllipse\ndraw some text in a ttf font drawText\ndraw based on a parametric function drawParametricFunction, with an example here\nThey are documented in the API\n\nPracticing with the watering can tutorial\nYou can have a look at a practical example of using the drawing API with the watering can tutorial\n\nreplicad\nDrawing\nDrawingPen\ndrawRectangle\ndraw\ndrawCircle\ndrawEllipse\ndrawFaceOutline\ndrawParametricFunction\ndrawPointsInterpolation\ndrawPolysides\ndrawProjection\ndrawRoundedRectangle\ndrawSingleCircle\ndrawSingleEllipse\ndrawText\nImport\nimportSTEP\nimportSTL\nFinders\nEdgeFinder\nFaceFinder\ncombineFinderFilters\nSolids\nmakeBox\nmakeCylinder\nmakeEllipsoid\nmakeSolid\nmakeSphere\nMeasure\nmeasureArea\nmeasureDistanceBetween\nmeasureLength\nmeasureVolume\nOther\n_1DShape\n_3DShape\nAssemblyExporter\nBaseSketcher2d\nBlueprint\nBlueprints\nBoundingBox\nBoundingBox2d\nCompound\nCompoundBlueprint\nCompoundSketch\nCompSolid\nCornerFinder\nCurve\nCurve2D\nDistanceQuery\nDistanceTool\nDrawing\nEdge\nFace\nLinearPhysicalProperties\nPlane\nProjectionCamera\nShape\nShell\nSketches\nSolid\nSurface\nSurfacePhysicalProperties\nTransformation\nVector\nVertex\nVolumePhysicalProperties\nWire\nWrappingObj\nBSplineApproximationConfig\nCurveLike\nDrawingInterface\nExtrusionProfile\nFaceTriangulation\nGenericSweepConfig\nLoftConfig\nShapeMesh\nSketchInterface\nAnyShape\nChamferRadius\nCorner\nCubeFace\nCurveType\nFilletRadius\nFilterFcn\nPlaneName\nPoint\nPoint2D\nProjectionPlane\nRadiusConfig\nScaleMode\nShape2D\nShape3D\nSimplePoint\nSplineConfig\nSupportedUnit\nSurfaceType\nDEG2RAD\nHASH_CODE_MAX\nmakeCompound\nRAD2DEG\naddHolesInFace\nasDir\nasPnt\nassembleWire\naxis2d\nbasicFaceExtrusion\ncast\ncomplexExtrude\ncompoundShapes\ncreateAssembly\ncreateNamedPlane\ncut2D\ncutBlueprints\ndowncast\nexportSTEP\nfuse2D\nfuseBlueprints\nGCWithObject\nGCWithScope\ngenericSweep\ngetFont\ngetOC\nintersect2D\nintersectBlueprints\nisPoint\nisProjectionPlane\nisShape3D\nisWire\niterTopo\nloadFont\nlocalGC\nloft\nlookFromPlane\nmakeAx1\nmakeAx2\nmakeAx3\nmakeBaseBox\nmakeBezierCurve\nmakeBSplineApproximation\nmakeCircle\nmakeDirection\nmakeEllipse\nmakeEllipseArc\nmakeFace\nmakeHelix\nmakeLine\nmakeNewFaceWithinFace\nmakeNonPlanarFace\nmakeOffset\nmakePlane\nmakePlaneFromFace\nmakePolygon\nmakeProjectedEdges\nmakeTangentArc\nmakeThreePointArc\nmakeVertex\nmeasureShapeLinearProperties\nmeasureShapeSurfaceProperties\nmeasureShapeVolumeProperties\nmirror\norganiseBlueprints\npolysideInnerRadius\npolysidesBlueprint\nrevolution\nrotate\nroundedRectangleBlueprint\nscale\nsetOC\nshapeType\nsketchText\nsupportExtrude\ntextBlueprints\ntranslate\ntwistExtrude\nweldShellsAndFaces\nSketching\nBlueprintSketcher\nFaceSketcher\nSketch\nSketcher\nGenericSketcher\nsketchCircle\nsketchEllipse\nsketchFaceOffset\nsketchHelix\nsketchParametricFunction\nsketchPolysides\nsketchRectangle\nsketchRoundedRectangle\n\nPlanes and Sketches\nWe have so far drawn on the 2D plane. But we want to put these drawings in 3D space. For this we will need to define a plane and sketch the drawing into it.\n\nSketching\nIn order to show the planes we will need to sketch on them.\n\nconst { drawRoundedRectangle } = replicad;\n\nconst main = () => {\n  return drawRoundedRectangle(100, 50).sketchOnPlane();\n};\n\n\nBy default this sketches on the XY plane.\n\nPlanes\nNow that we know what sketching is, we can see the way to create planes.\n\nStandard planes\nThere are a bunch of standard planes defined as a string\n\nconst { drawRoundedRectangle, makePlane } = replicad;\n\nconst main = () => {\n  const rect = drawRoundedRectangle(100, 50);\n  return [\n    { shape: rect.sketchOnPlane(makePlane(\"XY\")), name: \"XY\", color: \"blue\" },\n    { shape: rect.sketchOnPlane(makePlane(\"XZ\")), name: \"XZ\", color: \"green\" },\n    { shape: rect.sketchOnPlane(makePlane(\"YZ\")), name: \"YZ\", color: \"red\" },\n  ];\n};\n\n\nThe standard planes\n\nPlanes parallel to the standard one\nThere are a bunch of standard planes defined as a string\n\nconst { drawRoundedRectangle, makePlane } = replicad;\n\nconst main = () => {\n  const rect = drawRoundedRectangle(100, 50);\n  return [\n    { shape: rect.sketchOnPlane(makePlane(\"XY\")), name: \"At 0\", color: \"blue\" },\n    {\n      shape: rect.sketchOnPlane(makePlane(\"XY\", 20)),\n      name: \"At 20\",\n      color: \"green\",\n    },\n    {\n      shape: rect.sketchOnPlane(makePlane(\"XY\", -20)),\n      name: \"At -20\",\n      color: \"red\",\n    },\n  ];\n};\n\n\nSketching shortcut\nAs these are common ways to sketch a drawing, we have implemented a shortcut within the sketchOnPlane method.\n\nconst { drawRoundedRectangle } = replicad;\n\nconst main = () => {\n  return drawRoundedRectangle(100, 50).sketchOnPlane(\"XZ\", 10);\n};\n\n\nOpposite standard planes\nIn addition to the standard planes there are their opposite (YX is the opposite of XY). These are the same planes, but with their axis inverted – which also means top and bottom are inverted.\n\nAn example will make it more concrete\n\nconst { drawRoundedRectangle, makePlane } = replicad;\n\nconst main = () => {\n  const rect = drawRoundedRectangle(100, 50);\n  return [\n    { shape: rect.sketchOnPlane(\"XY\", 20), name: \"XY at 20\", color: \"green\" },\n    { shape: rect.sketchOnPlane(\"YX\", 20), name: \"YX at 20\", color: \"red\" },\n  ];\n};\n\n\nOpposite planes\n\nWe can see that the rectangle has been rotated to match the axis, but also that the direction of the plane is reversed.\n\nTransforming planes\nWe might want to use planes more different than translations of the origin along the normal of a plane. Note that the order in which you apply these transformations might change the final result.\n\nTranslations\nWe might want to translate the origin of an arbitrary position. Note that the general direction of the plane is the same. Only the origin point has been changed.\n\nconst { drawRoundedRectangle, makePlane } = replicad;\n\nconst main = () => {\n  const plane = makePlane(\"XZ\").translate(-50, 50, 20);\n  return drawRoundedRectangle(100, 50).sketchOnPlane(plane);\n};\n\n\nPivot\nWe might want to give an angle to our plane. In order to do this, we can pivot the plane around its origin and an axis (which can be a standard direction X, Y, Z, or a generic direction ([1, 1, 0])\n\nconst { drawRoundedRectangle, makePlane } = replicad;\n\nconst main = () => {\n  const plane = makePlane(\"XY\").pivot(30, \"Y\");\n  return drawRoundedRectangle(100, 50).sketchOnPlane(plane);\n};\n\n\nAxes rotation\nThere is a last operation that can be done on a plane - it is the rotation of its axes around the origin.\n\nconst { drawRoundedRectangle, makePlane } = replicad;\n\nconst main = () => {\n  const plane = makePlane(\"XY\").rotate2DAxes(30, \"Y\");\n  return drawRoundedRectangle(100, 50).sketchOnPlane(plane);\n};\n\n\nSummary\nYou can look at the different operations with the same base plane and drawing.\n\nconst { drawRoundedRectangle, makePlane } = replicad;\n\nconst main = () => {\n  const rect = drawRoundedRectangle(100, 50);\n\n  const plane = makePlane(\"XY\", 10);\n  return [\n    { shape: rect.sketchOnPlane(plane), name: \"Base\", opacity: 0.5 },\n    {\n      shape: rect.sketchOnPlane(plane.translateY(-70)),\n      name: \"Translated\",\n      opacity: 0.5,\n      color: \"green\",\n    },\n    {\n      shape: rect.sketchOnPlane(plane.pivot(30)),\n      name: \"Pivoted\",\n      opacity: 0.5,\n      color: \"orange\",\n    },\n    {\n      shape: rect.sketchOnPlane(plane.rotate2DAxes(30)),\n      name: \"Rotated\",\n      opacity: 0.5,\n      color: \"purple\",\n    },\n  ];\n};\n\n\nPracticing with the watering can tutorial\nYou can have a look at a practical example of using the drawing API with the watering can tutorial\n\nAdding depth\nOnce you have a sketch, you want to add some depth to it. replicad offers all the standard methods to do this.\n\nYou can find the detailed API documentation here\n\nExtrusion\nThe sketch extruded\n\nThe simplest way to \"add depth\" is to take the face that we have and add thickness, to extrude it in other words.\n\nconst { draw } = replicad;\nconst main = () => {\n  return draw()\n    .hLine(25)\n    .halfEllipse(0, 40, 5)\n    .hLine(-25)\n    .close()\n    .sketchOnPlane(\"XZ\")\n    .extrude(10);\n};\n\n\nThis is exactly what we have done, but added a depth of 10mm.\n\nVariations on the extrusion\nWe can play a bit with the extrusion as well, in addition to the extrusion length we can change:\n\nthe direction of the extrusion (by default normal to the sketching plane), .extrude(10, { extrusionDirection: [0, 1, 0.5] })\nadd a twisting motion to the shape (angle in degrees) .extrude(10, { twistAngle: 10 })\nRevolution\nThe sketch revolved\n\nLet's make this shape rotate on an axis, which is, by default the Z axis\n\nconst { draw } = replicad;\nconst main = () => {\n  return draw()\n    .hLine(25)\n    .halfEllipse(0, 40, 5)\n    .hLine(-25)\n    .close()\n    .sketchOnPlane(\"XZ\")\n    .revolve();\n};\n\n\nLoft\nA loft between two sketches\n\nWith a loft we make a smooth transition between two sketches (simple ones, different from the one we had before).\n\nconst { drawRoundedRectangle, drawCircle } = replicad;\nconst main = () => {\n  const rect = drawRoundedRectangle(5, 10).sketchOnPlane();\n  const circle = drawCircle(3).sketchOnPlane(\"XY\", 10);\n  return rect.loftWith(circle);\n};\n\n\nVariations on the loft\nYou can also play a bit with the loft.\n\nBy adding a point at the end (or the start) of the loft:\nconst { drawRoundedRectangle, drawCircle } = replicad;\nconst main = () => {\n  const rect = drawRoundedRectangle(5, 10).sketchOnPlane();\n  const circle = drawCircle(3).sketchOnPlane(\"XY\", 10);\n\n  return rect.loftWith(circle, { endPoint: [2, 2, 15] });\n};\n\n\nBy having multiple lofted sketches\nconst { drawRoundedRectangle, drawCircle } = replicad;\nconst main = () => {\n  const rect = drawRoundedRectangle(5, 10).sketchOnPlane();\n  const circle = drawCircle(3).sketchOnPlane(\"XY\", 10);\n  const rect2 = drawRoundedRectangle(5, 10, 1).sketchOnPlane(\"XY\", 20);\n\n  return rect.loftWith([circle, rect2]);\n};\n\n\nPracticing with the watering can tutorial\nYou can have a look at a practical example of using the drawing API with the watering can tutorial\n\nTransformations\nNow that we have a 3D shape it is time to move it around. Note that usually you will transform a shape in order to align it with another shape, for instance, or to have different versions of a same basic shape.\n\nFor this part of the tutorial we will create a weird, non symmetrical shape:\n\nconst { draw } = replicad;\nconst main = () => {\n  const shape = draw()\n    .movePointerTo([50, 50])\n    .hLine(-120)\n    .vSagittaArc(-80, -20)\n    .sagittaArc(100, 20, 60)\n    .close()\n    .sketchOnPlane()\n    .extrude(100, { extrusionProfile: { profile: \"linear\", endFactor: 0.5 } });\n\n  return shape;\n};\n\n\nA weird shape to transform\n\nLet's move stuff around\nThis is fairly straightforward. We have a shape, we translate it on the axes (or on a vector)\n\nreturn shape.translateZ(20);\n\nYou can see the 2cm between the base of the shape and the grid\n\nLet's rotate this thing\nreturn shape.rotate(45, [0, 0, 0], [1, 0, 0]);\n\nThe shape is rotated 45 degrees around an axis going through the origin and in the X direction. Try to move these points around to see what is going on.\n\nFinally mirroring\nreturn shape.mirror(\"XZ\");\n\nThe mirror image of the shape!\n\nCombinations\nIt is now time to introduce a way to combine shapes together, the main operations of constructive geometry, also known as the boolean operations.\n\nWe will play with two shapes, a box and a cylinder.\n\nPasting shapes together\nThis is what we call the fuse operation:\n\nconst { drawRoundedRectangle, drawCircle } = replicad;\nconst main = () => {\n  const cylinder = drawCircle(20).sketchOnPlane().extrude(50);\n  const box = drawRoundedRectangle(60, 90).sketchOnPlane().extrude(25);\n\n  return box.fuse(cylinder);\n};\n\n\nthe box and cylinder fused\n\nCutting one shape with another\nThis is what we call the cut operation:\n\nconst { drawRoundedRectangle, drawCircle } = replicad;\nconst main = () => {\n  const cylinder = drawCircle(20).sketchOnPlane().extrude(50);\n  const box = drawRoundedRectangle(60, 90).sketchOnPlane().extrude(25);\n\n  return box.cut(cylinder);\n};\n\n\nthe cylinder cut into the box\n\nIntersecting two shapes\nFor the intersection we will intersect the cylinder with itself. This creates a fun shape:\n\nconst { drawRoundedRectangle, drawCircle } = replicad;\nconst main = () => {\n  const cylinder = drawCircle(20).sketchOnPlane().extrude(50);\n  const sideCylinder = cylinder.clone().rotate(90, [0, 0, 20], [1, 0, 0]);\n\n  return sideCylinder.intersect(cylinder);\n};\n\n\nthe cylinder intersecting itself\n\nFinders\nWhen using a visual interface to draw in 3D, selecting a face or an edge is trivial - the user just needs to click it.\n\nIn the case of code CAD, this is a more complicated operation - we need to find these as features. This is what finders are for.\n\nFor this tutorial we will use this relatively complex shape (a simple house):\n\nconst { draw, drawCircle, drawRoundedRectangle } = replicad;\nconst main = () => {\n  let house = draw()\n    .hLine(50)\n    .vLine(60)\n    .line(-50, 20)\n    .closeWithMirror()\n    .sketchOnPlane(\"XZ\")\n    .extrude(30);\n\n  const window = drawCircle(10)\n    .sketchOnPlane(\"XZ\")\n    .extrude(30)\n    .translate([10, 0, 50]);\n\n  const door = drawRoundedRectangle(20, 30)\n    .sketchOnPlane(\"XZ\")\n    .extrude(30)\n    .translate([-20, -5, 15]);\n\n  house = house.cut(window).fuse(door);\n  return house;\n};\n\n\nWe will use a feature of the viewer, where you can highlight programatically some faces (or edges).\n\nthe house\n\nBasic finders usage\nFinding faces\nIn order to find faces, we create a face finder object. Let's say we want to find the face of the door\n\nconst main = () => {\n  let house = draw();\n  //...\n\n  return {\n    shape: house,\n    highlightFace: (f) => f.inPlane(\"XZ\", 35),\n  };\n};\n\nThis was fairly easy, the door is the face parallel to the plane XZ, at the coordinate 35.\n\nThere are many different types of filters like inPlane that allow you to specify precisely which face you are interested in. For instance you can look for faces that:\n\nhave a certain type of surface f.ofSurfaceType(\"CYLINDRE\") will return the inside of the window.\ncontain a certain point f.containsPoint([0, -15, 80]) will return both sides of the roof\nand other methods you can find in the API documentation\n\nFinding edges\nTo find edges, it works in the same way, you just work with an EdgeFinder instead of a face finder and use the methods that are documented here.\n\nFor instance, to find the top of the roof\n\n  let house = draw()\n  //...\n\n  const findRooftop = new EdgeFinder()\n\n  return {\n    shape: house,\n    highlightEdge: e => e.containsPoint([0, -15, 80])\n  };\n};\n\nCombinating filters\nBy default you can chain different filter conditions. Only the shapes that follow all the conditions will be found. For instance, to find the window of the back of the house:\n\n  let house = draw()\n  //...\n\n  return {\n    shape: house,\n    highlightEdge: e => e.ofCurveType(\"CIRCLE\").inPlane(\"XZ\")\n  };\n};\n\nIf you only use one of the filters you will see more edges highlighted.\n\nCombinating with an either condition\nIn some cases you might want to combine elements with an OR condition, to find faces that fit either one condition or the other. For instance if we want to find both side faces:\n\n(f) => f.either([(f) => f.inPlane(\"YZ\", 50), (f) => f.inPlane(\"YZ\", -50)]);\n\nNegating a condition\nYou might also want to specify the inverse of a condition, that is what not is for. For instance, we can select the front window by just adding a not to the finder we created earlier\n\nconst frontWindow = (e) => e.ofCurveType(\"CIRCLE\").not((f) => f.inPlane(\"XZ\"));\n\nNote that it works because there are only two edges that are circles in the house.\n\nFinding faces and edges\nWe have created finders so far and used them to highlight faces and edges\n\nbut what are they really useful for.\nThis will be mostly clear in the next chapter with modifications that can make a lot of use of finders.\n\nYou can also find a specific face. For instance, we might want to have only the front face of the house. For this you will need to use the FaceFinder and EdgeFinder objects directly (instead of within a function that already declared it).\n\nconst { draw, drawCircle, drawRoundedRectangle, FaceFinder } = replicad;\nconst main = () => {\n  let house = draw()\n    .hLine(50)\n    .vLine(60)\n    .line(-50, 20)\n    .closeWithMirror()\n    .sketchOnPlane(\"XZ\")\n    .extrude(30);\n\n  const window = drawCircle(10)\n    .sketchOnPlane(\"XZ\")\n    .extrude(30)\n    .translate([10, 0, 50]);\n\n  const door = drawRoundedRectangle(20, 30)\n    .sketchOnPlane(\"XZ\")\n    .extrude(30)\n    .translate([-20, -5, 15]);\n\n  house = house.cut(window).fuse(door);\n\n  return new FaceFinder().inPlane(\"XZ\", 30).find(house);\n};\n\nModifications\nIn addition to the shape transformations and shape combinations, it is also possible to apply some advanced modifications to shapes. These modifications use finders to filter out which face or edges they need.\n\nFillet and chamfer\nAdding fillet (rounded edges) and chamfers (beveled edges) is a very common operation when modelling in 3D. These operations are mainly configured by their radius.\n\nconst { drawRoundedRectangle } = replicad;\nconst main = () => {\n  return drawRoundedRectangle(30, 50).sketchOnPlane().extrude(20).fillet(2);\n};\n\n\nWhen configuring a fillet with a number, all the edges of the shape will be filleted.\n\nIf you want to target specific edges you will need to configure a finder within a filter configuration. For instance to fillet only the top edges:\n\nconst { drawRoundedRectangle } = replicad;\nconst main = () => {\n  return drawRoundedRectangle(30, 50)\n    .sketchOnPlane()\n    .extrude(20)\n    .fillet(2, (e) => e.inPlane(\"XY\", 20));\n};\n\n\nMultiple radii\nWhat if you want to apply different radii for different edges? You can use a function that will combine filter configurations.\n\nIn this case we want to have a bigger fillet on the sides of the box and a small one at the top. You might have been able to do this with two different fillet operations, but in some cases the kernel has more difficulties finding a good solution with multiple operations.\n\nconst { drawRoundedRectangle, EdgeFinder, combineFinderFilters } = replicad;\nconst main = () => {\n  const [filters] = combineFinderFilters([\n    {\n      filter: new EdgeFinder().inPlane(\"XY\", 20),\n      radius: 2,\n    },\n    {\n      filter: new EdgeFinder().inDirection(\"Z\"),\n      radius: 9,\n    },\n  ]);\n\n  return drawRoundedRectangle(30, 50)\n    .sketchOnPlane()\n    .extrude(20)\n    .fillet(filters);\n};\n\n\nAsymmetric chamfer\nBy default chamfer operations will use a radius, the same distance on both sides of a edge. If you want to use a different distance on each side and create an asymmetric chamfer, you can use a custom radius:\n\nconst { makeBaseBox, EdgeFinder } = replicad;\n\nexport default function main() {\n  let base = makeBaseBox(30, 50, 10);\n  return base.chamfer(\n    {\n      distances: [5, 2],\n      selectedFace: (f) => f.inPlane(\"YZ\", 15),\n    },\n    (e) => e.inPlane(\"XY\", 10)\n  );\n}\n\n\nThe selected face corresponds to the face on which the first distance will be applied.\n\nFillet with radius evolution\nYou can also have a fillet vary along the edge. This is done by using an array of two numbers. The first number is the radius at the start of the edge, and the second number is the radius at the end of the edge.\n\nconst { makeBaseBox } = replicad;\n\nexport default function main() {\n  let base = makeBaseBox(30, 50, 10);\n  return base.fillet([4, 1], (e) => e.inPlane(\"YZ\", 15).inDirection(\"Y\"));\n}\n\n\nShell\nWith a shell you can hollow out a full shape (keeping a wall of a certain thickness). You need to specify a face that will be hollow, and you configure a finder for this.\n\nconst { drawRoundedRectangle } = replicad;\nconst main = () => {\n  return drawRoundedRectangle(30, 50)\n    .sketchOnPlane()\n    .extrude(20)\n    .shell(5, (f) => f.inPlane(\"XY\", 20));\n};\n\nIntroduction\nDo you like to follow steps to learn? This tutorial is for you - it allows you to build this plunge watering can by using the replicad APIs.\n\n\nNote that this model is inspired by Robert Bronwasser's watering can. The original implementation comes from our community.\n\nIf you want to follow along you can click on the workbench icon (next to copy!) in the code examples!\n\nDrawing the body profile\ntip\nYou can click on the Open in workbench button in most code samples to see (and edit them) within the workbench.\n\nThe workbench button\nSo let's start by the body of our can. We will take the general approach of drawing a profile that will then be revolved.\n\nLet's start with our basic shape:\n\nconst { draw } = replicad;\n\nconst main = () => {\n  return draw()\n    .hLine(20)\n    .line(10, 5)\n    .vLine(3)\n    .lineTo([8, 100])\n    .hLine(-8)\n    .close();\n};\n\n\nWe drew a simple shape following the profile using only straight lines. We generally went for relative positioning. For instance with hLine(20) which draws an horizontal line of 20mm of length). An line(10, 5) which draws a line by going 10 horizontally and 5 vertically. But we also used lineTo([8, 100]) which moves us to the point [8, 100] - this is using absolute coordinates.\n\nFilleting angles\nThe bottom of the can is rounded. We could use different methods for that. First, we will use round the corners of the previous shape (using filleting)\n\nconst { draw } = replicad;\n\nconst main = () => {\n  return draw()\n    .hLine(20)\n    .customCorner(2)\n    .line(10, 5)\n    .customCorner(3)\n    .vLine(3)\n    .customCorner(3)\n    .lineTo([8, 100])\n    .hLine(-8)\n    .close();\n};\n\n\nArcs of circles\nWe can also draw arcs of a circle directly.\n\nconst { draw } = replicad;\n\nconst main = () => {\n  return draw().hLine(20).tangentArc(10, 10).lineTo([8, 100]).hLine(-8).close();\n};\n\n\nThis is not the best use of these here, but I wanted to show you for the example.\n\nBézier curves\nBetter would be to use Bézier curves with the smoothSpline method.\n\nconst { draw } = replicad;\n\nconst main = () => {\n  return draw([0, 100])\n    .hLine(8)\n    .lineTo([30, 8])\n    .smoothSpline(-10, -8, { endTangent: [-1, 0], startFactor: 2 })\n    .lineTo([0, 0])\n    .close();\n};\n\n\nWe reoriented the drawing to start from the top (and to not have to compute the direction of the end tangent ourselves). By varying the startFactor we can reach a shape that we like.\n\nComparing the different cases\nHere a just a comparison of the different profiles we achieved.\n\nconst { draw } = replicad;\n\nconst main = () => {\n  // just lines\n  const s1 = draw()\n    .hLine(20)\n    .line(10, 5)\n    .vLine(3)\n    .lineTo([8, 100])\n    .hLine(-8)\n    .close();\n\n  // Using bezier curves\n  const s2 = draw([0, 100])\n    .hLine(8)\n    .lineTo([30, 8])\n    .smoothSpline(-10, -8, { endTangent: [-1, 0], startFactor: 2 })\n    .lineTo([0, 0])\n    .close();\n\n  // Straight lines and fillets\n  const s3 = draw()\n    .hLine(20)\n    .customCorner(10)\n    .line(10, 5)\n    .customCorner(3)\n    .vLine(3)\n    .customCorner(3)\n    .lineTo([8, 100])\n    .hLine(-8)\n    .close();\n\n  // Arcs\n  const s4 = draw()\n    .hLine(20)\n    .tangentArc(10, 10)\n    .lineTo([8, 100])\n    .hLine(-8)\n    .close();\n\n  return [\n    { shape: s1, color: \"blue\", name: \"Straight lines\" },\n    { shape: s4, color: \"orange\", name: \"Arcs\" },\n    { shape: s2, color: \"green\", name: \"Bézier\" },\n    { shape: s3, color: \"red\", name: \"Rounded corners\" },\n  ];\n};\n\n\nUsing planes for the filler\ntip\nYou can click on the Open in workbench button in most code samples to see (and edit them) within the workbench.\n\nThe workbench button\nIn order to build the filler we will need to place three circles (that will be lofted later on).\n\nWe will approach this by drawing on three different planes. The first one is simple, it corresponds to the plane parallel to the XY plane, but at a certain distance from the origin.\n\nconst { drawCircle, makePlane } = replicad;\nconst main = () => {\n  const middlePlane = makePlane(\"XY\", 100);\n  return drawCircle(8).sketchOnPlane(middlePlane);\n};\n\n\nNote that sketching on a plane parallel to a standard one (XY, XZ or YZ is a common operation and you can use the shortcut\n\nconst { drawCircle } = replicad;\nconst main = () => {\n  return drawCircle(8).sketchOnPlane(\"XY\", 100);\n};\n\n\nPlane translations\nWhat we have done here could also be done with a plane translation.\n\nconst { drawCircle, makePlane } = replicad;\nconst main = () => {\n  const middlePlane = makePlane(\"XY\").translateZ(100);\n  return drawCircle(8).sketchOnPlane(middlePlane);\n};\n\n\nA translation changes the origin point of a plane (not its orientation).\n\nPlane pivots\nWhat if you want a plane that is not parallel to one of the standard ones? You can pivot it on it's origin following a direction.\n\nconst { drawCircle, makePlane } = replicad;\nconst main = () => {\n  const topPlane = makePlane().pivot(-20, \"Y\");\n  return drawCircle(12).sketchOnPlane(topPlane);\n};\n\n\nThe circle is drawn with an angle of 20 degrees along the Y axis.\n\nPutting it all together to build the filler\nWith the filler we want 3 circles, some of them pivoted. We put it all together like this:\n\nconst { drawCircle, makePlane } = replicad;\n\nconst main = () => {\n  const topPlane = makePlane().pivot(-20, \"Y\").translate([-35, 0, 135]);\n  const topCircle = drawCircle(12).sketchOnPlane(topPlane);\n\n  const middleCircle = drawCircle(8).sketchOnPlane(\"XY\", 100);\n\n  const bottomPlane = makePlane().pivot(20, \"Y\").translateZ(80);\n  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);\n\n  return [\n    { shape: topCircle, name: \"Top Circle\" },\n    { shape: middleCircle, name: \"Middle Circle\" },\n    { shape: bottomCircle, name: \"Bottom Circle\" },\n  ];\n};\n\n\nWe will want to use all these circles with a \"loft\" operation later on.\n\nEdit this page\n\n\nCreating the 3D shapes\ntip\nYou can click on the Open in workbench button in most code samples to see (and edit them) within the workbench.\n\nThe workbench button\nWe now have the basic drawing to create our 3D shapes:\n\nthe can body for which we have a profile drawing\nthe filler for which we have three well positioned circles\nthe spout which is a simple cylinder\nThe spout cylinder\nCreation of a cylinder\nWe have two different approaches we could take to create a cylinder:\n\ndraw a circle and extrude it\ncreating the cylinder with a direct function\nExtrusion\nTo create a cylinder we can draw a circle, sketch it in 3D space, and then a extrude it.\n\nconst { drawCircle } = replicad;\nconst main = () => {\n  return drawCircle(5).sketchOnPlane().extrude(70);\n};\n\n\nWe have seen the first step in the previous page. We draw a circle and sketch it in the 3D space on a plane (here the default XY plane).\n\nWe extrude it, making a copy of itself in a certain direction and filling the sides.\n\nusing a direct creation method\nconst { makeCylinder } = replicad;\nconst main = () => {\n  return makeCylinder(5, 70);\n};\n\n\nPositioning the shape\nIn the case of a circle that we extrude, we could place the plane to sketch on and then position it.\n\nWe have seen how to position a plane in 3D space, but we might want to position a 3D shape.\n\nThe operations are similar for a shape as for a plane. First, translations are identical.\n\nconst { makeCylinder } = replicad;\nconst main = () => {\n  return makeCylinder(5, 70).translateZ(100);\n};\n\n\nRotations are similar to pivots for planes - but as shapes do not have an origin point by default, we need to specify it.\n\nconst { makeCylinder } = replicad;\nconst main = () => {\n  return makeCylinder(5, 70).translateZ(100).rotate(45, [0, 0, 100], [0, 1, 0]);\n};\n\n\nIn order to make things more readable, we might want to rotate before we translate (with a different origin).\n\nThe can body\nTo create the can body we will use the profile we drew, sketch it on the XZ plane and rotate it around the Z axis:\n\nconst { draw } = replicad;\n\nconst main = () => {\n  const profile = draw()\n    .hLine(20)\n    .line(10, 5)\n    .vLine(3)\n    .lineTo([8, 100])\n    .hLine(-8)\n    .close();\n\n  return profile.sketchOnPlane(\"XZ\").revolve([0, 0, 1]);\n};\n\n\nThe filler\nAfter extrusion and revolution, the filler uses a third method of 3D shape creation: lofting. We can create shapes by defining sections through which an object will pass trough.\n\nWe have defined our three circles and now we create a shape that passes through them all.\n\nconst { makePlane, drawCircle } = replicad;\n\nconst main = () => {\n  const topPlane = makePlane().pivot(-20, \"Y\").translate([-35, 0, 135]);\n  const topCircle = drawCircle(12).sketchOnPlane(topPlane);\n\n  const middleCircle = drawCircle(8).sketchOnPlane(\"XY\", 100);\n\n  const bottomPlane = makePlane().pivot(20, \"Y\").translateZ(80);\n  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);\n\n  return topCircle.loftWith([middleCircle, bottomCircle], { ruled: false });\n};\n\n\nPutting it all together\nLet's show all the pieces we have built so far together\n\nconst { makePlane, makeCylinder, draw, drawCircle } = replicad;\n\nconst main = () => {\n  // Building the body\n  const profile = draw()\n    .hLine(20)\n    .line(10, 5)\n    .vLine(3)\n    .lineTo([8, 100])\n    .hLine(-8)\n    .close();\n\n  const body = profile.sketchOnPlane(\"XZ\").revolve([0, 0, 1]);\n\n  // Building the spout\n  const topPlane = makePlane().pivot(-20, \"Y\").translate([-35, 0, 135]);\n  const topCircle = drawCircle(12).sketchOnPlane(topPlane);\n\n  const middleCircle = drawCircle(8).sketchOnPlane(\"XY\", 100);\n\n  const bottomPlane = makePlane().pivot(20, \"Y\").translateZ(80);\n  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);\n\n  const filler = topCircle.loftWith([middleCircle, bottomCircle], {\n    ruled: false,\n  });\n\n  const spout = makeCylinder(5, 70)\n    .translateZ(100)\n    .rotate(45, [0, 0, 100], [0, 1, 0]);\n\n  return [\n    { shape: body, color: \"blue\", opacity: 0.5 },\n    { shape: filler, color: \"red\", opacity: 0.5 },\n    { shape: spout, color: \"green\" },\n  ];\n};\n\nCombining the shapes\ntip\nYou can click on the Open in workbench button in most code samples to see (and edit them) within the workbench.\n\nThe workbench button\nNow that we have our three bodies we want to put them together (and smooth the corners it creates).\n\nFusing shapes together is easy:\n\nconst { makePlane, makeCylinder, draw, drawCircle } = replicad;\n\nconst main = () => {\n  // Building the body\n  const profile = draw()\n    .hLine(20)\n    .line(10, 5)\n    .vLine(3)\n    .lineTo([8, 100])\n    .hLine(-8)\n    .close();\n\n  const body = profile.sketchOnPlane(\"XZ\").revolve([0, 0, 1]);\n\n  // Building the spout\n  const topPlane = makePlane().pivot(-20, \"Y\").translate([-35, 0, 135]);\n  const topCircle = drawCircle(12).sketchOnPlane(topPlane);\n\n  const middleCircle = drawCircle(8).sketchOnPlane(\"XY\", 100);\n\n  const bottomPlane = makePlane().pivot(20, \"Y\").translateZ(80);\n  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);\n\n  const filler = topCircle.loftWith([middleCircle, bottomCircle], {\n    ruled: false,\n  });\n\n  return body.fuse(filler);\n};\n\n\nThe relevant line is just body.fuse(filler).\n\nSelection and filleting\nWe want to smooth the transition between the two bodies we just merged, we will use a fillet. But for this we need to select the edges that will need to be smoothed.\n\nconst { makePlane, makeCylinder, draw, drawCircle } = replicad;\n\nconst main = () => {\n  // Building the body\n  const profile = draw()\n    .hLine(20)\n    .line(10, 5)\n    .vLine(3)\n    .lineTo([8, 100])\n    .hLine(-8)\n    .close();\n\n  const body = profile.sketchOnPlane(\"XZ\").revolve([0, 0, 1]);\n\n  // Building the spout\n  const topPlane = makePlane().pivot(-20, \"Y\").translate([-35, 0, 135]);\n  const topCircle = drawCircle(12).sketchOnPlane(topPlane);\n\n  const middleCircle = drawCircle(8).sketchOnPlane(\"XY\", 100);\n\n  const bottomPlane = makePlane().pivot(20, \"Y\").translateZ(80);\n  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);\n\n  const filler = topCircle.loftWith([middleCircle, bottomCircle], {\n    ruled: false,\n  });\n\n  const fused = body.fuse(filler);\n\n  return {\n    shape: fused,\n    highlightEdge: (e) => e.inPlane(\"XY\", 100),\n  };\n};\n\n\nOnce we have found the edges we are concerned about using the finder API, we can fillet them like this:\n\nconst { makePlane, makeCylinder, draw, drawCircle } = replicad;\n\nconst main = () => {\n  // Building the body\n  const profile = draw()\n    .hLine(20)\n    .line(10, 5)\n    .vLine(3)\n    .lineTo([8, 100])\n    .hLine(-8)\n    .close();\n\n  const body = profile.sketchOnPlane(\"XZ\").revolve([0, 0, 1]);\n\n  // Building the spout\n  const topPlane = makePlane().pivot(-20, \"Y\").translate([-35, 0, 135]);\n  const topCircle = drawCircle(12).sketchOnPlane(topPlane);\n\n  const middleCircle = drawCircle(8).sketchOnPlane(\"XY\", 100);\n\n  const bottomPlane = makePlane().pivot(20, \"Y\").translateZ(80);\n  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);\n\n  const filler = topCircle.loftWith([middleCircle, bottomCircle], {\n    ruled: false,\n  });\n\n  const fused = body.fuse(filler).fillet(30, (e) => e.inPlane(\"XY\", 100));\n\n  return {\n    shape: fused,\n  };\n};\n\n\nAnd then repeat the operation for the spout:\n\nconst { makePlane, makeCylinder, draw, drawCircle } = replicad;\n\nconst main = () => {\n  // Building the body\n  const profile = draw()\n    .hLine(20)\n    .line(10, 5)\n    .vLine(3)\n    .lineTo([8, 100])\n    .hLine(-8)\n    .close();\n\n  const body = profile.sketchOnPlane(\"XZ\").revolve([0, 0, 1]);\n\n  // Building the spout\n  const topPlane = makePlane().pivot(-20, \"Y\").translate([-35, 0, 135]);\n  const topCircle = drawCircle(12).sketchOnPlane(topPlane);\n\n  const middleCircle = drawCircle(8).sketchOnPlane(\"XY\", 100);\n\n  const bottomPlane = makePlane().pivot(20, \"Y\").translateZ(80);\n  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);\n\n  const filler = topCircle.loftWith([middleCircle, bottomCircle], {\n    ruled: false,\n  });\n\n  const spout = makeCylinder(5, 70)\n    .translateZ(100)\n    .rotate(45, [0, 0, 100], [0, 1, 0]);\n\n  return body\n    .fuse(filler)\n    .fillet(30, (e) => e.inPlane(\"XY\", 100))\n    .fuse(spout)\n    .fillet(10, (e) => e.inBox([20, 20, 100], [-20, -20, 120]));\n};\n\n\nCreating an hollow shape\nFor now, we still have a full shape. We need to make it hollow - to be able to put water in it. Remember we are building a watering can.\n\nThis is similar to how we fillet, but instead of selecting edges we select the faces that will be hollowed out, and give the thickness of the walls.\n\nWe need to do a little bit of maths to find the coordinates of the end of the spout.\n\nconst { makePlane, makeCylinder, draw, drawCircle } = replicad;\n\nconst main = () => {\n  // Building the body\n  const profile = draw()\n    .hLine(20)\n    .line(10, 5)\n    .vLine(3)\n    .lineTo([8, 100])\n    .hLine(-8)\n    .close();\n\n  const body = profile.sketchOnPlane(\"XZ\").revolve([0, 0, 1]);\n\n  // Building the filler\n  const topPlane = makePlane().pivot(-20, \"Y\").translate([-35, 0, 135]);\n  const topCircle = drawCircle(12).sketchOnPlane(topPlane);\n\n  const middleCircle = drawCircle(8).sketchOnPlane(\"XY\", 100);\n\n  const bottomPlane = makePlane().pivot(20, \"Y\").translateZ(80);\n  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);\n\n  const filler = topCircle.loftWith([middleCircle, bottomCircle], {\n    ruled: false,\n  });\n\n  // Building the spout\n  const spout = makeCylinder(5, 70)\n    .translateZ(100)\n    .rotate(45, [0, 0, 100], [0, 1, 0]);\n\n  let wateringCan = body\n    .fuse(filler)\n    .fillet(30, (e) => e.inPlane(\"XY\", 100))\n    .fuse(spout)\n    .fillet(10, (e) => e.inBox([20, 20, 100], [-20, -20, 120]));\n\n  const spoutOpening = [\n    Math.cos((45 * Math.PI) / 180) * 70,\n    0,\n    100 + Math.sin((45 * Math.PI) / 180) * 70,\n  ];\n\n  wateringCan = wateringCan.shell(-1, (face) =>\n    face.either([\n      (f) => f.containsPoint(spoutOpening),\n      (f) => f.inPlane(topPlane),\n    ])\n  );\n\n  return {\n    shape: wateringCan,\n    name: \"Watering Can\",\n  };\n};\n\n\nWe are done!\nThe previous shape was the final one we were looking for! You can play with it, change some parameters and so on to create your own version!\n\nWhy recipes?\nThere are some operations using replicad (or any CAD tool) that are at the same time very common - but have many different configurations and edge cases.\n\nIn tools with a UI, this translates to very complex configuration boxes with multiple options that do not work well together most of the time.\n\nIn a code CAD tool like replicad, this would translate to a function with a very complex signature.\n\nIn some cases - the basic logic behind this functionality is fairly simple – but the different tweaks possible add the complexity.\n\nInstead of offering these as a standard library with a complex interface, I propose a recipe book of code that can be easily copied and tweaked to your particular needs.\n\nPolar array\nSometimes you want to copy a shape with a circular pattern. This is fairly easy to do with a little bit of javascript.\n\nconst polarCopies = (shape, count, radius) => {\n  const base = shape.translate(0, radius);\n  const angle = 360 / count;\n\n  const copies = [];\n  for (let i = 0; i < count; i++) {\n    copies.push(base.clone().rotate(i * angle));\n  }\n  return copies;\n};\n\nFor the optimal use, take into account that we assume\n\nthat your original shape is centered at the origin\nthat you want to rotate around the origin\nthat you want to go all around the circle\nLet's show an example\n\nconst { drawCircle } = replicad;\n\nconst polarCopies = (shape, count, radius) => {\n  const base = shape.translate(0, radius);\n  const angle = 360 / count;\n\n  const copies = [];\n  for (let i = 0; i < count; i++) {\n    copies.push(base.clone().rotate(i * angle));\n  }\n  return copies;\n};\n\nfunction main() {\n  return polarCopies(drawCircle(5), 5, 12);\n}\n\n\nNote that this code works for both 2D and 3D cases. In the case of 3D, it will do the copies in the XY plane.\n\nconst { drawCircle } = replicad;\n\nconst polarCopies = (shape, count, radius) => {\n  const base = shape.translate(0, radius);\n  const angle = 360 / count;\n\n  const copies = [];\n  for (let i = 0; i < count; i++) {\n    copies.push(base.clone().rotate(i * angle));\n  }\n  return copies;\n};\n\nfunction main() {\n  return polarCopies(drawCircle(5).sketchOnPlane().extrude(2), 5, 12);\n}\n\nSwept profile box\nLet's say you want to start designing with a box. Simple extrusion is good if you do not have a complex profile. A way to work with a more complex shape is to draw the profile in 2D, and then sweep it along a base sketch.\n\nconst { makeSolid, makeFace, assembleWire, EdgeFinder, genericSweep, Plane } =\n  replicad;\n\nfunction profileBox(inputProfile, base) {\n  const start = inputProfile.blueprint.firstPoint;\n  const profile = inputProfile.translate(-start[0], -start[1]);\n\n  const end = profile.blueprint.lastPoint;\n\n  const baseSketch = base.sketchOnPlane();\n\n  // We create the side of the box\n  const side = baseSketch.clone().sweepSketch(\n    (plane) => {\n      return profile.sketchOnPlane(plane);\n    },\n    {\n      withContact: true,\n    }\n  );\n\n  // We put all the pieces together\n  return makeSolid([\n    side,\n    // The face generated by sweeping the end of the profile\n    makeFace(assembleWire(new EdgeFinder().inPlane(\"XY\", end[1]).find(side))),\n    // The face generated by the base\n    baseSketch.face(),\n  ]);\n}\n\nThis code assumes some things about its input:\n\nthe input profile is a single open line\nthe base is a single closed line\nthere is only one profile point at the coordinate of the end of the profile\nThe box will have its base in the XY plane.\n\nLet's build an example\n\nconst { makeSolid, makeFace, assembleWire, EdgeFinder, genericSweep, Plane } =\n  replicad;\n\nfunction profileBox(inputProfile, base) {\n  const start = inputProfile.blueprint.firstPoint;\n  const profile = inputProfile.translate(-start[0], -start[1]);\n\n  const end = profile.blueprint.lastPoint;\n\n  const baseSketch = base.sketchOnPlane();\n\n  // We create the side of the box\n  const side = baseSketch.clone().sweepSketch(\n    (plane) => {\n      return profile.sketchOnPlane(plane);\n    },\n    {\n      withContact: true,\n    }\n  );\n\n  // We put all the pieces together\n  return makeSolid([\n    side,\n    // The face generated by sweeping the end of the profile\n    makeFace(assembleWire(new EdgeFinder().inPlane(\"XY\", end[1]).find(side))),\n    // The face generated by the base\n    baseSketch.face(),\n  ]);\n}\n\nconst { draw, drawRoundedRectangle } = replicad;\n\nfunction main() {\n  const base = drawRoundedRectangle(30, 20, 5);\n\n  const profile = draw()\n    .line(5, 5)\n    .line(2, 3)\n    .hLine(-2)\n    .vLine(-1)\n    .bulgeArcTo([0, 1], 0.2)\n    .done();\n\n  return profileBox(profile, base);\n}\n\nFuse All\nYou might find yourself in a situation where you have an array of shapes (2D or 3D) and you just want to fuse (or intersect) them all together. The following snippet just does this\n\nconst fuseAll = (shapes) => {\n  let result = shapes[0];\n  shapes.slice(1).forEach((shape) => {\n    result = result.fuse(shape);\n  });\n  return result;\n};\n\nLet's show an example (also using polar copies).\n\nconst { drawCircle } = replicad;\n\nconst polarCopies = (shape, count, radius) => {\n  const base = shape.translate(0, radius);\n  const angle = 360 / count;\n\n  const copies = [];\n  for (let i = 0; i < count; i++) {\n    copies.push(base.clone().rotate(i * angle));\n  }\n  return copies;\n};\n\nconst fuseAll = (shapes) => {\n  let result = shapes[0];\n  shapes.slice(1).forEach((shape) => {\n    result = result.fuse(shape);\n  });\n  return result;\n};\n\nfunction main() {\n  return fuseAll(polarCopies(drawCircle(5), 5, 7));\n}\n\nreplicad as a library\nAt its core, replicad is just a library. You can then create your own viewer, editor, configurator on top of it.\n\nIn order to show what can be done in the most simple way, you can find a sample app here: https://sample-app.replicad.xyz.\n\nDisplay of the model\nWith replicad you can easily export an STL (or STEP) file to be opened in another application. Nevertheless displaying a model in your page tends to be nicer.\n\nFor this you will need to use a 3D library. For instance, replicad has helpers to integrate with threejs.\n\nopencascade.js and webassembly\nMost of the complexity in using replicad as a library is that it depends on a webassembly module, opencascadejs, and the tooling around WASM is not always easy to use.\n\nAdditionally, you should load the webassembly code from opencascadejs (or the replicad custom build) in a webworker. The model computation can take some time and the parallelism of a worker will allow you to offer a reactive interface during the computation.\n\nInjecting opencascadejs\nThe important bit you need to do to have replicad work is that you need to inject an instance of opencascadejs at initialisation.\n\nYou can have a look at the initialisation in the sample app:\n\nlet loaded = false;\nconst init = async () => {\n  if (loaded) return Promise.resolve(true);\n\n  const OC = await opencascade({\n    locateFile: () => opencascadeWasm,\n  });\n\n  loaded = true;\n  setOC(OC);\n\n  return true;\n};\nconst started = init();\n\nIn addition to the opencascadejs boilerplate, we use the setOC function. This will inject the instance of the opencascade library into replicad.\n\nOnce this is done, replicad will work.\n\n## 1.1 Purpose\n\nThis document contains a beginner's guide for users of the Replicad (https://replicad.xyz/) libary and tools. Its purpose is mainly to demonstrate how models can be build using the tools, the so-called \"studio\", that are offered alongside the library. If you want to use this document to generate a separate manual, use one of the tools available to generate a simple document out of a github wiki repository. \n\nAt the Replicad website some documentation is offered as well as links to the detailed documentation of the API (Application Progamming Interface) of the library (see https://replicad.xyz/docs/api/). Nevertheless it can be quite daunting to collect all information for people that are just interested in modelling and are less experienced in reading computer code or building applications. \n\nUsing the Replicad tools it is possible to build complicated mechanical parts and even free form geometry. Two examples are shown below. Throughout the guide some examples will be given how the commands discussed in each chapter can be applied to real modelling examples. The folder \n[models](https://github.com/raydeleu/ReplicadManual/tree/main/models) on the website https://github.com/raydeleu/ReplicadManual/ contains some examples on how the functions of Replicad can be applied to create models. \n\n![Shapes created with Replicad, both technical and freeform is possible](https://github.com/raydeleu/ReplicadManual/blob/main/images/fork-plunge.png)\n\nFor additional help you can visit https://github.com/sgenoud/replicad and in particular the discussions area. There are sections labelled \"Q&A\" and \"modelling help\" where you can post your question. The programmer of Replicad is active in responding questions from users and you can also expect some help from fellow users. \n\nTo understand how the library can be included in new applications please consult the replicad website at https://replicad.xyz/. A very nice example how the library can be used can be visited at https://blingmything.sgenoud.com/. The code to this application is also available on github at https://github.com/sgenoud/blingmything. \n\n## 1.2 What is Replicad? \n\nReplicad is a software library that allows the user to enter a kind of script to create a 3D model. This model can then be exported in several formats,  allowing the user to create nice images (renders) or to send the shape to a 3D printer.\n\nThe approach to model a 3D shape with code (or script) has become popular through the availability of a software package called OpenSCAD (Open Scripted-Computer-Aided-Design). OpenSCAD has been used initially to model simple shapes for 3D modelling. It uses a technique called Constructive Solid Geometry (CSG), which indicates that 3D shapes are created by combining simple geometric shapes such as boxes, spheres, cylinders into more complex shapes. The operations used to combine these shapes are called boolean operations.\n\n\n![Simple car model created in OpenSCAD](https://github.com/raydeleu/ReplicadManual/blob/main/images/openscad-car.jpg)\n\nThis shape is created by entering the following script:\n\n.Code to create a car in OpenSCAD, using two boxes and 6 cylinders (4 wheels and two axles)\n\n``` javascript\ncube([60,20,10],center=true);\ntranslate([5,0,10 - 0.001])\n    cube([30,20,10],center=true);\ntranslate([-20,-15,0])\n    rotate([90,0,0])\n    cylinder(h=3,r=8,center=true);\ntranslate([-20,15,0])\n    rotate([90,0,0])\n    cylinder(h=3,r=8,center=true);\ntranslate([20,-15,0])\n    rotate([90,0,0])\n    cylinder(h=3,r=8,center=true);\ntranslate([20,15,0])\n    rotate([90,0,0])\n    cylinder(h=3,r=8,center=true);\ntranslate([-20,0,0])\n    rotate([90,0,0])\n    cylinder(h=30,r=2,center=true);\ntranslate([20,0,0])\n    rotate([90,0,0])\n    cylinder(h=30,r=2,center=true);\n```\n\nReplicad takes this approach a step further. It still retains the approach that shapes are created with a simple script, but it uses a more advanced 3D kernel that allows BRep (Boundary Representation) modelling. In this type of 3D kernel a solid is represented as a collection of surface elements - described using a mathematical equation - that define the boundary between interior and exterior points.\n\nThe advantage of a BRep kernel is that in addition to the simple boolean operations it is possible to define how the surfaces are linked to each other. This allows a more easy creation of angled edges (chamfers) or rounded edges (fillets). \n\n![Example of Replicad shape with fillets](https://github.com/raydeleu/ReplicadManual/blob/main/images/replicad_fillets.png)\n\n## 1.3 Tools to work with Replicad\n\nA model in Replicad is built using a javascript input file (see section 1.4 File Template). The best way for a beginner is to use the studio tools which come in two flavours namely the workbench and a visualizer. \n\n### 1.3.1 Workbench\nThe workbench, available at https://studio.replicad.xyz/workbench , is a complete design environment that includes a code editor with a pane to visualize the result of the input file. The result can be exported to STL and STEP formats to allow further processing, for example 3D printing. The code in the editor can be downloaded as a javascript file. Use the icon with a circle and arrow going down that can be found directly on top of the editor window. Of course you can also select the code in the editor and paste it into any other editor. \n\n![User interface of the Replicad workbench](https://github.com/raydeleu/ReplicadManual/blob/main/images/workbench.png)\n\nNote that the Workbench starts to interpret the code as soon as you type it in the editor window. In most cases this will result in an error message and the 3D window will show an animated cloud or \"amoebe\". The error found by Replicad is shown in a pane that appears directly below the editor. In some cases this is a straightforward error, for example if a function was mistyped or you forgot a closing bracket. In other cases the pane reports a \"Kernel Error\" followed by a number. Just continue completing the code until you see the progress indicator turning again. If the \"Kernel Error\" persists, try to remove instructions, for example by adding `//` at the beginning of this line to indicate that this is only a comment, until you get either an understandable error message or a shape again.   \n\nAn interesting feature of the workbench that is offered at the link shown above is that you can create a link to your model that includes the code. In that way you can share your model through an internet link that opens the workbench with your code in it. Others can then take your code and make modifications for their own purpose. Use the icon above the editor window that resembles a rectangle with an arrow going up. \n\n### 1.3.2 Visualizer\nFor people that prefer to edit the input files on their own computer using their preferred code editor, a visualizer is offered at https://studio.replicad.xyz/visualiser that can be used to show the results of processing an input file. Just like the workbench the visualizer supports the export of the shapes. \n\n![User interface of the Visualizer](https://github.com/raydeleu/ReplicadManual/blob/main/images/interface_black.png)\n\nIf the input file contains an error, the error message is shown in a pop-up window in the 3D view. \n\n<p align=center>\n<img src= \"https://github.com/raydeleu/ReplicadManual/blob/main/images/visualizer-error.png\" alt=\"Display of an error in the visualizer\" width = \"500\">\n</p>\n\n## 1.4 File template\n\nThe template to create and display a 3D part in Replicad looks like this.  \n\n``` javascript\nconst r = replicad\n\nconst defaultParams = {                // setting the value of the parameters\n  height:       100,\n  baseWidth:     20,\n  ...}\n\n// next lines allow intellisense help in VS Code \n/** @typedef { typeof import(\"replicad\") } replicadLib */\n/** @type {function(replicadLib, typeof defaultParams): any} */\n\nfunction main( \n { Sketcher, sketchRectangle, ... },   // functions used within the main program\n { height, basewidth, ....        } )  // parameters to adjust the model\n{\n    // add code to describe the shape\nreturn  shape   |  \nreturn  {shape: [shape], highlight: [foundFeature]}\n}\n```\n\nNote that the line \n\n``` javascript\nconst r = replicad\n```\ncan be used to circumvent the need to list all functions that are used in the code. Prepending each function with `r.` directly points the compiler to the complete Replicad source code. So for example, instead of listing the function `sketchRectangle` at the beginning of the declaration of `main` you can use `r.sketchRectangle`. Yet another approach is to list all the functions but add this add the beginning of your code using the notation: \n\n``` javascript\nconst { draw, ... other functions ... } = replicad;\n\nfunction main() \n{\n    // code to describe the shape\nreturn shape \n} \n``` \n\nUsing this notation there is no need to remember which of the arguments in the brackets of `function main({functions},{designparams})` contains what. You can simply use `main()`. \n\nAlternatively to the file listing shown above, you can use the arrow notation for the javascript function. This notation can be combined with the notations shown above to shortcut the definition of functions from the Replicad library. \n\n``` javascript\nconst defaultParams = {                // setting the value of the parameters\n  height:       100,\n  baseWidth:     20,\n  ...}\n\nconst main = (\n  { Sketcher, sketchRectangle, ... },   // functions used within the main program\n  { height, basewidth, ....        }    // parameters to adjust the model\n) => {\n    // add code to describe the shape\nreturn  shape   |  \nreturn  {shape: [shape], highlight: [foundFeature]}\n}\n```\n\nIf you want to display multiple shapes, the returned variable should be an array of all shapes. In this array it is possible to define \n\n* the variable name of the shape, \n* the name of the shape as a \"string\", \n* the color of the shape in the Visualiser, using the X11 \"color name\", see https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart\n\n\nExample colors are black, \ngrey,\ndimgrey,\nslategrey,\nlightslategrey,\nsteelblue,\nlightsteelblue,\nred,\ngreen,\nblue,\nviolet,\nsilver, \nskyblue,\nmagenta,\nmediumpurple. \n\n* the opacity, where opacity 1 is the default (visible) and 0 is fully transparant. \n\nAn example of an array is: \n\n``` javascript\nlet shapeArray = [\n{shape: plunge, name: \"plunge\", color:\"steelblue\", opacity: 0.5}, \n{shape: body, color: \"orange\",opacity:0.5},\n{shape: filler, color: \"red\"}]\n```\n\n## 2.1 How to create 3D parts? \n\nThe purpose of using Replicad is creating a 3D representation of a solid part for visualisation or 3D printing. \nThe process to create a 3D solid part in Replicad looks like this: \n\n![image](https://github.com/raydeleu/ReplicadManual/assets/38007983/38e3b5af-3c1f-4768-8627-afa2bbaf7084)\n\nTo understand this process, it might help to explain some terminology first. The following image shows some basic concepts that apply to almost all 3D modelling programs: \n\n![image](https://github.com/raydeleu/ReplicadManual/assets/38007983/6fe1449d-3261-4e0e-b1a2-e32ffdff474b)\n\nThe 3D space is defined by so-called coordinates. The coordinates are measured along three cartesian axes (see [Wikipedia Cartesian Axes](https://en.wikipedia.org/wiki/Cartesian_coordinate_system). You might think of them als length, width and height, but in 3D programs they are mostly called the X,Y and Z-axis where the Z-axis is pointing up. Using the coordinates you can define \"points\" in space. When these spaces are connected by a line, these lines are called \"edges\". When the edges completely enclose a flat area, this can be defined as a \"face\". In some programs such a face is referred to as a \"polygon\". Extruding an open edge is performed by shifting a copy of the edges. A real life comparison is creating a soap film when lifting the edges from a soap bath. The resulting 3D shape is a \"shell\", as it only contains walls that are infinitesimally  thin. When the edge is closed, you can consider the shape as a volume that is completely enclosed in faces. When you assume that the enclosed volume is completely filled with material, you have a \"solid\". \n\nWhen you now use this terminology of \"points\", \"edges\", \"faces\", \"shells\" and \"solids\" the process of creating 3D shapes can be explained using the following steps. Each of these steps will be explained in more detail in the next chapters of this manual. Note that as a beginner you might start at Step 3 to have quick results, although all chapters are filled with examples to get you going quickly. \n\n**Step 1: Create a 2 dimensional sketch** \n\nThe normal flow to define a solid part is to start with a 2-dimensional sketch of the part. You often start with a sketch that contains most information of the 3D shape. So in case of a car, you would probably start with the side view as this tells you more about the shape than the front view. How to create a sketch in Replicad will be explained in [Chapter 3](3.-Sketch.md). [Chapter 4](4.-Create-3D-wires-and-faces.md) discusses a special type of edge, namely a socalled \"wire\" that can be thought of as an edge that is not necessarily in a flat plane. An example is a helix, a wire in the shape of a rotating staircase or screw. \"Wires\" can be used as a guide rails to sweep a face to create special 3D shapes. \n\n**Step 2: Create a solid shape**\n\nBy using a method like extruding, lofting, revolving or sweeping, the 2D sketch is translated into a 3-dimensional solid. The methods to add thickness to the 2D sketch are explained in [Chapter 5](5.-Create-solid-shapes.md). \n\n**Step 3: Use simple predefined drawings or solids**\n\nA beginner can start with pre-baked shapes, i.e. standard shapes, to shorten the path to determine a shape. There are 2 dimensional pre-baked shapes like rectangles, rounded rectangles, circles, ellipes, and 3 dimensional shapes like boxes, spheres or cylinders. The functions to create standard 2D and 3D shapes are detailed in  respectively [Chapter 3](3.-Sketch.md) and [Chapter 5](5.-Create-solid-shapes.md). \n\n**Step 4: Modify the solid shape**\n\nThe 3 dimensional shape can then be modified, for example by rounding or chamfering the sharp edges. In its simplest form this modification is applied to all edges at once. A more advanced approach is to select individual edges or faces to apply the modification. The modification-methods and functions to select edges are discussed in [Chapter 6](6.-Modify-solids.md). \n\n**Step 5: Move or transform the solid shapes**\n\nAfter their creation, solid shapes can be moved and rotated. Other transformations are scaling the part or creating a mirrored version. The transformation methods are described in [Chapter 7](7.-Transform-shapes.md). \n\n**Step 6: Combine parts**\n\nDifferent parts can be combined to create new shapes. Combining parts can mean fusing parts together, subtracting the volume of one part from the other part, intersect parts or combine parts in a group or compound. It is like building a larger part from a set of building blocks. The methods to combine the building blocks are explained in [Chapter 8](8.-Combine-solids-to-parts.md). \n\nBuilding a complex part can also mean that the result of a particular step is fed into another step. For example, once you have combined some building blocks into a larger shape, you can go back and modify this new shape by applying fillet or chamfers. It is even possible to extract a face from the complex object and use this again as a starting point to build a new component. Therefore the process should be regarded more as a process to learn 3D modelling. Once you are comfortable with the available methods and functions, you will follow the process more or less automatically and also understand that sometimes a different order of steps is more practical.\n\n## 2.2 Comparing the Replicad approach with other tools \n\n### 2.2.1 Comparing Replicad to CAD tools\n\nFor users that have used a CAD (computer aided design) program earlier, the terminology will sound very familiar. Tools like \n\n* Siemens SolidEdge (https://solidedge.siemens.com/en/solutions/users/hobbyists-and-makers/), \n* Dassault Solidworks (https://www.solidworks.com/), \n* OnShape (https://onshape.com)\n* Autodesk Fusion 360 (https://www.autodesk.com/products/fusion-360/personal)\n* FreeCad (https://www.freecad.org/) \n\nuse a very similar approach, although they do not use code to determine the shape but visual interaction. The illustration below shows the interface of OnShape. At the left of this interface there is a list of parameters and so-called features. In fact this contains the same information as is represented in the code of Replicad. Starting from the top there are parameters that determine the dimensions of the shape, then a sketch of the sideview, an extrusion, adding fillets (rounding of edges) and then some actions to combine shapes.  \n\n![User interface of OnShape with a sketch highlighted in the modelling history](https://github.com/raydeleu/ReplicadManual/blob/main/images/onshape_sketch.png)\n\n### 2.2.2 Other code based tools\nUsers coming from OpenSCAD (https://www.openscad.org) will immediately recognize the coding approach but might be tempted to start with the prebaked 3D shapes first, as this makes modelling in OpenSCAD so fast. Go to [5.3 Pre-baked shapes](5.-Create-solid-shapes#53-pre-baked-shapes.md) to see examples how these can be used to quickly model a part by transforming (see [Chapter 7](7.-Transform-shapes.md) and combining the parts (see [Chapter 8](8.-Combine-solids-to-parts.md)). \n\nThere is no right or wrong way to go about creating the 3 dimensional shape. Compare it to creating a 3 dimensional structure by adding material like a brick layer or painter versus removing material like a sculptor. Use the chapters to quickly find your way through the documentation to suit the approach that you prefer.\n\n> **WARNING**\n> The user should be aware that Replicad is built upon the OpenCascade 3D modelling kernel which is available as open source and may be used without paying any license fee. However, this kernel has quite some limitations compared to kernels that are developed by large companies. \n\n> **Topological naming problem**\n> One of the most referenced shortcomings of OpenCascade is referred to as the \"Topological Naming Problem\" (or TNP). Whenever a model is modified so that the number of faces or edges change, the internal names of faces and edges are changed by the kernel. If your model relies on referencing the edges or faces by their old name, rebuilding the model will fail. Currently the developers of OpenCascade try to correct this issue by using a more complex identification method for faces and edges, but as this affects the complete kernel this change may take a long time. \n\n> **Rounding/fillets**\n> Another shortcoming is related to filleting. This will be discussed in [Chapter 6](6.-Modify-solids.md). \n\n## 3.1 Create a new sketch or drawing \n\nTo start a sketch, use the `new Sketcher` command. Note the keyword `new` that is required to create a new object of the type `Sketcher`.  \n\n``` javascript\nlet sketch = new Sketcher(\"XZ\",-5)\n\".sketchCommands\"        (see below)\n.close()                    // ends the sketch with line to starting point\n.done()                     // ends the sketch without closing\n.closeWithMirror()          // closes the sketch with mirror on axis from start to end\n```\n\nThe definition of a sketch refers to a plane in 3D space where the sketch is drawn. Most often this will be either the \"XY\" plane (top view), the \"XZ\" plane (front view) or the \"XY\" plane (side view). It is also possible to define an offset to these planes, as was done in the code sample above.  \n\nAn alternative and often preferred method to create a sketch is to use the function `draw()` to create a drawing. \nA drawing can be understood as an adapted version of a sketch. A sketch starts with identifying the sketching plane first and then defining a wire. As the plane is defined up front, the sketch is in fact a 3D shape from its origin. In contrast a drawing is considered a pure 2D shape that can be placed on a plane after its creation. Compared to a sketch a drawing has the following advantages: \n\n* drawings can be translated, rotated (in 2D space) and scaled;\n* drawings can be used in 2D boolean operations;\n* drawings can be exported directly in 2D formats;\n* drawings can be placed on other shapes, not only planes\n\nThe drawing can be defined with the `draw()` function. As this function already includes the creation of a new object the `new` keyword is not needed. The starting point of the drawing can be defined by adding a 2D point as a parameter to the `draw()`, for example `draw([5,5])`.   \n\n``` javascript\nconst shape1 = draw()\n    .lineTo([20,0])\n    .line(0,5)\n    .hLine(10)\n    .vLine(5)\n    .polarLineTo([22,45])\n    .polarLine(10,150)\n    .halfEllipse(-10, -15, 5)\n    .smoothSpline(2, -5)\n    .close() \n```    \n\nAfter its creating, a drawing has to be placed on a plane, using the method `.sketchOnPlane`. Through this method, a drawing can also be translated and rotated in 3D space. You can achieve this by translating and pivoting the plane on which the drawing is placed. For example, using the following code: \n\n``` javascript\n  const bottomPlane = makePlane().pivot(20, \"Y\").translateZ(80);\n  const bottomCircle = drawCircle(9).sketchOnPlane(bottomPlane);\n```\n\nfirst a Plane is defined, which is first pivoted by 20 degrees along the Y-axis and then translated up 80 mm on the Z-axis. Note that you can not translate or rotate the sketch after it is placed on a plane. The full set of commands to create and position planes is : \n\n| method                           | description                                        |\n| ---------------------------------|----------------------------------------------------|\n| `.sketchOnPlane(plane,offset)`   | place the drawing on a given plane                 | \n| `makePlane()           `         | create a basic plane, default is on the XY plane   |\n| `.pivot(degrees, axis) `         | rotate the plane x degrees around the given axis   |\n| `.translate   `                  | translate the plane                                 |\n| `.translateZ  `                  | translate the plane along the Z-axis                |\n| `.translateY  `                  | translate the plane along the Y-axis                |\n| `.translateX  `                  | translate the plane along the X-axis                |\n\n\nA standard plane is identified \"XY\", \"XZ\", \"YZ\", but using the function `makePlane()` you can also define a new plane with its own name. \n\nThere are a number of \".methods\" to define a sketch that can be used either on a `new Sketcher()` object or on a `draw()` object. These will be explained in the following paragraphs. \n\n\n## 3.2 Create straight lines\n\n![](https://github.com/raydeleu/ReplicadManual/blob/main/images/lines.png)\n\nStraight lines can be sketched using the line functions. Be aware that points are generally defined as a tuple or array, i.e. enclosed in square brackets. This array either contains the absolute distance in the x and y direction from the origin, or the distance and angle in case of polar coordinates. Relative distances to the x- and y-axis are defined as two separate values dx and dy. \n\n| method                           | description                                        |\n| ---------------------------------|----------------------------------------------------|\n| `.movePointerTo([x,y]) `         | move pointer without drawing, can only be used at start\n| `.lineTo([x,y])        `         | line to absolute coordinates\n| `.line(dx,dy)          `         | line to relative coordinates\n| `.vLineTo(y)           `         | vertical line to absolute y\n| `.vLine(dy)            `        | vertical line to relative y\n| `.hLineTo(x)           `         | horizontal line to absolute x\n| `.hLine(dx)            `         | horizontal line to relative x\n| `.polarLineTo([radius,theta])`   | line to absolute polar coordinates. Note that the absolute polar coordinates are defined as an vector [radius,theta]\n| `.polarLine(distance,angle)`     | line to relative polar coordinates\n| `.tangentLine(distance)`         | tangent extension over distance\n\n\n## 3.3 Create arcs and ellipses\n\n![](https://github.com/raydeleu/ReplicadManual/blob/main/images/arcs.png)\n\nThe following commands are available to create circular and elliptical arcs in your sketch. Just as with lines be aware that points are generally defined as a tuple or array, i.e. enclosed in square brackets. Relative distances to the x- and y-axis are defined as two separate values dx and dy. \nThe elliptic curves can be defined in more detail with three extra parameters. If the values are omitted the default values are used. \n\n| method                                     | description                                        |\n| -------------------------------------------|----------------------------------------------------|\n| `.threePointsArcTo(point_end,point_mid)   `| arc from current to end via mid, absolute coordinates|\n| `.threePointsArc(dx,dy,dx_via,dy_via)     `| arc from current to end via mid, relative coordinate|\n| `.sagittaArcTo(point_end,sagitta)         `| arc from current to end with sag , absolute coordinates|\n| `.sagittaArc(dx,dy,sagitta)               `| arc from current to end with sag, relative coordinates|\n| `.vSagittaArc(dy,sagitta)                 `| vertical line to endpoint with sag, relative y|\n| `.hSagittaArc(dx,sagitta)                 `| horizontal line to endpoint with sag, relative x|\n| `.tangentArcTo([x,y])                     `| arc tangent to current line to end, absolute coordinates|\n| `.tangentArc(dx,dy)                       `| arc tangent to current line to end, relative coordinates|\n| `.ellipseTo([x,y],r_hor,r_vert)           `| ellipse from current to end, absolute coordinates, radii to hor and vert|\n| `.ellipse(dx,dy,r_hor,r_vert)             `| ellipse from current to end, relative coordinates, radii to hor and vert|\n| `.ellipse(dx,dy,r_h,r_v,deg rotation, long_way?, counter?` | extra parameters ellipse, rotation around axis defined as [x,y,z] array| \n| `.halfEllipseTo([x,y],r_min, long_way?)`    | half ellipse with r_min as sag, absolute coordinates|    \n| `.halfEllipse(dx,dy,r_min, long_way?)            `    | half ellipse with r_min as sag, relative coordinates|\n\nThese functions create only partial arcs as the starting point and the end point cannot be identical. To create a circle you therefore need to define two arcs. The following code shows how to draft a circle. Note that the same can be achieved with the function `sketchCircle` or `drawCircle` (see next sections). \n\n``` javascript\nconst {draw, Sketcher} = replicad\n\nfunction main()\n{\n    let circle = new Sketcher(\"XY\")\n    .halfEllipseTo([0,20],10)\n    // first half of circle, only one radius needed, \n    // long axis is defined by coordinates\n    .ellipseTo([0,0],10,10)\n    // second half, if r_min and r_max are equal this defines a circle\n    .close()\n    .extrude(5)\n\n    return circle}\n```\n### .threePointsArc\n\nThe method `threePointsArc` creates a circular arc through three points. It always tries to create the shortest arc possible from the current point to the end point through the second point. The arc is circular, i.e. has a constant radius, but the centerpoint of the arc is determined by the location of the three points. In most drawings, finding the third point of a curve that results in an arc that is tangent to other elements is not easy. In those cases one of the other methods might be more practical. \n\n![](https://github.com/raydeleu/ReplicadManual/blob/main/images/threePointsArc.png)\n\n### .sagittaArc\n\nThe sagitta (Latin for arrow) arc is an arc defined by drawing an arc from the starting point to the end point. The \"sag\" of sagitta defines the distance between the arc and the straight line between the starting and end point (the socalled \"chord\"). Think of it as taking a flexible band between the start and end point and then flexing this band to either the right or the left side over a distance equal to the \"sag\". The little icon on the top of this section illustrates the \"sag\" of this curve. When moving in a clockwise direction, the bulge or sag of the arc is to the left of the straight line between the two outer points of the arc when the value is positive. If you want the bulge to be on the other side, you have to define a negative value for this parameter. \n\n![](https://github.com/raydeleu/ReplicadManual/blob/main/images/sagittaArc.png)\n\n### .ellipse\n\nThere are several methods to create a part of an ellipse between two points. Most of the arguments to this method are straightforward, such as the definition of the endpoint (either as a point [x,y] or as a distance dx,dy) and the definition of the horizontal and vertical radius of the ellipse. Setting these two equal results in a circular arc. The rotation parameter defines the angle in degrees over which the long axis of the ellipse is rotated. The x-direction has angle 0, the y direction is +90 degrees. The following two parameters are booleans, so can be either `true` or `false`. The first of these parameters, in the API reference identified as \"sweep\" can be understood as taking the short way or the long way. When you fit a complete ellipse between two points, you can choose which way you traverse along the ellipse. In most cases the short way is the preferred solution, thus setting this parameter to `false` is the default. The last parameter defines whether the curve is drawn clockwise (`false`, default value) or counter-clockwise (`true`). \n\nThe image below shows 4 options to draw an ellipse from the starting point (indicated with the green circle) to the end point (indicated with the red circle). \n\n![](https://github.com/raydeleu/ReplicadManual/blob/main/images/ellipse.png)\n\n\n**Remark 1**: in the definition of SVG (scalable vector graphics) the two parameters as discussed above are also available. Here the 'sweep' parameter defines whether the starting angle of the curve is positive or negative (similar to being clockwise or counter-clockwise) and the 'long-arc' parameter defines whether the long or short path should be followed. Often setting the values by trial and error is the quickest solution. \n\n### .tangentArc\n\nA tangent arc is tangent to the segment that directly precedes the arc. It will not be tangent to the line following the arc. The image below shows some examples of tangent arc. Note that in one of the cases the curve is drawn clockwise. Using the right-hand rule, the face is pointing away from the viewer. You can think of it like when you turn a screw to the right, it moves away from you. \n\n![](https://github.com/raydeleu/ReplicadManual/blob/main/images/tangentArc.png)\n\nIf you want to create a fillet or rounding that is tangent to two segments, use the method `.customCorner(radius)` that is explained in the next section. \n\n\n## 3.4 Fillets and chamfers in 2D  \nCreating a rounded edge or fillet in sharp corners of your sketch can be achieved by calculating the parameters for the arc methods described in the previous paragraphs but can also be achieved with a specialized method called `customCorner(radius)`. This method uses the radius of the rounding as an argument and is applied to the corner defined by the last coordinate of the previous drawing command. The method should therefore be placed between the two methods used to define the corner. The following code snippet shows an example how to create a rounded shape. Note that in this case, using a rounding radius that is exactly half the height of the shape fails. If you want to achieve a semi-circle at each end you have to use the arc methods described in the previous section. \n\nAs the method has to be placed in between two methods that describe a sharp corner, the method can not be used as the last statement before closing or ending the sketch. In the example below this is solved to shift the startpoint for the definition of the rectangle from the first corner in the bottom left to somewhere along the first line (drawing counterclockwise). Another point worth noting is that when rounding sharp edges, as is done in the example below, the result might be different from what you expect. \n\n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/fillet2D.png\" title=\"Adding 2D fillets to a sketch\" width=\"400\">\n\n``` javascript\nconst { draw } = replicad;\n\nconst main = () => {\n  // just lines\n  const s1 = \n  draw([20,0])\n    .hLine(30)\n    .customCorner(5.45)\n    .vLine(11)\n    .customCorner(5.45)\n    .hLine(-50)\n    .customCorner(3)\n    .line(5,-11)\n    .customCorner(5)\n    .close();\n\nreturn [ { shape: s1, color: \"blue\", name: \"Straight lines\" }]} \n```\n\nThe method `.customCorner(radius)` also supports creating chamfers. To achieve this you have to add a second argument to the method: `customCorner(radius, \"chamfer\")`. The default value of this argument is `\"fillet\"`, so it does not have to be added explicitly. The dimension of the chamfer describes the length of the straight line perpendicular to the lines that define the corner. In case of sharp corner it is difficult to predict where this corner will land and what will be the overall dimension of the resulting shape. \n\n\n<img alt=\"Adding 2D chamfers to a sketch\" src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/chamfer2d.png\" width=\"400\">\n\n``` javascript\nconst { draw } = replicad;\n\nconst main = () => {\n  // just lines\n  const s1 = \n  draw([20,0])\n    .hLine(30)\n    .customCorner(5, \"chamfer\")\n    .vLine(11)\n    .customCorner(5.45)\n    .hLine(-50)\n    .customCorner(3,\"chamfer\")\n    .line(5,-11)\n    .customCorner(5, \"chamfer\")\n    .close();\n\nreturn [\n    { shape: s1, color: \"blue\", name: \"Straight lines\" }\n]\n} \n\n```\n\n\n\n## 3.5 Free form curves\n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/curves.png\" width=\"650\">\n\nFree form curves can be created with the methods listed below. \n\n| method                                                 | description                                        |\n| -------------------------------------------------------|----------------------------------------------------|\n| `.bezierCurveTo([x,y],points[])`                       | Bezier curve to end along points[]|\n| `.quadraticBezierCurveTo([x,y],[x_ctrl,y_ctrl])`       | Quadratic bezier curve to end with control point|\n| `.cubicBezierCurveTo([x,y],p_ctrl_start,p_ctrl_end)`   | Cubic bezier curve with begin and end control points| \n| `.smoothSplineTo([x,y],splineconfig)`                  | smooth spline to end, absolute coordinates |\n| `.smoothSpline(dx,dy,splineconfig)  `                  | smooth spline to end, absolute coordinates |\n| `{startTangent:angle,endTangent:angle / \"symmetric\"}`  | `splineconfig` = configuration of spline points| \n| `drawPointsInterpolation(array[[pt1],[pt2]..[ptn]])`   | create a drawing of a curve that is an interpolation of all points in the array| \n\nA Bezier curve is a type of curve that is defined by a set of control points. It was developed by French engineer Pierre Bezier for use in the design of Renault cars in the 1960s. The important feature of a Bezier curve is that the control points influence the shape of the curve, but the curve does not necessarily pass through these points. In case of a quadratic Bezier curve there is only one control point between the startpoint and endpoint of the curve which defines the direction of the curve at both ends. Using a cubic Bezier curve it is possible to adjust the slope of the curve at both ends. The control points may be considered as a kind of magnet, pulling the curve towards it. The further the control points are placed, the stronger the curve will deviate from a straight line between the begin and endpoints. The `.bezierCurveTo` method allows a large array of control points to define the shape of the curve, but adjusting these endpoints is difficult without being able to judge the effect of these points. \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/bezier_curves.png\" alt=\"Illustration of different Bezier curves\" width=\"700\">\n\nThe `.smoothSpline` method defines a curve that passes through each point. The shape of the curve can be adjusted using the spline configuration. An example of the application of this function is shown in <<smoothspline>>. The startTangent and endTangent define the angle of the curve at its starting and end point. The factor defines how far the curve is drawn into the direction of the tangent. The larger the factor, the longer the curve wants to proceed in the direction of the specified tangent. \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/smoothsplinehook.png\" alt=\"Example of the application of the smoothSpline method\" width=\"800\">  \n\nIt is not always necessary to use the configuration at the begin and end point of a smoothSpline. In the example in <<mouse>> the `.smoothSpline` method is used between two arcs. The `smoothSpline` adapts to the tangent of the previous line segment. Without any previous line segment it uses a tangent of 0 degrees, i.e. in the x-direction (assuming a drawing area aligned with x,y coordinates). The smoothSpline does not adjust the endTangent to the next segment, so without any specification the endTangent is 0 degrees, along the x-axis. In <<mouse>> this yields the intended result without any additional configuration. \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/mouse.png\" alt=\"Using the smoothSpline between two arcs without config\"> \n\nThe code below illustrates how a `smoothSpline` curve is either tangent to the x-axis or follows the tangent of the previous line segment. It also demonstrates that with a factor of 2.63 the resulting curve is very close to a perfect arc.  \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/smoothSpline.png\" width=\"800\" alt=\"Comparison of smoothSpline curves\"> \n\nThe function `drawPointsInterpolation(array of points)` is a drawing function that draws a curve through all points listed in the array of 2D points. The code sample below shows an example how this function can be used to create the shape of an airfoil by creating an array that lists 2D points along the contour of the airfoil. Note that the curve starts and ends at the sharp trailing edge of the airfoil. The last point of the array has to be identical to the first point to create a closed curve for extrapolation. Closing the curve in another way is difficult as this drawing is created with a function, not a method that can be followed by any of the other drawing methods listed above.   \n\n``` javascript\nlet chord = 100 \nlet span  = 100\nlet airfoilPointsLarge = airfoilPoints.map(function([x,y]){return [x*chord,y*chord]}) \nlet airfoil = drawPointsInterpolation(airfoilPointsLarge).sketchOnPlane(\"XZ\");\nlet wing = airfoil.extrude(span)\n```\n\n## 3.6 Pre-baked sketches and drawings\nThe methods described in the previous chapter contain the building blocks that can be used to create any sketch or drawing. To simplify the creation of standard shapes like rectangles, circles and ellipses, some standard functions are available in Replicad. The function encapsulates the process to create a sketch or drawing, so only using the function with the required parameters is sufficient to create a sketch. Note that the `draw()` functions still have to be placed on a plane before they can be used to create 3D shapes. The sketch is always produced on the \"XY\" plane, centered at [0,0,0] unless this is changed using the optional configuration defined for the function (see table)\n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/baked-sketch.png\" width=\"650\"> \n\n| method                                                     | description                                                |\n| -----------------------------------------------------------|------------------------------------------------------------|\n| `sketchRectangle(length,width) `                           | create a sketch of a rectangle with length and width       |\n| `sketchRoundedRectangle(length,width,fillet, {config?}) `  |create a sketch of a rounded rectangle                   |\n| `sketchCircle(radius,{config?})`                           | create a sketch of a circle                                |\n| `sketchEllipse(xRadius,yRadius,{config?})`                 | create a sketch of an ellipse\n| `sketchPolysides(radius,numSides,sagitta?,{config?})`      | create a sketch of a regular polygon, where the sides of the polygon are lines or arcs with a sag from the straight line. The radius is defined without the sagitta.  \n| `sketchText(string,{textConfig?},{planeConfig}`            | create a sketch of a text. The textConfig defines the fontFamily, fontSize, startX,startY \n| `{config?}` = configuration of pre-baked sketch            | `{plane:\"XZ\",origin:dist/[point]})`                        | \n| `sketchFaceOffset(shape,thickness)           `             | create a sketch by defining an offset from an existing face in the scene\n| `sketchParametricFunction(function,{planeconfig},namedParameters?,approximation?`| create a sketch of a parametric function\n\nSimilarly as for the sketches, some pre-baked drawings are available to speed-up the creation of standard shapes. As the draw() object also allows boolean operations the creation of more complex shapes can be achieved by combining a number of standard shapes. \n\n| method                           | description                                        |\n| ---------------------------------|----------------------------------------------------|\n| `drawRoundedRectangle(length, width, radius) `| Draw a rounded rectangle centered at [0,0] \n| `drawSingleCircle(radius)                 `| Creates the `Drawing` of a circle as one single curve. The circle is centered on [0, 0]\n| `drawCircle(radius)                       `| Draw a circle with a given radius, centered at [0,0]\n| `drawSingleEllipse(majRadius,minRadius)   `| Creates the `Drawing` of an ellipse as one single curve. The ellipse is centered on [0, 0], with axes aligned with the coordinates.\n| `drawPolysides(radius, sidesCount,sagitta = 0) `| Creates the `Drawing` of an polygon in a defined plane. The sides of the polygon can be arcs of circle with a defined sagitta. The radius defines the out radius of the polygon without sagitta. \n| `drawText(\"text\",{ startX: 0, startY: 0, fontSize: 16, fontFamily: \"default\" }`| Draw a 2D text. The options can be used to adjust location, fontsize and font. \n| `drawParametricFunction(function, {options}) `| Draw a parametric function with variable t. With the option it is possible to adjust the number of intermediate points that are used { pointsCount : 400, start : 0, stop : 1 } and the type of approximation of the curve. \n| `drawPointsInterpolation(points2D[],{approximationConfig:})`  | Draw a bSpline through the array of points \n\n\n## 3.7 Methods for drawings\n\nIn the introduction to the chapter on sketches and drawings it was explained that drawings support some additional methods compared to sketches. These methods are listed in the following table. \n\n| method                           | description                                        |\n| ---------------------------------|----------------------------------------------------|\n| `.clone()`                                 | create a copy of the shape \n| `.offset(r)`                               | create a 2D offset with radius r, shape is rounded with radius, negative inwards\n| `.mirror([center/dir],[origin],mode? )`    | mode? \"center\" or \"plane\"  \n| `.translate(xDist,yDist)`                  | translate the shape \n| `.rotate(angle,[center])`                  | rotate the shape\n| `.stretch(ratio,direction,origin)`         | scale the shape in a single direction\n| `.cut(cuttingDrawing)`                     | create a 2D boolean where the drawing listed as an argument to this method is subtracted from the drawing that this method is acting on.     \n| `.intersect(drawing)  `                    | create a 2D intersection between two drawings   \n| `.fuse(other)         `                    | create a 2D boolean where the drawing listed as an argument is fused to the drawing that this method is acting on\n| `.sketchOnFace(face,scaleMode)`            | The scale mode is \"original\" for global coordinates, \"bounds\" for following UV of the receiving face or \"native\" for the default UV parameters of opencascade \n| `.sketchOnPlane`                           | place the drawing on a plane \n| `.toSVG(margin)`                          | format the drawing as an SVG image\n| `.toSVGPaths()`                            | format the drawing as a list of SVG paths\n| `.toSVGViewBox`                            | return the SVG viewbox that corresponds to this drawing\n\nThe boolean operations `cut`, `fuse` and `intersect` provide options to shortcut the creation of complicated drawings without the need for complex geometric calculations. \nUsing boolean functions and the pre-baked drawings of a circle and rectangle, creating a shape like an axle with a keyway is very simple. Notice in de code below that a drawing needs to be placed on a plane before any other method can be applied to it. \n\n``` javascript\nconst { draw, drawCircle, drawRectangle} = replicad;\n\nconst main = () => {\nlet axleRadius = 11\nlet keySlotHeight = 6\nlet keySlotWidth  = 2.50  \n\nlet axleHole = drawCircle(axleRadius)\nlet axleHole2 = drawCircle(axleRadius).translate(3*axleRadius,0)\nlet keySlot  = drawRectangle(2*keySlotWidth,keySlotHeight)\n.translate(-axleRadius,0)\nlet keySlot2  = drawRectangle(2*keySlotWidth,keySlotHeight)\n.translate(-axleRadius,0).translate(3*axleRadius,0)\nlet axleShape = axleHole.cut(keySlot).sketchOnPlane(\"XZ\")\nlet axleShape2 = axleHole2.fuse(keySlot2).sketchOnPlane(\"XZ\",20)\nlet axle = axleShape.extrude(25)\nlet axle2 = axleShape2.extrude(25)\n\n  return [axle,axle2];\n};\n```\n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/keyway.png\" alt=\"Creating an axle with a keyway using 2D boolean functions on drawings\"> \n\nThe `.intersect()` method can be used to create shapes based on the intersection of two other shapes. An example is creating a curved slot (see image below). By intersecting a ring with a sector, only a segment of the ring remains. The rounded ends of the curved slot are then added by fusing circles at each end. \n\n<img alt=\"Creating a curved slot using an intersection and union of drawings\" src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/sector_intersection.png\" width=\"800\">\n\nThe following code snippet shows the use of the 2D offset function. Offset only works on a closed curve. The curve is offset with radius r, positive values create an offset outward of the curve, negative values inward. When offsetting outward, the curve is automatically rounded with the radius r. In the code example a rounded rectangle is created by drawing a very thin rectangle, then applying an offset of 5 mm, resulting in a shape with a height of 10 mm and corners rounded with a radius of 5 mm. Then an additional shape is created with an offset of 2 mm. Finally the original shape is subtracted from the offset shape to create a thin walled shape.  \n\n``` javascript\nconst {draw} = replicad\n\nfunction main()\n{\n// frontview of receiver is just a rectangle with height 0.1 mm\nlet frontView = draw()\n.movePointerTo([-20,7])\n.hLine(40)\n.vLine(0.1)\n.hLine(-40)\n.close()\n\nlet contourBody = frontView.offset(5) // shape is offset with r=5\nlet contourHolder = contourBody.offset(2) // holder is offset with r=2\n// not that drawings have to placed on plane before extruding\nlet gpsFront = contourBody.sketchOnPlane(\"YZ\")\nlet holderFront = contourHolder.sketchOnPlane(\"YZ\")\nlet gpsReceiver = gpsFront.extrude(70)\nlet gpsHolder = holderFront.extrude(72).cut(gpsReceiver)\n\nreturn [gpsReceiver,gpsHolder]\n}\n``` \n\n<img alt=\"Creating a thin walled shape with an offset\" src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/offset2D.png\" \n width=\"500\">\n\n\nHave a look at https://studycadcam.blogspot.com/ for training exercise for your 2D drawing skills. \n\n## 4.1 Create wires in 3D \nIn comparison to sketches which create wires or faces in 2D, the following functions create a wire in 3D. These wires can be used for example to create a 3-dimensional path for a sweep operation. This operation might be needed to create a tube that is bend in a 3-dimensional shape, such as the frame of a chair. \n\n| method                                                               | description                  |\n|----------------------------------------------------------------------|------------------------------|\n| `makeLine([point],[point]) `                                         | Create a straight 3D line    |\n| `makeCircle(radius,[center],[normal])`                               | Create a 3D circle wire      |\n| `makeEllipse(major,minor,[center],[normal])`                         | Create a 3D ellipse          |\n| `makeHelix(pitch,height,radius,[center],[dir],lefthand?)`            | Create a 3D helix, center and helix a [x,y,z]|\n| `makeThreePointArc([point1],[point2],[point3])`                      | Create 3D arc through 3 points |\n| `makeEllipseArc(major,minor,anglestart,angleEnd,[center],[normal],[xDir?])`| Create 3D ellipsoid arc  |\n| `makeBSplineApproximation([points[],{bezierSplineApproximationConfig})`| Create a 3D spline approximation through array of points |\n| `{tolerance:1e-3,smoothing:null/[x,y,z],degMax:6,degMin:1}`          | bezierSplineApproximationConfig, configuration for spline | \n| `makeBezierCurve([points[]])`                                        | Create a 3D bezier curve through array of 3D points|\n| `makeTangentArc([startPoint],[tangentPoint],[endPoint])`             | Create a 3D tangent arc, tangentPoint is like vector |   \n| `assembleWire([Edges])`   `                                          | Create a continuous edge from separate wires | \n\n\n## 4.2 Create faces in 3D\n\nYou can not only create wires in 3D but also complete faces. The difference between a wire and a face is that a face consists of a sketch or 3D wire that encloses a surface. This surface can be flat but also bend in space. \n\n| method                                | description                  |\n|---------------------------------------|------------------------------|\n| `makeFace(wire)`                      | Create a face from a wire consisting only of edges\n| `makeNewFaceWithinFace(face,wire)`    | Create a face on another face using a wire   \n| `makeNonPlanarFace(wire)`             | Create a curved surface from a non-planar wire\n| `makePolygon(points[])`               | Create a face from an array of points in a plane\n| `makeOffset(face,offset,tolerance)`   | Create an offset to a face\n| `makePlaneFromFace() `                | Extend a face out to an infinite plane parallel to this face\n| `makeSolid(faces[]/shell)`            | Create a solid from the volume that is defined by the array of faces or by a surface. \n\n\nThe following code example demonstrates how faces in 3 dimensions can be created using a quite complicated algorithm. In this example, the faces consisting of triangular surfaces are assembled in such a way that they completely enclose a volume, without leaving a gap. Using the method `makeSolid` the volume enclosed by these faces can then be converted to a solid. In the image below this is demonstrated by cutting a sphere out of the newly created shape. Note that without this final step, the faces represent infinitely thin surfaces floating in space. This might be sufficient to create a 3D shape for visualization, but does not allow 3D printing the object. The next section will explain the concept of shapes (solids) in more detail. \n\n<img alt=\"Icosahedron shape created from faces\" src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/icosahedron.png\" width=\"500\"> \n\n``` javascript\nfunction projectOnSphere(radius, vertex) {\n  // function to project a vertex on to a sphere with radius \"radius\"\n  let x = vertex[0];\n  let y = vertex[1];\n  let z = vertex[2];\n  let currentRadius = Math.sqrt(\n    Math.pow(x, 2) + Math.pow(y, 2) + Math.pow(z, 2)\n  );\n  let scale = radius / currentRadius;\n  let scaledVertex = [scale * x, scale * y, scale * z];\n  return scaledVertex;\n}\n\nconst icosahedronFaces = (radius) => {\n  let golden = (1 + Math.sqrt(5)) / 2;\n\n  let v = [\n    // vertices determined by 4 rectangles\n    projectOnSphere(radius, [-1, golden, 0]),\n    projectOnSphere(radius, [1, golden, 0]),\n    projectOnSphere(radius, [-1, -golden, 0]),\n    projectOnSphere(radius, [1, -golden, 0]),\n\n    projectOnSphere(radius, [0, -1, golden]),\n    projectOnSphere(radius, [0, 1, golden]),\n    projectOnSphere(radius, [0, -1, -golden]),\n    projectOnSphere(radius, [0, 1, -golden]),\n\n    projectOnSphere(radius, [golden, 0, -1]),\n    projectOnSphere(radius, [golden, 0, 1]),\n    projectOnSphere(radius, [-golden, 0, -1]),\n    projectOnSphere(radius, [-golden, 0, 1]),\n  ];\n\n  // faces added so that they always have an edge in common\n  // with the previous ones\n  return [\n    [v[0], v[11], v[5]],\n    [v[0], v[5], v[1]],\n    [v[0], v[10], v[11]],\n    [v[0], v[7], v[10]],\n    [v[5], v[11], v[4]],\n    [v[4], v[9], v[5]],\n    [v[3], v[9], v[4]],\n    [v[3], v[8], v[9]],\n    [v[3], v[6], v[8]],\n    [v[3], v[2], v[6]],\n    [v[6], v[2], v[10]],\n    [v[10], v[7], v[6]],\n    [v[8], v[6], v[7]],\n    [v[0], v[1], v[7]],\n    [v[1], v[5], v[9]],\n    [v[11], v[10], v[2]],\n    [v[7], v[1], v[8]],\n    [v[3], v[4], v[2]],\n    [v[2], v[4], v[11]],\n    [v[9], v[8], v[1]],\n  ];\n};\n\nconst main = (\n  { makeSolid, sketchRoundedRectangle, makeSphere, makePolygon },\n  {}\n) => {\n  function makeIcosahedron(radius) {\n    const faces = icosahedronFaces(radius).map((f) => makePolygon(f));\n    return makeSolid(faces);\n  }\n\n  // draw the isosphere\n  let icosahedron = makeIcosahedron(2.0).scale(50);\n  const sphere = makeSphere(100).translate([90, 30, 20]);\n  \n  // cut the icosahedron with a sphere to demonstrate that the first \n  // shape is indeed a solid, no longer collection of faces\n  icosahedron = icosahedron.cut(sphere)\n\n  let shapes = [\n  {shape: icosahedron, name: \"icosehadron\", color: \"steelblue\"}\n  ]\n  return shapes;\n};\n\n```\n\n## 5.1 What is a shape or solid?\n\nA solid in OpenCascade is a 3D volume that is closed. Closed means that the infinitely thin surfaces that build the shape enclose the volume completely. \n\n<img src=https://github.com/raydeleu/ReplicadManual/blob/main/images/thickness.png width=\"800\"> \n\nThe generic command to create a 3D solid shape from a 2D sketch is based on adding thickness. This can be performed using the following basic command, where the method `thicknessMethod` has to be replaced with any of the methods listed in the table below. \n\n``` javascript\nlet shape = sketch.thicknessMethod\n``` \n\n## 5.2 Methods to add thickness to a 2D sketch\n\nThe `.thicknessMethods` that are available to add thickness or volume to a 2D sketch are listed below. The configurations consists of a number of parameters between curly brackets. In some cases the configuration can contain other configurations. In the next sections the commands will be clarified with code examples, so the table is intended only for quick reference. The parameters with a questionmark have a default value and can be omitted when the default is applicable. \n\n| method                                     | description                                                                                                |\n| -----------------------------------------------------|------------------------------------------------------------------------------------------------------------|\n| `.extrude(distance,{extrusionConfig?}) `               | extrude a face over a distance normal to the face.                                                         |\n| `{extrusionConfig}`                                    | `origin:[xyz], extrusionDirection[xyz],twistAngle:deg,{extrusionProfile}`                                  |\n| `{extrusionProfile}`                                   | {profile:\"linear\" / \"s-curve\", endFactor: scale}                                         |\n| `.loftWith([otherSketches],{loftConfig},returnShell?)` | build a solid through lofting between different wires                                    |\n| `{loftConfig}`                                         |{ruled: boolean, endPoint:[point],startPoint:[point]}                                     |                   \n| `.revolve(revolutionAxis:[point]?,revolveConfig?)`     | revolve a drawing around the z-axis (or indicated axis) to create a solid shape.         |                    \n| `{revolveConfig}`                                      | `{origin: [xyz]}`  origin on which axis of revolution is centered                        |   \n| `revolution(face,[origin],[direction],degrees)`        | revolve a face around the axis identified in the function, over the angle indicated in degrees    | \n| `.face()`                                              | This is not really a thickness method  but a method to create the first surface from a sketch or drawing. Note that this method is not needed in most cases as a closed sketch already is translated into a face that can be used directly for extrusion, revolving or sweeping. \n| `.sweepSketch( (plane, origin) => sketchFunction(plane,origin) )` |  Sweep the sketch defined by the sketchFunction along the sketch used as the object for this method.\n| `makeSolid(faces[]/shell)`                             | Create a solid from the volume that is defined by the array of faces or by a surface. \n\n\n\n### 5.2.1 .extrude()\n\nExtruding adds thickness to a drawing in the direction normal to the drawing, thereby creating a solid. You can think of it like pushing dough through a hole that has the shape of the drawing. In the simplest form you only have to specify the height of the extrusion. As shown in the image below you can adapt some characteristics of the extrusion. \n\n<img src=https://github.com/raydeleu/ReplicadManual/assets/38007983/fa12f0de-991d-4208-ac82-b2e6b20ca13d> \n\nThe following code explains some of the modifications that you can apply to the extrusion. The first parameter, the extrusion height determines the distance over which the extrusion is performed. In a normal situation this is also the height of the resulting object, but if the extrusion axis is tilted and not performed from the center of the object (i.e. the origin of the extrusion is different from the origin of the object) the height can be different from the extrusion distance. The `twistAngle`, in degrees, determines how many degrees the extrusion is twisted during the extrusion. Finally, the `extrusionProfile` allows to change the scale of the drawing during the extrusion and to change the profile followed between the profile at the start and the profile at the end of the extrusion. The \"s-curve\" profile creates a profile that starts and ends in the direction of the extrusion but adapts to the change in width of the extrusion as defined by the \"endFactor\".\n\n\n``` javascript\n// create a drawing that you want to extrude\nlet rectangleDrawing = drawRoundedRectangle(50,30,3)\n.translate([-40,40]).sketchOnPlane(\"XY\")\n\nlet extrudeDraft = rectangleDrawing.clone()\n.extrude(30,                                                // height of the extrusion\n{origin: [-40,40,0],                                        // if the drawing was translated you have to adjust the origin as well            \nextrusionDirection: [0,0,1],                               // direction of the extrusion in relation to the origin\ntwistAngle:90,                                             // the twist applied during the extrusion \nextrusionProfile: { profile: \"s-curve\", endFactor: 0.5 }}) // the profile of the extrusion\n```\n\nIt is important to note that many of the modifications relate to the origin, so often it is easier to create your model at the origin and translate it after building the solid than to move the drawing and apply the extrusion later. \n\nTo create a solid using extrusion, the sketch or drawing that you use as a base for extruding should be closed. It is possible to extrude an open wire, but this results in a shell instead of a solid. \n\n### 5.2.2 .revolve()\n\nThe method `.revolve()` creates a shape based on revolving the drawing around the z-axis. The drawing that is revolved should be closed, so the edges should completely enclose an area and form a face. Revolving an open (i.e. non-closed) drawing will result in the creation of a shell instead of a solid. The difference is shown in the image below. \n\n<img src=https://github.com/raydeleu/ReplicadManual/assets/38007983/d9610383-9d06-4c85-9568-2dacb504db03 width=\"600\">\n\nIf you want to use another axis for the revolution, you can add a point that indicates the direction from the origin. If you want to use another origin for the axis of revolution this can be added in a configuration between curly brackets. In the example below the rotation is performed around the x-axis with the origin displaced to z = -10.  \n\n``` javascript\nlet profileClosed = draw()\n.line(20,0).line(5,5).line(0,30).line(-25,0)\n.close().sketchOnPlane(\"XZ\")\n.revolve([1,0,0],{origin:[0,0,-10]})\n.translate(-30,-30)\n----\n\nThe `.revolve()` method always revolves a shape over 360 degrees. If you dig into the documentation you will find a function called `revolution` that allows to create a body of revolution where the angle can be defined. The function requires a face as input, so you need to add the `face()` method after a drawing to create a face first. The code then look like this: \n\n[source, javascript]\n----\nlet {draw} = replicad\nfunction main(){\n// let solid = revolution(face,[x,y,z origin],[x,y,z direction], degrees)\nlet profile = draw().hLine(10).line(3,5).hLine(-13).close().sketchOnPlane(\"XZ\")\nlet halfCircle =  revolution(profile.face(),[0,0,0],[0,0,1],180)\nreturn halfCircle}\n```\n\n### 5.2.3 .loftWith()\n\nThe method `.loftWith(sketch/placed drawing)` builds a loft along the sketches fed to the method.\n\nTo create a loft you need two or more (placed) drawings. In the following example three profiles are drawn and placed on different planes. Then one of the profiles is used as the parent to which the `loftWith()` method is applied. The method can accept multiple profiles ordered in an array. The order of the drawings in the array determines the way the loft is built. \n\n<img src=https://github.com/raydeleu/ReplicadManual/assets/38007983/d5da73ae-3c28-40e2-a3fc-752e4122f5d7>\n\nIn the example, the drawings used for the loft are clones (using the `.clone()` method) to be able to re-use or display the drawings. The loft method normally deletes the drawings after creating the loft to save memory. \n\n``` javascript\nconst {draw} = replicad\n\nfunction main(){\nlet scale = 1/10\nlet baseLength = 200*scale;\nlet topLength = Math.sqrt((2*Math.pow((baseLength/2),2)))\nlet height = (1368-196.85)*scale\n\nlet baseProfile = draw()\n.hLine(baseLength).vLine(baseLength).hLine(-baseLength).close()\nbaseProfile = baseProfile.translate([-baseLength/2,-baseLength/2]).sketchOnPlane(\"XY\")\n\nlet midProfile = draw().hLine(baseLength/2).polarLine(topLength/2,45).vLine(baseLength/2)\n.polarLine(topLength/2,135).hLine(-baseLength/2).polarLine(topLength/2,225)\n.vLine(-baseLength/2).close()\nmidProfile = midProfile.translate([-baseLength/4,-baseLength/2]).sketchOnPlane(\"XY\",height/2) \n\nlet topProfile = draw().polarLine(topLength,45).polarLine(topLength,135)\n.polarLine(topLength,225).close()\ntopProfile = topProfile.translate([0,-baseLength/2]).sketchOnPlane(\"XY\", height)\n\nlet tower = baseProfile.clone().loftWith([midProfile.clone(),topProfile.clone()],{ruled:true})\nlet tower1 = baseProfile.clone().loftWith([midProfile.clone(),topProfile.clone()],{ruled:false})\n.translate(30,0,0)\nlet tower2 = baseProfile.clone().loftWith(topProfile.clone(),{ruled:true}).translate(60,0,0)\n\nreturn [{shape: baseProfile, color:\"orange\"},{shape:midProfile, color: \"orange\"}\n,{shape:topProfile, color:\"orange\"},{shape: tower, opacity:\"0.5\"}\n,{shape: tower1},{shape: tower2}]} \n``` \n\nIt is also possible to use a sketch as a profile for the loft. The code below shows an extract from the definition of a watering can that is based on the `loftWith` method. Three circles are used to define the shape. In this case the circles are created using a `sketch` object. Note that you need to extract the face before creating the loft, using the `face()` method. Using a drawing instead of a sketch therefore is a bit more intuitive. As we will see below, you cannot use a face extracted from an object to create the loft, which seems contradictionary with the need to create a face from a sketch. \n \n``` javascript\n// create cross sections of the filler for the carafe\n//          used a workaround to rotate and translate the sketch to the required position\nlet fillHole = sketchCircle(12).face().rotate(-20,[0,0,0],[0,1,0]).translate([-35,0,135])\nfillHole = sketchFaceOffset(fillHole,0);\nlet topBody = sketchCircle(8).face().translate([0,0,100]);   // radius 8 at 100 mm \ntopBody = sketchFaceOffset(topBody,0); \nlet fillBottom = sketchCircle(9).face().rotate(20,[0,0,0],[0,1,0]).translate([0,0,80]); \nfillBottom = sketchFaceOffset(fillBottom,0); \n\n// filler shape is created as a loft between the three wires\nlet filler    = fillHole.loftWith([topBody,fillBottom],{ruled: false});\n```\n\nThe configuration `{ruled: false}` produces a smooth line between the profiles, whereas the configuration `{ruled: true}` creates straight lines between the profiles. \n\nimage::https://github.com/raydeleu/ReplicadManual/blob/5264639f36465962ddd70235d066d02764791ebb/images/loft-examples-ruled.png[]\n\nThe following source sample shows how to extract a face from an existing object and use this as part of a loft. Here a new sketch is created from the edges extracted from the face of the object. This is necessary as a face on an object can also contain holes, whereas the wire to create the loft should be closed and not contain a hole. \n\n<img src=https://github.com/raydeleu/ReplicadManual/assets/38007983/fb7eab29-7829-41bd-9f89-6f8f0f7a12cd>\n\n\n``` javascript\nconst r = replicad\n\nexport default function main(p) {\n  const box = r.makeBaseBox(30, 10, 20).translateY(-5)\n\n  const triBase = new r.FaceFinder().inPlane(\"XZ\", 0).find(box, { unique: true })\n  const triMid = r.drawCircle(10).translate(0, 10). // lay onto XY plane\n    sketchOnPlane(\"XZ\", -20)\n  const triTop= r.drawCircle(10).translate(0, 10). // lay onto XY plane\n    sketchOnPlane(\"XZ\", -50)\n\n  // I should expose this as a helper `sketchFace` function\n  const faceSketch = new r.Sketch(triBase.clone().outerWire(), { \n    defaultDirection: triBase.normalAt(triBase.center), \n    defaultOrigin: triBase.center \n  })\n\n  const tri = triTop.clone().loftWith([triMid,faceSketch],{ruled: true})\n\n  return [\n    { shape: box, name: \"sleeve\", color: \"green\", highlightFace: (f) => f.inPlane(\"XZ\", 10) },\n    { shape: tri, name: \"tri\", color: \"blue\" },\n    { shape: triBase, name: \"triBase\", color: \"red\" },]}\n```\n\nIf you want to start or end the loft with a single point, you can use the configuration setting `startPoint` or `endPoint`. The sample below demonstrates how to use this configuration. \n\n``` javascript\nconst { drawRoundedRectangle, drawCircle } = replicad;\nconst main = () => {\n  const rect = drawRoundedRectangle(5, 10).sketchOnPlane();\n  const circle = drawCircle(3).sketchOnPlane(\"XY\", 10);\n\n  return rect.loftWith(circle, { endPoint: [2, 2, 15] });\n};\n```\n\n### 5.2.3 .sweepSketch()\n\nThe method `.sweepSketch` can be used to create a solid by sweeping a sketch along another curve. An example is the chair profile shown in the icon at the beginning of this chapter or the ringshape shown in the image below:  \n\n<img src=https://github.com/raydeleu/ReplicadManual/blob/main/images/sweepSketch-samples.png>\n\nThe source to create these shapes is: \n\n``` javascript\nconst {Sketcher, sketchRectangle, sketchRoundedRectangle,draw}=replicad\n\nconst main = () => {\n  let p0 = [0, 0];\n  let p1 = [50, 100];\n  let p2 = [60, -110];\n  let p3 = [70, 50];\n  let p4 = [100, 25];\n  let points = [p1, p2, p3, p4];\n\n// create wavy path on XZ plane\nlet basePath = new Sketcher(\"XZ\")\n    .movePointerTo(p0)\n    .bezierCurveTo(p4, points)\n    .done()\n\n// sweep a rectangle along the wavy path\nlet baseShape = basePath.clone().sweepSketch((plane, origin) => \n                sketchRectangle(2, 30, { plane, origin }))\n                .translate(0,-40);\n\n// create a path consisting of rounded rectangle\nlet topPath = sketchRoundedRectangle(110,30,5,{plane:\"XY\",origin:[50,0,26]})\n\n// create an L-shaped cross section\nfunction ringSection(plane,origin) \n{let section = new Sketcher(plane,origin)\n    .hLine(10).vLine(-3).hLine(-8)\n    .vLine(-26).hLine(-2).close()\n  return section}  \n\nlet ringSectionDraw=draw()\n.hLine(10).vLine(-3).hLine(-8)\n.vLine(-26).hLine(-2).close().sketchOnPlane(\"YZ\")\n\n// sweep the L-shaped section along the rounded rectangle\nlet topSweep   = topPath.sweepSketch((plane, origin) => ringSection(plane,origin))\n.translate(0,60)\n\nreturn [topSweep, baseShape, ringSectionDraw]}\n``` \n\nAs shown in the code above, the `sketchFunction` used in the `.sweepSketch()` can be derived from either a standard sketching function, such as `sketchRectangle(2, 30, { plane, origin })` or by defining your own closed sketch using a `Sketcher` object. This object should then refer to a `(plane, origin)` like this: \n\n``` javascript\n            function sketchFunction(plane,origin) \n            {let section = new Sketcher(plane,origin)\n                    (add sketch commands)\n                    .close()\n            return section}\n``` \n\nA swept object can also be used to cut a profile in another shape. The image below shows an example where the contour of a knop is rounded with a large radius. This is achieved by creating a profile with the appropriate radius that encloses the area that should be \"shaved\" off. \n\n<img src=https://github.com/raydeleu/ReplicadManual/blob/main/images/sweep-knob.png>\n\nThe cross section is shown in red, projected on the XY plane. The object resulting from the `.sweepSketch()` method is displayed with a transparent material on top of the knob. \n\n\n``` javascript\n// identical to side view but only top edge\n// to be used as a rail to sweep the 32mm radius profile  \nlet sweepRail = draw()\n.movePointerTo([-60,0])\n.ellipse(20*Math.sin(Math.PI/6),20*Math.cos(Math.PI/6),20,20,0,0,false)\n.smoothSplineTo([0,32])\n.ellipse(32,-32,32,32,Math.PI/2,0,false)\n.done()\n.sketchOnPlane(\"YZ\")\n\n// create a rounded profile to shape finger of knob  \nfunction sweepProfile(plane,origin)\n{let section = new Sketcher(plane,origin)\n.movePointerTo([segmentHeight,-20])\n.lineTo([segmentHeight,-16])\n.threePointsArcTo([segmentHeight,16],[0,0])\n.lineTo([segmentHeight,20])\n.lineTo([-1,20])\n.lineTo([-1,-20])\n.close()\nreturn section}\n\nlet profileCut = sweepRail.clone()\n.sweepSketch((plane,origin) => sweepProfile(plane,origin))\n```\n\nThe so-called boolean function to cut the material will be discussed in the Chapter [[Combine solids to parts]]. \n\n### 5.2.6  makeSolid()\n\nThe `makeSolid` function can be used to create a solid from a number of faces. The faces need to enclose a volume without any gap. The following code example shows how to create a so-called antiprism. The model represents the One World Trade Center. The following image shows the same shape but for clarity the height is reduced: \n\n<img src=https://github.com/raydeleu/ReplicadManual/blob/main/images/anti-prism-short.png>\n\nThe shape is created by first creating the triangles that make up the sides of the shape, using the `makePolygon()` method discussed in the previous chapter. The solid is then built by joining these triangles together with the square bottom and top faces. \n\n``` javascript\nconst {draw, drawRectangle, makePolygon, makeSolid} = replicad;\n\nfunction main()\n{\nlet bL = 200/10;  // base length is 200 ft\nlet h = 1368/10;  // height 1368 ft\nlet m = (60/0.3048)/10; // first 60 meters are straight, converted to feet\n\n    function antiPrism(bLength,prismHeight,endScale)\n    {\n        let bL = bLength/2;\n        let tL = bL/Math.sin(Math.PI/4)\n        let base=[]\n        base[1] = [-bL,-bL,0];\n        base[2] = [bL,-bL,0];\n        base[3] = [bL,bL,0];\n        base[4] = [-bL,bL,0];\n        base[5] = base[1]   // trick to avoid need for modulus 4\n\n        let top=[]\n        top[1] = [0  ,-tL*endScale ,prismHeight]\n        top[2] = [tL*endScale  , 0  ,prismHeight]\n        top[3] = [0 ,tL*endScale  ,prismHeight]\n        top[4] = [-tL*endScale ,0   ,prismHeight]\n        top[5] = top[1]    // trick to avoid need for modulus 4\n\n        let face=[]\n        face[1] = makePolygon([base[1],base[4],base[3],base[2]]);        \n        // not defined counterclockwise to have face facing in negative z-direction\n        for (let i=2 ; i<=8; i+=2)\n            {\n            face[i]     = makePolygon([top[i/2],base[i/2],base[i/2+1]]);\n            face[i+1]   = makePolygon([base[i/2+1],top[i/2+1],top[i/2]]);\n            }\n        face[10] = makePolygon([top[1],top[2],top[3],top[4]]);\n        return face;\n        }\nlet faces = antiPrism(bL,h,Math.sin(Math.PI/4));\nlet tower = makeSolid(faces).translate(0,0,m);\nlet towerbase = drawRectangle(bL,bL).sketchOnPlane(\"XY\").extrude(m)\ntower = tower.fuse(towerbase)\nreturn tower}\n``` \n\n## 5.3 Pre-baked shapes\n\nThe methods specified above can be used to create complex shapes but also to create standard shapes like boxes, cylinders or spheres. As these shapes are often used as basic building blocks, Replicad provides a number of functions to automate the creation of the standard shapes. These functions are explained in the following table: \n\n| method                                                       | description                                        |\n| -------------------------------------------------------------|----------------------------------------------------|\n| makeCylinder(radius,height,[location],[direction])           |create a cylinder                                   |\n| makeBaseBox(xLength,yLength,zLength)                         |create a box                                        |\n| makeSphere(radius)                                           |create a sphere                                     |\n| makeVertex([point])                                          |create a vertex/point                               |\n\nThe shapes listed above are the same shapes that are available in most CAD programs and OpenSCAD. The CAD program for beginner, offered by the company Autodesk at https://tinkercad.com) offers even more basic solids. Apart from the box, cylinder and sphere there are shapes like half domes, piramids, extruded hexagons, donuts et cetera. \n\n\n![tinkercad shapes](https://github.com/raydeleu/ReplicadManual/assets/38007983/de372431-6a53-4bf8-aae4-ade75a9907b9)\n\nMost of these shapes can be created easily with the methods described in this chapter. The following image shows the shapes as created with functions that were described in this and the previous chapters. The only difference is the rounded cube. How all sides of the cube can be rounded will be discussed in Chapter 6. \n(The code to create these shapes can be found in the Appendix with examples). \n\n![image](https://github.com/raydeleu/ReplicadManual/assets/38007983/93d3a22c-7108-4fff-85a8-f89382a2c9a0)\n\nIf you want to use these shapes as quick building blocks, automating the creation of these shapes using functions will allow you to re-use these components. This will be discussed in Chapter [[9. Automate modelling with functions]]. \n\n\n\n\n\n<img src=https://github.com/raydeleu/ReplicadManual/blob/main/images/mm2023-parts.png>\n\nAs shown in <<img-mm2023-parts>> it is possible to create quite complicated parts by just combining simple shapes such as boxes, spheres and cylinders. The shape used in this image is an exercise called Model Mania organized by the company that created the Solidworks CAD program. There are only some fillets missing which were obviously too complicated for the OpenCascade modelling kernel. The shapes are combined using the boolean operations decribed in <<Combine shapes>>. Some of the edges of the basic shapes were rounded. How this can be achieved is explained in <<Modify shapes>>. The result is shown in the image below.  \n\n<img src=https://github.com/raydeleu/ReplicadManual/blob/main/images/mm2023-complete.png>\n\n\n\n\n\n\n## 6.1 What are modifications? \n\nThis section explains how to modify a 3D solid that was created using the functions and methods decribed in the previous chapter. Modifications as described in this section only relate to a single shape. Combining multiple shapes, through fusing, subtracting or intersecting, will be described in the next chapter. \n\nThe following table lists modifications that can be applied to a solid. \n\n| method                           | description                                        |\n| ---------------------------------|----------------------------------------------------|\n|` .fillet(radiusConfig,filter?) `                                   | round an edge of a shape with a fixed radius or a radius that is defined by a function. The filter refers to the selection mechanism defined in the next secion. It has the general shape of (e) => e.inDirection(\"X\")  \n|` .chamfer(radiusConfig,filter?) `                                  | take of a sharp edge by creating a transitional face, default at 45 degrees to a edge\n|` .shell(thickness, (f) => f.inPlane(\"YZ\",-20),{tolerance:number})` | create a thin walled object from a shape, removing the indicated face from the shape to provide access to the hollow inside. \n|` makeOffset(shape,thickness)`                                      | create a shape that is offset from the original shape by the thickness. A positive number results in an increased size of the shape, a negative value will result in a smaller shape\n|` .addHolesInFace(face,holeWires[])`                                 | create a hole in a shape using the wires that are indicated in the parameters to this function. \n \n\nMost of the methods listed in the table require the selection of an edge or face of the shape. Therefore the next subsection will explain how edges and faces can be selected. \n\n## 6.2 Selecting faces or edges for modification\nSome of the methods listed in the previous subsection can be used without indicating a specific face or edge.For example, if a fillet is applied to a shape, the same radius of rounding is applied to all sharp edges in the shape. However, in most cases the fillet should be applied only to specific edges. In most visual CAD programs, the edges for the fillet operation are selected with the mouse cursor in the 3D view. In Replicad a filter mechanism has to be used to find the edges. The next paragraphs explain how faces or edges can be selected. Faces are relevant to create a thin walled object (shell) or to create holes in a face. Finding edges is relevant to create rounded edges (fillets) or chamfers.  \n\n### 6.2.1 Selecting faces\n\nFaces can be selected using a `FaceFinder` object or using the so-called arrow notation of javascript. The arrow notation is a shorthand notation to define a function that changes the value of a given parameter. The following code explains this in more detail:  \n\n\n``` javascript\n// create a variable as a new object to which a selection-method is applied\nlet foundFaces = new FaceFinder().inPlane(\"XZ\",35)\n// use this variable as an input to create a shell \nlet hollowShape = solidShape.shell(thickness, (f)=>foundFaces,{tolerance:number})\n\n// use the arrow notation to select a face directly as parameter to a method to change a shape \nlet hollowShape = solidShape.shell(thickness, (f) => f.inPlane(\"YZ\",-20),{tolerance:number})\n ```\n\nThe following methods to select faces are available: \n\n| method                           | description                                        |\n| ---------------------------------|----------------------------------------------------|\n|` .inPlane(\"XZ\",35)`                                           | select all faces that are positioned in a given plane and offset\n|` .parallelTo(plane/face/standardplane)`                                        | select a face parallel to a given plane or face\n|` .ofSurfaceType(\"CYLINDRE\")`                                                   | select all faces of a certain type\n|` \"PLANE\" / \"CYLINDRE\" / \"CONE\" /\"SPHERE\"/ \"TORUS\" / \"BEZIER_SURFACE\"       /\"BSPLINE_SURFACE\"/\"REVOLUTION_SURFACE\"/\"EXTRUSION_SURFACE\"/ \"OFFSET_SURFACE\"/\"OTHER_SURFACE\" `                                               | surface types to use with surfaceType selector \n|` .containsPoint([0,-15,80])`                                                   | select a face that contains a given point\n|` .atAngleWith(direction,angle)`                                                | select a face at a certain angle to an axis or plane atAngleWith(\"Z\",20)\n|` .atDistance(distance,point)  `                                                | select a face at a given distance to a point \n|` .inBox(corner1,corner2)       `                                               | select a face that is partially located inside the given box\n|` .inList(elementList[])    `                                                   | select a face that is in the elementList\n|` find(shape,options), options {unique: true}`                                  | returns all the elements that fit the filters\n \n\n\n\n\n\n### 6.2.2 Selecting edges\nSelecting edges works similar to selecting faces.\n\n``` javascript\n// create a variable as a new object to which a selection-method is applied\nlet foundEdges = new EdgeFinder().inPlane(\"XZ\",35)\n// use this variable as an input to create a shell \nlet roundedShape = solidShape.fillet(radius, (e)=>foundEdges,{tolerance:number})\n\n// use the arrow notation to select an edge directly as parameter to a method to change a shape \nlet roundedShape = solidShape.fillet(thickness, (e) => e.inPlane(\"YZ\",-20),{tolerance:number})\n ```\n\nThe following selection mechanisms can be used to find and select edges: \n\n| method                           | description                                        |\n| ---------------------------------|----------------------------------------------------|\n|` .inDirection([x,y,z]/\"X\"/\"Y\"/\"Z\")`                     | find all edges that have the direction\n|` .atAngleWith(direction,angle)`                        | atAngleWith(\"Z\",20)\n|` .ofLength(number)`                                    | find all edges with a particular length\n|` .containsPoint([0,-15,80])`                           | find edges that go exactly through a point\n|` .atDistance(distance,point)`                          | same as .containsPoint but allows some margin around the defined point \n|` .inBox(corner1,corner2)`                              | finds all edges that are (partly) within a box\n|` .inList(elementList[])`                               | see issue https://github.com/sgenoud/replicad/issues/13, does not work yet\n|` .inPlane(inputPlane,origin)`                          | inPlane(\"XY\",30), find all edges that are exactly in the defined plane\n|` .ofCurveType(       )`                                | find all edges of a certain curve type. \"LINE\", \"BSPLINE_CURVE\", \"CIRCLE\"\n|` .parallelTo(plane / StandardPlane e.g. \"XY\")`         | find all edges parallel to a stanadard plane\n|` .shouldKeep todo?`                                    | tbd\n \n\n>[!NOTE]\n>When you reference faces or edges with their index, using the `.inList` method, you may experience the issue of the Topological Naming Problem. If the change to the design parameters results in a changing number of edges or faces, the fillet will no longer be applied to the correct edges. So use this method with care, if you only allow minor changes to the design such as using a different tolerance between two parts. Note that this selector currently does not work as expected, see issue https://github.com/sgenoud/replicad/issues/13. \n\n\n\n### 6.2.3 Combine filters \n\n| method                           | description                                        |\n| ---------------------------------|----------------------------------------------------|\n|`and`                             | both filters should be applied\n|`either`                          | only one of the filters may be applied\n|`not`                             | select all other edges than those selected by this filter\n\n\n ``` javascript       \n            const houseSides = new FaceFinder().either([\n            (f) => f.inPlane(\"YZ\", 50),\n            (f) => f.inPlane(\"YZ\", -50),]);\n     \n             const frontWindow = new EdgeFinder()\n            .ofCurveType(\"CIRCLE\")\n            .not((f) => f.inPlane(\"XZ\"));  \n ```\n\nBelow is an example how finders can be combined in the definition of a fillet. \n\n ``` javascript       \nlet axleShape2 = axleHole2.fuse(keySlot2).sketchOnPlane(\"XZ\",20)\nlet axle2 = axleShape2.extrude(25)\n            .fillet(2,(e)=>e.either([\n                          (e)=>e.inPlane(\"XZ\",45),\n                          (e)=>e.inPlane(\"XZ\",20)]) )\nreturn [axle2];\n ```\n\n## 6.3 .fillet() \n\nA fillet is a rounded edge. In real products a fillet is often used to remove sharp edges that can be damaged easily and can also cause damage to people and other parts. A rounded corner is easier to coat and paint and after its application the risk of paint peeling of the corner is smaller. A fillet therefore improves the longevity of the product. The rounding on internal edges also helps to reduce stress concentrations. And finally a rounding can help to mate parts, although a chamfer (see next section) is often preferred in that case. \n\nThe fillet method in Replicad has the following form: \n\n``` javascript\n let roundedBox = box.fillet(radius,(e)=>e.edgeSelectingMethod) \n```\nThe `edgeSelectionMethod` can be a combination of one or more selection methods as described in the previous section. If the edge selection is omitted, Replicad will try to round all edges of the object. When you select an edge, Replicad uses the \"tangent chain\" approach to continue the rounding until it encounters a sharp corner. This is illustrated in the image below. Only the edges in the \"X\" direction are selected for filleting, yet all edges that have a tangent connection to these edges are also rounded. \n\n<img width=\"893\" alt=\"image\" src=\"https://github.com/raydeleu/ReplicadManual/assets/38007983/f032cab0-a956-42f1-88eb-0a23aec874df\">\n\nIn most cases the continuation of the fillet along smoothly connected faces is the intended behaviour. If this is not the case, the order of applying the fillets should be changed. Replicad does not offer the capability to suppress the tangential chaining. \n\nWhen we take the code of the example and uncomment the additional fillet construction, fillets with three different radii will be applied to the solid. When the order of the two last instruction is changed, the fillet fails with a \"kernel error\". \n\n``` javascript\n// Demonstration of tangent chain \nconst {draw} = replicad\n\nfunction main(){\n\nlet uShape = draw().line(40,0).customCorner(4).line(0,20)\n.customCorner(2).line(-8,0).customCorner(2)\n.line(0,-12).customCorner(2)\n.line(-24,0).line(0,12).line(-8,0).close()\n.sketchOnPlane(\"XY\").extrude(20)\n\nuShape = uShape.fillet(2,(e)=>e.inDirection(\"X\"))\n//uShape = uShape.fillet(1,(e)=>e.inDirection(\"Y\"))\n//uShape = uShape.fillet(3,(e)=>e.inDirection(\"Z\"))\n\nreturn uShape}\n```\n\nReplicad currently only offers circular filets with a constant radius for each assigned edge. On internal edges the fillet is concave (hollow), providing a fluid transition between the adjacent faces. \n\nIf you want to create a full round top on a part you should be aware that joining two fillets will mostly fail. A solution is to approximate the full rounding with a minimal straight part between the two fillets, for example by reducing the size of the fillet with a tolerance of 0.001.  \n\n\n>[!NOTE]\n> Users of OpenCascade, the 3D kernel used by Replicad, have noticed that fillets may often cause the program to fail. This may result in a broken geometry (which will be reported as errors in other 3D applications such as slicers for 3D printers), or in the crash of the program. The best approach reported is: \n\n> * if possible, try to add the fillets already in the sketching stage. The fillet mehtod for sketches is called `customCorner()` and is described in [Chapter 3](3.-Sketch). Alternatively you can use sketching commands such as `tangentArc` or `smoothSpline` to define arcs or smooth transitions instead of sharp corners;\n> * when the rounding cannot be applied in the sketching stage, try to add the fillets to a completed shape as late as possible;\n> * when a fillet fails, try to reduce the fillet size. OpenCascade cannot handle situations where a fillet completely removes an adjacent face. If you want to design such a geometry, try to find a different modelling approach to get the same result. \n> * inspect the shape closely after filleting to determine if there are faces missing. This is a clear indicator for socalled non-manifold geometry, i.e. geometry that does not fully enclose a volume. \n\n\n## 6.4 .chamfer()\n\nA chamfer is defined as a symmetrical sloped angle applied to a sharp edge. Just like a rounding it takes away the sharp edge that is unpleasant to the touch and prone to damage. Chamfers are also often used to make it easier to assemble parts. When the chamfer is applied to a 90 degree angle it results in two 135 degree angles. When a part needs to be coated or painted, a bevel is a better finishing than a chamfer as there are still sharp angles, even though they are less sharp. \n\n\n\n\n\n\n## 6.5 .shell() \n\nThe `.shell()` method creates a thin walled shape out of a solid, taking one or more faces away to provide an opening to the thin walled shape. The resulting shape is still a solid, as the walls are not infinitesimally thin as for a \"shell\" using the terminology as explained in [Chapter 2](2.-From-sketch-to-3D-part). \n\n\n\n\n\n\n## 6.6 makeOffset()\n\n\n\n## 6.7 addHolesInFace()\n\n\n\nThe transform functions require a 2D face or a 3D shape. As explained in Section 3, sketches can not be transformed. If you want to transform a sketch, use the `draw()` function. The generic instruction to transform a face or shape is: \n\n``` javascript\ntransformedShape = shape.\"transformCommand\"\n```  \n\nThe following transformations are offered by Replicad:\n\n| method                                               | description                                        |\n| -----------------------------------------------------|----------------------------------------------------|\n| .translate([dx,dy,dz])                               | Translate a part over distance dx,dy,dz along the respective axis\n| .translateX(dx)                                      | Translate a part along the x-axis only\n| .translateY(dy)                                      | Translate a part along the y-axis only\n| .translateZ(dz)                                      | Translate a part along the z-axis only\n| .rotate(angleDeg,axisOrigin[x,y,x],axisEnd[x,y,x])   | Rotate a part over the indicated degrees along an axis defined by two points \n| .scale(number)                                       | Scale the part equally in all directions\n| .mirror(\"YZ\",[-10,0])                                | Mirror the part in a given plane\n\n\n\n\n## 8.1 Overview of methods to combine solids\n\nReplicad offers a number of methods and functions to combine solids to create a new solid or compound shape. \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/booleans-icons.png\" width=\"500\"> \n\nThe table below provides a quick reference to the methods and functions. The sections of this chapter describe them in more detail. \n\n| method                           | description                                                      |\n| ---------------------------------|------------------------------------------------------------------|\n|`.cut(tool,{optimisation?})`     | cut the tool-shape from the shape, optional optimisation         |  \n|`{optimisation?`                |` {optimisation:\"none\" / \"commonFace\" / \"sameFace\"}`              |\n|`.fuse(otherShape,.. )`          | fuse the othershape with the shape.                              | \n|`.intersect(tool) `              | find the volume that is common to the two shapes considered      |\n|`compoundShapes(shapeArray[])`   | this function is identical to makeCompound                       |\n|`makeCompound(shapeArray[])`     | allows to combine an array of any type of shape into a single entity that can be displayed.|   \n\nThe boolean operators were already discussed in the section on sketching and drawing (see [Sketch](./3.-Sketch.md)). The methods used by Replicad (and therefore in the OpenCascade library) are fairly standard but sometimes have a different name in other programs. The following table lists some of these alternative names. \n\n| Method in Replicad               | Name in other applications                                      |\n|----------------------------------|-----------------------------------------------------------------|\n| `.cut()`                         | 'subtract' or 'difference'                                      | \n| `.fuse()`                        | `join` , `union` , `add` (add keeps all original geometry)      |               \n| `.intersect()`                   | `common`                                                        |   \n\n## 8.2 .cut()\n\n\n\n\n## 8.3 .fuse()\n\n\n\n\n## 8.4 .intersect()\n\n\n\n\n## 8.5 compoundShapes() or makeCompound\n\n\n\n\n<<<\n\n## 9.1 Define points based on directions and distances\n\n``` javascript\nfunction Polar(currentPoint,distance,angleDegToX)\n{\n    let newPoint = [];\n    let angleRad = angleDegToX * Math.PI/180;\n    newPoint[0]  = currentPoint[0] + distance * Math.cos(angleRad);\n    newPoint[1]  = currentPoint[1] + distance * Math.sin(angleRad);\n    return newPoint\n}\n\nfunction PolarX(currentPoint,xdistance,angleDegToX)\n{\n    let newPoint = [];\n    let angleRad = angleDegToX * Math.PI/180;\n    newPoint[0]  = currentPoint[0] + xdistance;\n    newPoint[1]  = currentPoint[1] + xdistance * Math.tan(angleRad);\n    return newPoint\n}\n\nfunction PolarY(currentPoint,ydistance,angleDegToX)\n{\n    let newPoint = [];\n    let angleRad = angleDegToX * Math.PI/180;\n    newPoint[0]  = currentPoint[0] + ydistance/Math.tan(angleRad);\n    newPoint[1]  = currentPoint[1] + ydistance;\n    return newPoint\n}\n``` \n\n## 9.2 Circles joined with tangent lines\n\nThis function can be used to draw to circle-arcs connected with tangent lines, as an outline for a lever or a droplet. The circle with `radius1` is centered on the origin, the second arc is centered along the x-axis at a distance called `distance`. \n\n\n![Creating a drop shape for a lever](https://github.com/raydeleu/ReplicadManual/blob/main/images/droplet1.png)\n\n``` javascript \nfunction dropView(radius1, radius2, distance)\n{\n    let sinus_angle = (radius1 - radius2) / distance\n    let angle = Math.asin(sinus_angle);\n\n    // points of outer contour of the lever\n    let p1 = [radius1 * Math.sin(angle), radius1 * Math.cos(angle)];\n    let p2 = [distance + radius2 * Math.sin(angle), radius2 * Math.cos(angle)];\n    let p3 = [distance + radius2, 0];\n    let p4 = [distance + radius2 * Math.sin(angle), - radius2 * Math.cos(angle)];\n    let p5 = [radius1 * Math.sin(angle), - radius1 * Math.cos(angle)];\n    let p6 = [- radius1, 0 ];\n\n    let dropDrawing = draw(p1)\n                    .lineTo(p2)\n                    .threePointsArcTo(p4,p3)\n                    .lineTo(p5)\n                    .threePointsArcTo(p1,p6)\n                    .close();\n    \n    return dropDrawing}\n```\n\n\n## Create a polar array \n\nMany CAD programs offer the function to create a polar array of shapes, for example adding holes in a circular pattern. The following script solves this (copied from https://replicad.xyz/docs/recipes/polar-array)\n\n``` javascript\nconst polarCopies = (shape, count, radius) => {\n  const base = shape.translate(0, radius);\n  const angle = 360 / count;\n\n  const copies = [];\n  for (let i = 0; i < count; i++) {\n    copies.push(base.clone().rotate(i * angle));\n  }\n  return copies;\n};\n```\n\nThe code only works properly if: \n\n* your original shape is centered at the origin [x,y] = [0,0]\n* the circular pattern is located around the origin \n\nThe script works for any shape and therefore both for 2D and 3D shapes. In the case of 3D, it will create the copies in the XY plane (as the default rotation is defined around the z-axis). \n\n\nThis section describes how to export geometric data, what file types are supported, what are possible pipelines to transfer information from Replicad to STEP to STL or OBJ format. Resolution of tesselation, difference between quality of tesselation produced by different softwares.  \n\n## 10.1 Exporting shapes\n\nApart from saving the javascript input file, Replicad offers three options to save your work for further modification or 3D printing. These options are: \n\n* Save the shapes in STL format\n* Save the shapes in STEP format\n* Save the shapes in JSON format\n\n<img src=\"https://github.com/raydeleu/ReplicadManual/assets/38007983/17f770fd-730a-470a-952c-a97035e82513\" width=\"500\">\n\nWhich option is best depends on the purpose of the export. Two scenario's will be discussed in the next sections.\n\n### 10.1.1 Exporting for 3D printing\n\nOne of the reasons you might be interested in modelling with Replicad is that you want to create objects with a 3D printer or CNC (computer numerical control) machining. Replicad is perfectly suited for this task as it allows to enter exact dimensions that can be altered slightly if it turns out that your design needs modification, for example because your 3D printer requires larger tolerances or cannot handle the printing overhangs. (An additional advantage is that modelling with a \"real\" CAD tool often result in less modelling errors such as non-manifold meshes, which are meshes that are not completely enclosing a volume. The concept of a 3D mesh will be discussed below). \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/assets/38007983/ee8d77f2-097a-47a0-90ed-f37ae58d7a03\" width=\"800\">\n\nIn the case of 3D printing you need a file that can be imported by the so-called slicing tool that you use. The most well-known slicing tools are Ultimaker Cura  (https://ultimaker.com/software/ultimaker-cura/) and Prusa Slicer (https://www.prusa3d.com/). These tools mostly require a model in a socalled polygonal format. A polygon is a small flat face, so in a polygonal model the shape is enclosed in little small faces. File formats for polygonal models are the Wavefront OBJ format and the STL (Stereo Lithography) format. (Wafefront was a 3D company, subsequently acquired by Alias which was then acquired by Autodesk). The following image shows the file formats accepted by Cura: \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/assets/38007983/da40e7fa-fa52-41dc-8773-8638dddc3e75\" width=\"300\">\n\nReplicad can export in the STL format. The STL format describes the model with a mesh of triangle-shaped polygons. It is therefore an approximation of the 3D shape and may be considered a \"lossy\" format: data is lost in the conversion towards STL and the original format cannot be recovered from this format. As said, to produce a polygonal model of a 3D shape, the shape has to be broken down into small faces. The granularity or resolution of these faces determines the deviation of the exported model from the accurate model in the BRep modelling tool such as Replicad. The larger the resolution, the smaller the difference between the accurate model and the approximate polygonal model. But a larger resolution will also result in longer export times and larger files. Whether the resolution of the produced file is visible in the end-product is determined both by the resolution of the data and the capabilities of the manufacturing tool. For example, a 3D printer always prints in small layers, so having a resolution much smaller than these layers makes no sense.  \n\nThe Workbench and Visualizer do not offer the option to adjust the resolution. The settings can be found hidden in de code of Replicad. So if you need to adjust the resolution of your model, you can install Replicad locally (see Appendix B) and adjust the source code. Look for the following piece of code in the source: \n\n```\nblobSTL({ tolerance = 1e-3, angularTolerance = 0.1 }\n```\nNote that the tolerance is already set quite low, resulting in accurate models for day-to-day use, especially for 3D printing. \n\nIf you are still not satisfied with the STL export produced by Replicad, you can take a detour using other software. In that case you would export your object in a STEP file (see next section), import the STEP file into another software and then perform the export to STL with that software. In a software like \n\n* Moi3D (https://moi3d.com/) you can adjust the number of faces that is produced for the STL export,\n* OnShape (https://onshape.com) offers four settings ranging from fine to coarse,\n* CascadeStudio (https://zalo.github.io/CascadeStudio/) allows to set the `MeshRes` from its interface.\n* SolidEdge (https://solidedge.siemens.com/en/solutions/users/hobbyists-and-makers/) allows to set the Conversion Tolerance and the Tolerance Units.  \n\n### 10.1.2 Exporting for further modification \n\nIt might be that you want to provide your 3D model to another person to enable him to adapt this model in her/his software of choice. In that case transferring the information in STEP format is preferred. STEP stands for \"Standard for the Exchange of Product Data\" and is a format defined in ISO 10303. It can describe a shape in terms of curves and faces. Additionally it can contain information on material, tolerances and colour of the object. The STEP format is the most appropriate format to transfer the model to other 3D design software as this file most accurately describes the shape.\n\nThe following image shows the import options for Moi3D ((https://moi3d.com/)\n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/moi_import.png\" width=\"750\"> \n\nWhen you import the shape into Moi3D you can see that no tesselation (break-up of the object into small faces) has occurred: \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/moi_import_step.png\" width=\"700\"> \n\nAnd here is the same shape after importing into OnShape: \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/import_step_onshape.png\" width=\"800\"> \n\nUsing the 3D programs mentioned above, you can export in many other formats, both accurate formats (STEP, IGES) and polygonal formats (STL, OBJ, WRL, Collada DAE). \n\nImporting a Replicad object into another software makes sense if not all intended modelling actions such as applying fillets are possible in Replicad. Another reason could be that your object is only a part in a larger assembly which is created in the other software. The following image shows an example where Solid Edge was used to apply some additional fillets that caused a \"kernel error\" in Replicad. The blue object was exported as a STEP file from Replicad, the green object has the additional fillets. A benefit of this approach is that you do not need to learn the other software completely but can restrict your knowledge to applying fillets or exporting in other formats. \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/slottedlever-render.jpg\" width=\"800\"> \n\nAs mentioned in the previous section, some of the programs that are discussed in this section allow to export the shape in a polygonal format and to determine the level of detail of these models. The following two images show the export of an object in OBJ and STL format using Moi3D. \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/moi_export_obj.png\" width=\"400\"> \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/moi_export_stl.png\" width=\"400\"> \n\nNotice that the OBJ format allows polygonal faces with more than 3 vertices, whereas the STL model consists completely of triangular faces. Moi3D is known for its nice algorithm for meshing objects, especially in the OBJ format. This is especially beneficial if you want to change the model in a polygonal modelling software such as Blender (https://www.blender.org). \n\n### 10.1.3 Exporting for visualization\n\nWhen you want to create a nice rendering of your object you can use both the accurate CAD format as a polygonal format such as STL. In most cases the object will be changed into a polygonal format anyhow by the rendering engine. This is even the case in the Replicad Visualizer and Workbench. Most rendering software uses algorithms to smooth surfaces. Therefore using a model with a very high resolution often makes no sense as it just increases the  size of the model files without any noticeable effect on the rendered result. The examples in this section were all created using the output from Replicad without any enhancement. \n\nIf you are prepared to use commercial software to create a visualization, Solid Edge is a very good choice. The software is available at no cost for \"makers and hobbyists\" at [solidedge.siemens.com](https://solidedge.siemens.com/en/solutions/users/hobbyists-and-makers/). The software can import the STEP files produced by Replicad and save these as a PAR file, a Parasolid part file. The software package of Solid Edge includes a restriced version of Keyshot (https://www.keyshot.com/) that can import the objects in PAR format and produce a nice rendering without much effort. Just select some materials, apply these to the objects, choose the type of lighting (product design, jewelry et cetera) and press \"render\". \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/keyshot-screenshot.png\" width=\"800\"> \n\nThe result is a realistic product rendering within less than an hour of work (note that if you do not use materials like glass, you can really get a result within a few minutes): \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/keyshot-replicad9.jpg\" width=\"800\"> \n\nA disadvantage of Solid Edge is that you can not use the free version for commercial activities and you never know when the offer to use this software freely ends. Furthermore this software can only be used on the Windows operating system. If you are using MacOS or Linux you would have to install a virtual machine with Windows to run this software. \n\nAn open source alternative that is available on most operating systems is Blender (https://www.blender.org). This software offers the same functionality, but is not easy to use. Things that make life easier, like material libraries and lighting setups, are available for Blender as well but in many cases require a small fee. You can find many of these libraries at https://blendermarket.com/categories/studio-lighting/browse. If you are willing to put in your own time and experiment a lot you can build everything for free. \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/blender-screenshot.png\" width=\"800\"> \n\n>[!NOTE]\n>The commercial license to the full package of Keyshot costs around 100 US dollar per month, lower cost plans are available at 39 USD per month. A low cost commercial license to Solid Edge costs around 140 US dollar per month.  This would mean spending a small amount on a material library or studio setup for Blender is still not as costly. \n\nThe more expensive programs like OnShape and Solid Edge can also create accurate drawings from a 3D part, which might be needed to transfer the design information to others. \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/blob/main/images/drawing_onshape_v2.png\" width=\"800\"> \n\n>[!NOTE]\n>You can also produce drawings with Replicad using the functions described in the documentation, see https://replicad.xyz/docs/examples/projections)\n\n\n\n\n\n\n<img src=\"https://github.com/raydeleu/ReplicadManual/assets/38007983/606b44ca-be24-4533-a0c8-76fd9d5a831b\" width =\"500\"> \n\nThe CAD assistant (https://www.opencascade.com/products/cad-assistant/) allows an export of the shape to polygon formats such as OBJ, WRL, STL but also a format  like IGES that contains all the detail of curves and arcs. \n\n\n## 10.2 Importing shapes\n\nThis section provides an explanation how to import geometric data, what types of information can be imported, how, what are the options to use the imported shapes for further modification. What are approaches to extract geometric information from other programs if the tools provided by Replicad make modelling tasks difficult.\n\n### 10.2.1 Importing 2D shapes\n\nReplicad currently offers no option to import 2D sketches. Yet this functionality could be practical. Think of the following cases: \n\n* You are given een 3D-view (side, front, top) of an object with dimensions that assume that you have a so-called constraint based modeller. A constraint based modeller, such as most visual 3D CAD programs, allow to enter the dimensions and relations between drawing segments to end up with a fully defined shape. Without this capability, finding the coordinates of these sketches often involves tedious geometric calculations. An alternative is to seek other ways to create the same shape, to measure the coordinates from the drawing or do some trial and error until the shape looks right. But you could also use one of the freely available tools to create the 2D sketch and import this sketch into Replicad. Examples of freely available tools that support constraint based modelling are `Freecad`  (https://www.freecad.org/), `Solvespace` ([[https://solvespace.com](https://solvespace.com/index.pl)) or `jSketcher` (https://github.com/xibyte/jsketcher).\n\n* It might be the case that you want to use a pattern or logo to embellish you 3D shape. The author of Replicad has implemented a basic functionality in a website called https://blingmything.sgenoud.com/ that contains this functionality. Unfortunately this functionality is (not yet) included in Replicad. \n\nOne option to import 2D shapes from other softwares is to analyze the files and extract the relevant coordinates. As an example take the shape shown in the image below. This shape consist of two arcs, one with radius 32 mm on the right and one with radius 20 on the left. According to the original drawing this shape is based on, the two arcs are connected with a third arc, but the radius of this arc is not given in the drawing. Using a constraint based drawing tool it turns out that by entering the dimensions and constraints given in the drawing, the shape is fully defined. In the example below the drawing at the left (or top) was created in `SolveSpace`, the drawing at the right in `FreeCad` (see above). \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/assets/38007983/34734cf8-00d8-4168-aef8-1ab47f3837d3\" width=\"450\">\n\n<img src=\"https://github.com/raydeleu/ReplicadManual/assets/38007983/9adb59d6-a7f9-428d-98d7-7687e6b6f4a1\" width=\"450\">\n\nSolveSpace supports the option to export the 2D view. Before exporting the shape you have to hide the construction lines (the green lines in the image) and the dimensions. The resulting SVG file then only contains the path of the shape. The SVG file is in fact a text file that can be opened in any text editor. The definition of the contour can be found by looking for the `path` statements. For the shape above the following path can be found in the SVG file: \n\n```\n<path d='\nM5.000 37.000\nL97.000,37.000\nA32.000,32.000 0 0,0 65.000,5.000\nA92.667,92.667 0 0,0 13.991,20.303\nA20.000,20.000 0 0,0 5.000,37.000 ' class='s1' />\n```\nFor the purpose of clarity each separate statement is shown on a separate line, but in the actual file the statements are all contained in a single line. The elements of the path are identified by single characters. The following table shows that the drawing functions defined by these characters are very similar to the drawing methods available in Replicad. \n\n| SVG path command                                      | Replicad command                                            |\n|-------------------------------------------------------|-------------------------------------------------------------|\n|`M x y`                                                |`.movePointerTo([x,y]) or draw([x,y]) `                      |\n|`m dx dy`                                              | no equivalent in Replicad other than starting new drawing   | \n|`L x,y  `                                              |`.lineTo([x,y])`                                             |\n|`l dx,dy`                                              |`.line(dx,dy)  `                                             | \n|`v y`                                                  |`.vLine(dy)`                                                 |\n|`h x `                                                 |`.hLine(dx)`                                                 |\n|`A rx,ry deg-rotation large-arc?,sweep-positive? x,y`  |`.ellipseTo([x,y],rx,ry,deg rotation, long_way?, counter?`   | \n|`C x1 y1 x2 y2 x y`                                    |`.cubicBezierCurveTo([x,y],p1_ctrl_start,p2_ctrl_end)`       |   \n|`Q controlX controlY endX endY `                       |`.quadraticBezierCurveTo([x,y],[x_ctrl,y_ctrl])`             |         \n|`q dx_control dy_control dx dy `                       |`.quadraticBezierCurve(dx,dy,dx_ctrl,dy_ctrl)`               |\n|`Z`                                                    |`.close()`                                                   |\n\n\nUsing this translation, the equivalent Replicad code is: \n\n```\nconst {draw}  = replicad\n\nfunction main()\n{\nlet contour = draw([5,37])\n.lineTo([97,37])\n.ellipseTo([65,5],32,32,0,false,false)\n.ellipseTo([13.991,20.303],92.667,92.667,0,false,false)\n.ellipseTo([5,37],20,20,0,false,false)\n.close()\n.sketchOnPlane(\"XY\")\n\nreturn contour}\n```\nThe resulting shape in Replicad is shown below. Note that it is drawn upside down and not at the origin, but this can easily be corrected with a rotation and a translation. \n\n<img src=\"https://github.com/raydeleu/ReplicadManual/assets/38007983/4598b4a9-7f49-49ba-9c8c-f3fc3a767491\" width=\"500\">\n\nIn FreeCad you can export the shape in Open CAD format (.oca). The format of this file is very straight forward as for each line two points are given and for each arc three points.  \n\n```\n#oca file generated from FreeCAD\n\n# edges\nL1=P(-92.0 1.2246467986490979e-15 0.0) P(0.0 0.0 0.0)\nC2=ARC P(0.0 0.0 0.0) P(-9.372583002030478 22.627416997969522 0.0) P(-32.0 32.0 0.0)\nC3=ARC P(-32.0 32.0 0.0) P(-58.627570729148005 28.091902430493363 0.0) P(-83.0091743119266 16.697247706422022 0.0)\nC4=ARC P(-83.0091743119266 16.697247706422022 0.0) P(-89.6094219984435 9.481996460700351 0.0) P(-92.0 1.2246467986490979e-15 0.0)\n# faces\n```\n\nThe approach to use another program to create a sketch does not always work, as in some cases the file will not contain arcs but pieces of straight lines that approximate a curve. In `SolveSpace` this seems the case when the drawing consists of splines or bezier curves instead of circular arcs. In that case converting the SVG is often not practical, as modifications of the resulting shapes with fillets - one of the modifications that cannot be performed in 3D by SolveSpace - often fails on these shapes. In that case you could still use the sketch and determine the location of starting and end points of arcs and curves in the software that you used to create the sketch. \n\n### 10.2.2 Importing 3D shapes\n\nReplicad offers two basic options to import 3D shapes, namely import of STEP files and import of STL files.\n\n```\nlet shapeFromSTEP = await importSTEP(blobFile)\nlet shapeFromSTL  = await importSTL(blobFile)\n```\n\nFirst it should be noted that these functions are preceded by the instruction `await`, as reading the large amount of data takes some time. To make this work within Replicad you have to define the `main` function as an asynchronous function, using the statement `async function main()` instead of the default `function main()`. \nFurthermore, both functions require a blob, a Binary Large Object, as its input. The main issue therefore is how to convert a file into a blob that can be fed to the import functions. \n\nOne of the simplest approaches is to convert the file into a `base64` format. Base64 is an encoding of binary code or ASCII text that reduces the number of allowable characters to a standard set. This way the contents of a file can be converted into a single long string of characters. (Without the `base64` encoding the string would contain spaces and special characters, making it difficult to represent it as a single string of characters). The string of characters is assigned to a variable, which is then in turn decoded and turned into a `blob`.   \n\nNote that on most computers (such as Linux, MacOS and Windows OS) you can encode a file using the terminal command: \n\n```\nopenssl base64 -A -in <infile> -out <outfile>\n// -A is needed to have a single large string without new lines\n```\nThe complete contents of the resulting file then have to be entered into the Replicad input file, for example using a statement like:\n\n``` javascript\nlet stepFile = \" [complete string of characters from base64 file] \"\n```\n\nThe resulting string can be quite large, as due to the encoding with less characters the size increases with 33%. The next example demonstrates how this works. The code also demonstrates that if everything goes well, the resulting shape can be modified like any other shape. However, if your inputfile contains multiple shapes this might not work.\n\n``` javascript\nlet {importSTEP} = replicad  \n\nasync function main()  \n{  \n\nlet stepFile = \"SVNPLTEwMzAzLTIxOwpIRUFERVI7CkZJTEVfREVTQ1JJUFRJT04oKCdPcGVuIENBU0NBREUgTW9kZWwnKSwnMjsxJyk7CkZJTEVfTkFNRSgnT3BlbiBDQVNDQURFIFNoYXBlIE1vZGVsJywnMjAyMy0xMS0wN1QyMzo1MDoyMycsKCdBdXRob3InKSwoCiAgICAnT3BlbiBDQVNDQURFJyksJ09wZW4gQ0FTQ0FERSBTVEVQIHByb2Nlc3NvciA3LjYnLCdPcGVuIENBU0NBREUgNy42JwogICwnVW5rbm93bicpOwpGSUxFX1NDSEVNQSgoCidBUDI0Ml9NQU5BR0VEX01PREVMX0JBU0VEXzNEX0VOR0lORUVSSU5HX01JTV9MRi4gezEgMCAxMDMwMyA0NDIgMSAxIDQgCn0nKSk7CkVORFNFQzsKREFUQTsKIzEgPSBBUFBMSUNBVElPTl9QUk9UT0NPTF9ERUZJTklUSU9OKCdpbnRlcm5hdGlvbmFsIHN0YW5kYXJkJywKICAnYXAyNDJfbWFuYWdlZF9tb2RlbF9iYXNlZF8zZF9lbmdpbmVlcmluZycsMjAxMywjMik7CiMyID0gQVBQTElDQVRJT05fQ09OVEVYVCgnTWFuYWdlZCBtb2RlbCBiYXNlZCAzZCBlbmdpbmVlcmluZycpOwojMyA9IFNIQVBFX0RFRklOSVRJT05fUkVQUkVTRU5UQVRJT04oIzQsIzEwKTsKIzQgPSBQUk9EVUNUX0RFRklOSVRJT05fU0hBUEUoJycsJycsIzUpOwojNSA9IFBST0RVQ1RfREVGSU5JVElPTignZGVzaWduJywnJywjNiwjOSk7CiM2ID0gUFJPRFVDVF9ERUZJTklUSU9OX0ZPUk1BVElPTignJywnJywjNyk7CiM3ID0gUFJPRFVDVCgnT3BlbiBDQVNDQURFIFNURVAgdHJhbnNsYXRvciA3LjYgMicsCiAgJ09wZW4gQ0FTQ0FERSBTVEVQIHRyYW5zbGF0b3IgNy42IDInLCcnLCgjOCkpOwojOCA9IFBST0RVQ1RfQ09OVEVYVCgnJywjMiwnbWVjaGFuaWNhbCcpOwojOSA9IFBST0RVQ1RfREVGSU5JVElPTl9DT05URVhUKCdwYXJ0IGRlZmluaXRpb24nLCMyLCdkZXNpZ24nKTsKIzEwID0gQURWQU5DRURfQlJFUF9TSEFQRV9SRVBSRVNFTlRBVElPTignJywoIzExLCMxNSksIzQzNyk7CiMxMSA9IEFYSVMyX1BMQUNFTUVOVF8zRCgnJywjMTIsIzEzLCMxNCk7CiMxMiA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sMC4sMC4pKTsKIzEzID0gRElSRUNUSU9OKCcnLCgwLiwwLiwxLikpOwojMTQgPSBESVJFQ1RJT04oJycsKDEuLDAuLC0wLikpOwojMTUgPSBNQU5JRk9MRF9TT0xJRF9CUkVQKCcnLCMxNik7CiMxNiA9IENMT1NFRF9TSEVMTCgnJywoIzE3LCMxMzcsIzIxNiwjMjk5LCMzNzQsIzQyMSwjNDI5KSk7CiMxNyA9IEFEVkFOQ0VEX0ZBQ0UoJycsKCMxOCksIzMyLC5GLik7CiMxOCA9IEZBQ0VfQk9VTkQoJycsIzE5LC5GLik7CiMxOSA9IEVER0VfTE9PUCgnJywoIzIwLCM1NSwjODMsIzExMSkpOwojMjAgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMjEsLlQuKTsKIzIxID0gRURHRV9DVVJWRSgnJywjMjIsIzI0LCMyNiwuVC4pOwojMjIgPSBWRVJURVhfUE9JTlQoJycsIzIzKTsKIzIzID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwwLiwwLikpOwojMjQgPSBWRVJURVhfUE9JTlQoJycsIzI1KTsKIzI1ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwwLiwyMC4pKTsKIzI2ID0gU1VSRkFDRV9DVVJWRSgnJywjMjcsKCMzMSwjNDMpLC5QQ1VSVkVfUzEuKTsKIzI3ID0gTElORSgnJywjMjgsIzI5KTsKIzI4ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwwLiwwLikpOwojMjkgPSBWRUNUT1IoJycsIzMwLDEuKTsKIzMwID0gRElSRUNUSU9OKCcnLCgwLiwwLiwxLikpOwojMzEgPSBQQ1VSVkUoJycsIzMyLCMzNyk7CiMzMiA9IFBMQU5FKCcnLCMzMyk7CiMzMyA9IEFYSVMyX1BMQUNFTUVOVF8zRCgnJywjMzQsIzM1LCMzNik7CiMzNCA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sMC4sMC4pKTsKIzM1ID0gRElSRUNUSU9OKCcnLCgwLiwxLiwwLikpOwojMzYgPSBESVJFQ1RJT04oJycsKDEuLDAuLDAuKSk7CiMzNyA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzM4KSwjNDIpOwojMzggPSBMSU5FKCcnLCMzOSwjNDApOwojMzkgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDAuKSk7CiM0MCA9IFZFQ1RPUignJywjNDEsMS4pOwojNDEgPSBESVJFQ1RJT04oJycsKDAuLC0xLikpOwojNDIgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiM0MyA9IFBDVVJWRSgnJywjNDQsIzQ5KTsKIzQ0ID0gUExBTkUoJycsIzQ1KTsKIzQ1ID0gQVhJUzJfUExBQ0VNRU5UXzNEKCcnLCM0NiwjNDcsIzQ4KTsKIzQ2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiw0MC4sMC4pKTsKIzQ3ID0gRElSRUNUSU9OKCcnLCgxLiwwLiwtMC4pKTsKIzQ4ID0gRElSRUNUSU9OKCcnLCgwLiwtMS4sMC4pKTsKIzQ5ID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjNTApLCM1NCk7CiM1MCA9IExJTkUoJycsIzUxLCM1Mik7CiM1MSA9IENBUlRFU0lBTl9QT0lOVCgnJywoNDAuLDAuKSk7CiM1MiA9IFZFQ1RPUignJywjNTMsMS4pOwojNTMgPSBESVJFQ1RJT04oJycsKDAuLC0xLikpOwojNTQgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiM1NSA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCM1NiwuVC4pOwojNTYgPSBFREdFX0NVUlZFKCcnLCMyNCwjNTcsIzU5LC5ULik7CiM1NyA9IFZFUlRFWF9QT0lOVCgnJywjNTgpOwojNTggPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sMC4sMjAuKSk7CiM1OSA9IFNVUkZBQ0VfQ1VSVkUoJycsIzYwLCgjNjQsIzcxKSwuUENVUlZFX1MxLik7CiM2MCA9IExJTkUoJycsIzYxLCM2Mik7CiM2MSA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sMC4sMjAuKSk7CiM2MiA9IFZFQ1RPUignJywjNjMsMS4pOwojNjMgPSBESVJFQ1RJT04oJycsKDEuLDAuLDAuKSk7CiM2NCA9IFBDVVJWRSgnJywjMzIsIzY1KTsKIzY1ID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjNjYpLCM3MCk7CiM2NiA9IExJTkUoJycsIzY3LCM2OCk7CiM2NyA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sLTIwLikpOwojNjggPSBWRUNUT1IoJycsIzY5LDEuKTsKIzY5ID0gRElSRUNUSU9OKCcnLCgxLiwwLikpOwojNzAgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiM3MSA9IFBDVVJWRSgnJywjNzIsIzc3KTsKIzcyID0gUExBTkUoJycsIzczKTsKIzczID0gQVhJUzJfUExBQ0VNRU5UXzNEKCcnLCM3NCwjNzUsIzc2KTsKIzc0ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg0OS44NDM4NjA5MjExMTksMjUuODE3NTgzMzU5MjYyLDIwLikpOwojNzUgPSBESVJFQ1RJT04oJycsKDAuLDAuLDEuKSk7CiM3NiA9IERJUkVDVElPTignJywoMS4sMC4sLTAuKSk7CiM3NyA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzc4KSwjODIpOwojNzggPSBMSU5FKCcnLCM3OSwjODApOwojNzkgPSBDQVJURVNJQU5fUE9JTlQoJycsKC00OS44NDM4NjA5MjExMSwtMjUuODE3NTgzMzU5MjYpKTsKIzgwID0gVkVDVE9SKCcnLCM4MSwxLik7CiM4MSA9IERJUkVDVElPTignJywoMS4sMC4pKTsKIzgyID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojODMgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjODQsLkYuKTsKIzg0ID0gRURHRV9DVVJWRSgnJywjODUsIzU3LCM4NywuVC4pOwojODUgPSBWRVJURVhfUE9JTlQoJycsIzg2KTsKIzg2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgxMDAuLDAuLDAuKSk7CiM4NyA9IFNVUkZBQ0VfQ1VSVkUoJycsIzg4LCgjOTIsIzk5KSwuUENVUlZFX1MxLik7CiM4OCA9IExJTkUoJycsIzg5LCM5MCk7CiM4OSA9IENBUlRFU0lBTl9QT0lOVCgnJywoMTAwLiwwLiwwLikpOwojOTAgPSBWRUNUT1IoJycsIzkxLDEuKTsKIzkxID0gRElSRUNUSU9OKCcnLCgwLiwwLiwxLikpOwojOTIgPSBQQ1VSVkUoJycsIzMyLCM5Myk7CiM5MyA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzk0KSwjOTgpOwojOTQgPSBMSU5FKCcnLCM5NSwjOTYpOwojOTUgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sMC4pKTsKIzk2ID0gVkVDVE9SKCcnLCM5NywxLik7CiM5NyA9IERJUkVDVElPTignJywoMC4sLTEuKSk7CiM5OCA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzk5ID0gUENVUlZFKCcnLCMxMDAsIzEwNSk7CiMxMDAgPSBQTEFORSgnJywjMTAxKTsKIzEwMSA9IEFYSVMyX1BMQUNFTUVOVF8zRCgnJywjMTAyLCMxMDMsIzEwNCk7CiMxMDIgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sMC4sMC4pKTsKIzEwMyA9IERJUkVDVElPTignJywoLTEuLDAuLDAuKSk7CiMxMDQgPSBESVJFQ1RJT04oJycsKDAuLDEuLDAuKSk7CiMxMDUgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMxMDYpLCMxMTApOwojMTA2ID0gTElORSgnJywjMTA3LCMxMDgpOwojMTA3ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwwLikpOwojMTA4ID0gVkVDVE9SKCcnLCMxMDksMS4pOwojMTA5ID0gRElSRUNUSU9OKCcnLCgwLiwtMS4pKTsKIzExMCA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzExMSA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMxMTIsLkYuKTsKIzExMiA9IEVER0VfQ1VSVkUoJycsIzIyLCM4NSwjMTEzLC5ULik7CiMxMTMgPSBTVVJGQUNFX0NVUlZFKCcnLCMxMTQsKCMxMTgsIzEyNSksLlBDVVJWRV9TMS4pOwojMTE0ID0gTElORSgnJywjMTE1LCMxMTYpOwojMTE1ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwwLiwwLikpOwojMTE2ID0gVkVDVE9SKCcnLCMxMTcsMS4pOwojMTE3ID0gRElSRUNUSU9OKCcnLCgxLiwwLiwwLikpOwojMTE4ID0gUENVUlZFKCcnLCMzMiwjMTE5KTsKIzExOSA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzEyMCksIzEyNCk7CiMxMjAgPSBMSU5FKCcnLCMxMjEsIzEyMik7CiMxMjEgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDAuKSk7CiMxMjIgPSBWRUNUT1IoJycsIzEyMywxLik7CiMxMjMgPSBESVJFQ1RJT04oJycsKDEuLDAuKSk7CiMxMjQgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMxMjUgPSBQQ1VSVkUoJycsIzEyNiwjMTMxKTsKIzEyNiA9IFBMQU5FKCcnLCMxMjcpOwojMTI3ID0gQVhJUzJfUExBQ0VNRU5UXzNEKCcnLCMxMjgsIzEyOSwjMTMwKTsKIzEyOCA9IENBUlRFU0lBTl9QT0lOVCgnJywoNDkuODQzODYwOTIxMTE5LDI1LjgxNzU4MzM1OTI2MiwwLikpOwojMTI5ID0gRElSRUNUSU9OKCcnLCgwLiwwLiwxLikpOwojMTMwID0gRElSRUNUSU9OKCcnLCgxLiwwLiwtMC4pKTsKIzEzMSA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzEzMiksIzEzNik7CiMxMzIgPSBMSU5FKCcnLCMxMzMsIzEzNCk7CiMxMzMgPSBDQVJURVNJQU5fUE9JTlQoJycsKC00OS44NDM4NjA5MjExMSwtMjUuODE3NTgzMzU5MjYpKTsKIzEzNCA9IFZFQ1RPUignJywjMTM1LDEuKTsKIzEzNSA9IERJUkVDVElPTignJywoMS4sMC4pKTsKIzEzNiA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzEzNyA9IEFEVkFOQ0VEX0ZBQ0UoJycsKCMxMzgpLCMxMDAsLkYuKTsKIzEzOCA9IEZBQ0VfQk9VTkQoJycsIzEzOSwuRi4pOwojMTM5ID0gRURHRV9MT09QKCcnLCgjMTQwLCMxNDEsIzE2NCwjMTk1KSk7CiMxNDAgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjODQsLlQuKTsKIzE0MSA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMxNDIsLlQuKTsKIzE0MiA9IEVER0VfQ1VSVkUoJycsIzU3LCMxNDMsIzE0NSwuVC4pOwojMTQzID0gVkVSVEVYX1BPSU5UKCcnLCMxNDQpOwojMTQ0ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgxMDAuLDQwLiwyMC4pKTsKIzE0NSA9IFNVUkZBQ0VfQ1VSVkUoJycsIzE0NiwoIzE1MCwjMTU3KSwuUENVUlZFX1MxLik7CiMxNDYgPSBMSU5FKCcnLCMxNDcsIzE0OCk7CiMxNDcgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sMC4sMjAuKSk7CiMxNDggPSBWRUNUT1IoJycsIzE0OSwxLik7CiMxNDkgPSBESVJFQ1RJT04oJycsKDAuLDEuLDAuKSk7CiMxNTAgPSBQQ1VSVkUoJycsIzEwMCwjMTUxKTsKIzE1MSA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzE1MiksIzE1Nik7CiMxNTIgPSBMSU5FKCcnLCMxNTMsIzE1NCk7CiMxNTMgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLC0yMC4pKTsKIzE1NCA9IFZFQ1RPUignJywjMTU1LDEuKTsKIzE1NSA9IERJUkVDVElPTignJywoMS4sMC4pKTsKIzE1NiA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzE1NyA9IFBDVVJWRSgnJywjNzIsIzE1OCk7CiMxNTggPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMxNTkpLCMxNjMpOwojMTU5ID0gTElORSgnJywjMTYwLCMxNjEpOwojMTYwID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg1MC4xNTYxMzkwNzg4ODEsLTI1LjgxNzU4MzM1OTI2KSk7CiMxNjEgPSBWRUNUT1IoJycsIzE2MiwxLik7CiMxNjIgPSBESVJFQ1RJT04oJycsKDAuLDEuKSk7CiMxNjMgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMxNjQgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMTY1LC5GLik7CiMxNjUgPSBFREdFX0NVUlZFKCcnLCMxNjYsIzE0MywjMTY4LC5ULik7CiMxNjYgPSBWRVJURVhfUE9JTlQoJycsIzE2Nyk7CiMxNjcgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sNDAuLDAuKSk7CiMxNjggPSBTVVJGQUNFX0NVUlZFKCcnLCMxNjksKCMxNzMsIzE4MCksLlBDVVJWRV9TMS4pOwojMTY5ID0gTElORSgnJywjMTcwLCMxNzEpOwojMTcwID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgxMDAuLDQwLiwwLikpOwojMTcxID0gVkVDVE9SKCcnLCMxNzIsMS4pOwojMTcyID0gRElSRUNUSU9OKCcnLCgwLiwwLiwxLikpOwojMTczID0gUENVUlZFKCcnLCMxMDAsIzE3NCk7CiMxNzQgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMxNzUpLCMxNzkpOwojMTc1ID0gTElORSgnJywjMTc2LCMxNzcpOwojMTc2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg0MC4sMC4pKTsKIzE3NyA9IFZFQ1RPUignJywjMTc4LDEuKTsKIzE3OCA9IERJUkVDVElPTignJywoMC4sLTEuKSk7CiMxNzkgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMxODAgPSBQQ1VSVkUoJycsIzE4MSwjMTg5KTsKIzE4MSA9IFNVUkZBQ0VfT0ZfTElORUFSX0VYVFJVU0lPTignJywjMTgyLCMxODcpOwojMTgyID0gQl9TUExJTkVfQ1VSVkVfV0lUSF9LTk9UUygnJywzLCgjMTgzLCMxODQsIzE4NSwjMTg2KSwKICAuVU5TUEVDSUZJRUQuLC5GLiwuRi4sKDQsNCksKDAuLDEuKSwuUElFQ0VXSVNFX0JFWklFUl9LTk9UUy4pOwojMTgzID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgxMDAuLDQwLiwwLikpOwojMTg0ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg5Mi4wOTQzMDU4NDk1NzksNDcuOTA1Njk0MTUwNDIxLDAuKSk7CiMxODUgPSBDQVJURVNJQU5fUE9JTlQoJycsKDcxLjE4MDMzOTg4NzQ5OSw2MC4sMC4pKTsKIzE4NiA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwwLikpOwojMTg3ID0gVkVDVE9SKCcnLCMxODgsMS4pOwojMTg4ID0gRElSRUNUSU9OKCcnLCgtMC4sLTAuLC0xLikpOwojMTg5ID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMTkwKSwjMTk0KTsKIzE5MCA9IExJTkUoJycsIzE5MSwjMTkyKTsKIzE5MSA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sMC4pKTsKIzE5MiA9IFZFQ1RPUignJywjMTkzLDEuKTsKIzE5MyA9IERJUkVDVElPTignJywoMC4sLTEuKSk7CiMxOTQgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMxOTUgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMTk2LC5GLik7CiMxOTYgPSBFREdFX0NVUlZFKCcnLCM4NSwjMTY2LCMxOTcsLlQuKTsKIzE5NyA9IFNVUkZBQ0VfQ1VSVkUoJycsIzE5OCwoIzIwMiwjMjA5KSwuUENVUlZFX1MxLik7CiMxOTggPSBMSU5FKCcnLCMxOTksIzIwMCk7CiMxOTkgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sMC4sMC4pKTsKIzIwMCA9IFZFQ1RPUignJywjMjAxLDEuKTsKIzIwMSA9IERJUkVDVElPTignJywoMC4sMS4sMC4pKTsKIzIwMiA9IFBDVVJWRSgnJywjMTAwLCMyMDMpOwojMjAzID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMjA0KSwjMjA4KTsKIzIwNCA9IExJTkUoJycsIzIwNSwjMjA2KTsKIzIwNSA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sMC4pKTsKIzIwNiA9IFZFQ1RPUignJywjMjA3LDEuKTsKIzIwNyA9IERJUkVDVElPTignJywoMS4sMC4pKTsKIzIwOCA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzIwOSA9IFBDVVJWRSgnJywjMTI2LCMyMTApOwojMjEwID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMjExKSwjMjE1KTsKIzIxMSA9IExJTkUoJycsIzIxMiwjMjEzKTsKIzIxMiA9IENBUlRFU0lBTl9QT0lOVCgnJywoNTAuMTU2MTM5MDc4ODgxLC0yNS44MTc1ODMzNTkyNikpOwojMjEzID0gVkVDVE9SKCcnLCMyMTQsMS4pOwojMjE0ID0gRElSRUNUSU9OKCcnLCgwLiwxLikpOwojMjE1ID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojMjE2ID0gQURWQU5DRURfRkFDRSgnJywoIzIxNyksIzE4MSwuRi4pOwojMjE3ID0gRkFDRV9CT1VORCgnJywjMjE4LC5GLik7CiMyMTggPSBFREdFX0xPT1AoJycsKCMyMTksIzIyMCwjMjQ1LCMyNzYpKTsKIzIxOSA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMxNjUsLlQuKTsKIzIyMCA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMyMjEsLlQuKTsKIzIyMSA9IEVER0VfQ1VSVkUoJycsIzE0MywjMjIyLCMyMjQsLlQuKTsKIzIyMiA9IFZFUlRFWF9QT0lOVCgnJywjMjIzKTsKIzIyMyA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwyMC4pKTsKIzIyNCA9IFNVUkZBQ0VfQ1VSVkUoJycsIzIyNSwoIzIzMCwjMjM3KSwuUENVUlZFX1MxLik7CiMyMjUgPSBCX1NQTElORV9DVVJWRV9XSVRIX0tOT1RTKCcnLDMsKCMyMjYsIzIyNywjMjI4LCMyMjkpLAogIC5VTlNQRUNJRklFRC4sLkYuLC5GLiwoNCw0KSwoMC4sMS4pLC5QSUVDRVdJU0VfQkVaSUVSX0tOT1RTLik7CiMyMjYgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwMC4sNDAuLDIwLikpOwojMjI3ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg5Mi4wOTQzMDU4NDk1NzksNDcuOTA1Njk0MTUwNDIxLDIwLikpOwojMjI4ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg3MS4xODAzMzk4ODc0OTksNjAuLDIwLikpOwojMjI5ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg2MC4sNjAuLDIwLikpOwojMjMwID0gUENVUlZFKCcnLCMxODEsIzIzMSk7CiMyMzEgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMyMzIpLCMyMzYpOwojMjMyID0gTElORSgnJywjMjMzLCMyMzQpOwojMjMzID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwtMjAuKSk7CiMyMzQgPSBWRUNUT1IoJycsIzIzNSwxLik7CiMyMzUgPSBESVJFQ1RJT04oJycsKDEuLDAuKSk7CiMyMzYgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMyMzcgPSBQQ1VSVkUoJycsIzcyLCMyMzgpOwojMjM4ID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMjM5KSwjMjQ0KTsKIzIzOSA9IEJfU1BMSU5FX0NVUlZFX1dJVEhfS05PVFMoJycsMywoIzI0MCwjMjQxLCMyNDIsIzI0MyksCiAgLlVOU1BFQ0lGSUVELiwuRi4sLkYuLCg0LDQpLCgwLiwxLiksLlBJRUNFV0lTRV9CRVpJRVJfS05PVFMuKTsKIzI0MCA9IENBUlRFU0lBTl9QT0lOVCgnJywoNTAuMTU2MTM5MDc4ODgxLDE0LjE4MjQxNjY0MDczOCkpOwojMjQxID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg0Mi4yNTA0NDQ5Mjg0NiwyMi4wODgxMTA3OTExNTkpKTsKIzI0MiA9IENBUlRFU0lBTl9QT0lOVCgnJywoMjEuMzM2NDc4OTY2MzgsMzQuMTgyNDE2NjQwNzM4KSk7CiMyNDMgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwLjE1NjEzOTA3ODg4MSwzNC4xODI0MTY2NDA3MzgpKTsKIzI0NCA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzI0NSA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMyNDYsLkYuKTsKIzI0NiA9IEVER0VfQ1VSVkUoJycsIzI0NywjMjIyLCMyNDksLlQuKTsKIzI0NyA9IFZFUlRFWF9QT0lOVCgnJywjMjQ4KTsKIzI0OCA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwwLikpOwojMjQ5ID0gU1VSRkFDRV9DVVJWRSgnJywjMjUwLCgjMjU0LCMyNjEpLC5QQ1VSVkVfUzEuKTsKIzI1MCA9IExJTkUoJycsIzI1MSwjMjUyKTsKIzI1MSA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwwLikpOwojMjUyID0gVkVDVE9SKCcnLCMyNTMsMS4pOwojMjUzID0gRElSRUNUSU9OKCcnLCgwLiwwLiwxLikpOwojMjU0ID0gUENVUlZFKCcnLCMxODEsIzI1NSk7CiMyNTUgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMyNTYpLCMyNjApOwojMjU2ID0gTElORSgnJywjMjU3LCMyNTgpOwojMjU3ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgxLiwwLikpOwojMjU4ID0gVkVDVE9SKCcnLCMyNTksMS4pOwojMjU5ID0gRElSRUNUSU9OKCcnLCgwLiwtMS4pKTsKIzI2MCA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzI2MSA9IFBDVVJWRSgnJywjMjYyLCMyNzApOwojMjYyID0gU1VSRkFDRV9PRl9MSU5FQVJfRVhUUlVTSU9OKCcnLCMyNjMsIzI2OCk7CiMyNjMgPSBCX1NQTElORV9DVVJWRV9XSVRIX0tOT1RTKCcnLDMsKCMyNjQsIzI2NSwjMjY2LCMyNjcpLAogIC5VTlNQRUNJRklFRC4sLkYuLC5GLiwoNCw0KSwoMC4sMS4pLC5QSUVDRVdJU0VfQkVaSUVSX0tOT1RTLik7CiMyNjQgPSBDQVJURVNJQU5fUE9JTlQoJycsKDYwLiw2MC4sMC4pKTsKIzI2NSA9IENBUlRFU0lBTl9QT0lOVCgnJywoNDQuMTg4NjExNjk5MTU4LDYwLiwwLikpOwojMjY2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgyLjkwNDUwNDkxMDkwNUUtMTUsNTUuODExMzg4MzAwODQyLDAuKSk7CiMyNjcgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDQwLiwwLikpOwojMjY4ID0gVkVDVE9SKCcnLCMyNjksMS4pOwojMjY5ID0gRElSRUNUSU9OKCcnLCgtMC4sLTAuLC0xLikpOwojMjcwID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMjcxKSwjMjc1KTsKIzI3MSA9IExJTkUoJycsIzI3MiwjMjczKTsKIzI3MiA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sMC4pKTsKIzI3MyA9IFZFQ1RPUignJywjMjc0LDEuKTsKIzI3NCA9IERJUkVDVElPTignJywoMC4sLTEuKSk7CiMyNzUgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMyNzYgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMjc3LC5GLik7CiMyNzcgPSBFREdFX0NVUlZFKCcnLCMxNjYsIzI0NywjMjc4LC5ULik7CiMyNzggPSBTVVJGQUNFX0NVUlZFKCcnLCMyNzksKCMyODQsIzI5MSksLlBDVVJWRV9TMS4pOwojMjc5ID0gQl9TUExJTkVfQ1VSVkVfV0lUSF9LTk9UUygnJywzLCgjMjgwLCMyODEsIzI4MiwjMjgzKSwKICAuVU5TUEVDSUZJRUQuLC5GLiwuRi4sKDQsNCksKDAuLDEuKSwuUElFQ0VXSVNFX0JFWklFUl9LTk9UUy4pOwojMjgwID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgxMDAuLDQwLiwwLikpOwojMjgxID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg5Mi4wOTQzMDU4NDk1NzksNDcuOTA1Njk0MTUwNDIxLDAuKSk7CiMyODIgPSBDQVJURVNJQU5fUE9JTlQoJycsKDcxLjE4MDMzOTg4NzQ5OSw2MC4sMC4pKTsKIzI4MyA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwwLikpOwojMjg0ID0gUENVUlZFKCcnLCMxODEsIzI4NSk7CiMyODUgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMyODYpLCMyOTApOwojMjg2ID0gTElORSgnJywjMjg3LCMyODgpOwojMjg3ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwwLikpOwojMjg4ID0gVkVDVE9SKCcnLCMyODksMS4pOwojMjg5ID0gRElSRUNUSU9OKCcnLCgxLiwwLikpOwojMjkwID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojMjkxID0gUENVUlZFKCcnLCMxMjYsIzI5Mik7CiMyOTIgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMyOTMpLCMyOTgpOwojMjkzID0gQl9TUExJTkVfQ1VSVkVfV0lUSF9LTk9UUygnJywzLCgjMjk0LCMyOTUsIzI5NiwjMjk3KSwKICAuVU5TUEVDSUZJRUQuLC5GLiwuRi4sKDQsNCksKDAuLDEuKSwuUElFQ0VXSVNFX0JFWklFUl9LTk9UUy4pOwojMjk0ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg1MC4xNTYxMzkwNzg4ODEsMTQuMTgyNDE2NjQwNzM4KSk7CiMyOTUgPSBDQVJURVNJQU5fUE9JTlQoJycsKDQyLjI1MDQ0NDkyODQ2LDIyLjA4ODExMDc5MTE1OSkpOwojMjk2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgyMS4zMzY0Nzg5NjYzOCwzNC4xODI0MTY2NDA3MzgpKTsKIzI5NyA9IENBUlRFU0lBTl9QT0lOVCgnJywoMTAuMTU2MTM5MDc4ODgxLDM0LjE4MjQxNjY0MDczOCkpOwojMjk4ID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojMjk5ID0gQURWQU5DRURfRkFDRSgnJywoIzMwMCksIzI2MiwuRi4pOwojMzAwID0gRkFDRV9CT1VORCgnJywjMzAxLC5GLik7CiMzMDEgPSBFREdFX0xPT1AoJycsKCMzMDIsIzMwMywjMzI4LCMzNTEpKTsKIzMwMiA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMyNDYsLlQuKTsKIzMwMyA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMzMDQsLlQuKTsKIzMwNCA9IEVER0VfQ1VSVkUoJycsIzIyMiwjMzA1LCMzMDcsLlQuKTsKIzMwNSA9IFZFUlRFWF9QT0lOVCgnJywjMzA2KTsKIzMwNiA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sNDAuLDIwLikpOwojMzA3ID0gU1VSRkFDRV9DVVJWRSgnJywjMzA4LCgjMzEzLCMzMjApLC5QQ1VSVkVfUzEuKTsKIzMwOCA9IEJfU1BMSU5FX0NVUlZFX1dJVEhfS05PVFMoJycsMywoIzMwOSwjMzEwLCMzMTEsIzMxMiksCiAgLlVOU1BFQ0lGSUVELiwuRi4sLkYuLCg0LDQpLCgwLiwxLiksLlBJRUNFV0lTRV9CRVpJRVJfS05PVFMuKTsKIzMwOSA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwyMC4pKTsKIzMxMCA9IENBUlRFU0lBTl9QT0lOVCgnJywoNDQuMTg4NjExNjk5MTU4LDYwLiwyMC4pKTsKIzMxMSA9IENBUlRFU0lBTl9QT0lOVCgnJywoMi45MDQ1MDQ5MTA5MDVFLTE1LDU1LjgxMTM4ODMwMDg0MiwyMC4pKTsKIzMxMiA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sNDAuLDIwLikpOwojMzEzID0gUENVUlZFKCcnLCMyNjIsIzMxNCk7CiMzMTQgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMzMTUpLCMzMTkpOwojMzE1ID0gTElORSgnJywjMzE2LCMzMTcpOwojMzE2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwtMjAuKSk7CiMzMTcgPSBWRUNUT1IoJycsIzMxOCwxLik7CiMzMTggPSBESVJFQ1RJT04oJycsKDEuLDAuKSk7CiMzMTkgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMzMjAgPSBQQ1VSVkUoJycsIzcyLCMzMjEpOwojMzIxID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMzIyKSwjMzI3KTsKIzMyMiA9IEJfU1BMSU5FX0NVUlZFX1dJVEhfS05PVFMoJycsMywoIzMyMywjMzI0LCMzMjUsIzMyNiksCiAgLlVOU1BFQ0lGSUVELiwuRi4sLkYuLCg0LDQpLCgwLiwxLiksLlBJRUNFV0lTRV9CRVpJRVJfS05PVFMuKTsKIzMyMyA9IENBUlRFU0lBTl9QT0lOVCgnJywoMTAuMTU2MTM5MDc4ODgxLDM0LjE4MjQxNjY0MDczOCkpOwojMzI0ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgtNS42NTUyNDkyMjE5NjEsMzQuMTgyNDE2NjQwNzM4KSk7CiMzMjUgPSBDQVJURVNJQU5fUE9JTlQoJycsKC00OS44NDM4NjA5MjExMSwyOS45OTM4MDQ5NDE1OCkpOwojMzI2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgtNDkuODQzODYwOTIxMTEsMTQuMTgyNDE2NjQwNzM4KSk7CiMzMjcgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMzMjggPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMzI5LC5GLik7CiMzMjkgPSBFREdFX0NVUlZFKCcnLCMzMzAsIzMwNSwjMzMyLC5ULik7CiMzMzAgPSBWRVJURVhfUE9JTlQoJycsIzMzMSk7CiMzMzEgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDQwLiwwLikpOwojMzMyID0gU1VSRkFDRV9DVVJWRSgnJywjMzMzLCgjMzM3LCMzNDQpLC5QQ1VSVkVfUzEuKTsKIzMzMyA9IExJTkUoJycsIzMzNCwjMzM1KTsKIzMzNCA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sNDAuLDAuKSk7CiMzMzUgPSBWRUNUT1IoJycsIzMzNiwxLik7CiMzMzYgPSBESVJFQ1RJT04oJycsKDAuLDAuLDEuKSk7CiMzMzcgPSBQQ1VSVkUoJycsIzI2MiwjMzM4KTsKIzMzOCA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzMzOSksIzM0Myk7CiMzMzkgPSBMSU5FKCcnLCMzNDAsIzM0MSk7CiMzNDAgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEuLDAuKSk7CiMzNDEgPSBWRUNUT1IoJycsIzM0MiwxLik7CiMzNDIgPSBESVJFQ1RJT04oJycsKDAuLC0xLikpOwojMzQzID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojMzQ0ID0gUENVUlZFKCcnLCM0NCwjMzQ1KTsKIzM0NSA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzM0NiksIzM1MCk7CiMzNDYgPSBMSU5FKCcnLCMzNDcsIzM0OCk7CiMzNDcgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDAuKSk7CiMzNDggPSBWRUNUT1IoJycsIzM0OSwxLik7CiMzNDkgPSBESVJFQ1RJT04oJycsKDAuLC0xLikpOwojMzUwID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojMzUxID0gT1JJRU5URURfRURHRSgnJywqLCosIzM1MiwuRi4pOwojMzUyID0gRURHRV9DVVJWRSgnJywjMjQ3LCMzMzAsIzM1MywuVC4pOwojMzUzID0gU1VSRkFDRV9DVVJWRSgnJywjMzU0LCgjMzU5LCMzNjYpLC5QQ1VSVkVfUzEuKTsKIzM1NCA9IEJfU1BMSU5FX0NVUlZFX1dJVEhfS05PVFMoJycsMywoIzM1NSwjMzU2LCMzNTcsIzM1OCksCiAgLlVOU1BFQ0lGSUVELiwuRi4sLkYuLCg0LDQpLCgwLiwxLiksLlBJRUNFV0lTRV9CRVpJRVJfS05PVFMuKTsKIzM1NSA9IENBUlRFU0lBTl9QT0lOVCgnJywoNjAuLDYwLiwwLikpOwojMzU2ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCg0NC4xODg2MTE2OTkxNTgsNjAuLDAuKSk7CiMzNTcgPSBDQVJURVNJQU5fUE9JTlQoJycsKDIuOTA0NTA0OTEwOTA1RS0xNSw1NS44MTEzODgzMDA4NDIsMC4pKTsKIzM1OCA9IENBUlRFU0lBTl9QT0lOVCgnJywoMC4sNDAuLDAuKSk7CiMzNTkgPSBQQ1VSVkUoJycsIzI2MiwjMzYwKTsKIzM2MCA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzM2MSksIzM2NSk7CiMzNjEgPSBMSU5FKCcnLCMzNjIsIzM2Myk7CiMzNjIgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDAuKSk7CiMzNjMgPSBWRUNUT1IoJycsIzM2NCwxLik7CiMzNjQgPSBESVJFQ1RJT04oJycsKDEuLDAuKSk7CiMzNjUgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMzNjYgPSBQQ1VSVkUoJycsIzEyNiwjMzY3KTsKIzM2NyA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzM2OCksIzM3Myk7CiMzNjggPSBCX1NQTElORV9DVVJWRV9XSVRIX0tOT1RTKCcnLDMsKCMzNjksIzM3MCwjMzcxLCMzNzIpLAogIC5VTlNQRUNJRklFRC4sLkYuLC5GLiwoNCw0KSwoMC4sMS4pLC5QSUVDRVdJU0VfQkVaSUVSX0tOT1RTLik7CiMzNjkgPSBDQVJURVNJQU5fUE9JTlQoJycsKDEwLjE1NjEzOTA3ODg4MSwzNC4xODI0MTY2NDA3MzgpKTsKIzM3MCA9IENBUlRFU0lBTl9QT0lOVCgnJywoLTUuNjU1MjQ5MjIxOTYxLDM0LjE4MjQxNjY0MDczOCkpOwojMzcxID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgtNDkuODQzODYwOTIxMTEsMjkuOTkzODA0OTQxNTgpKTsKIzM3MiA9IENBUlRFU0lBTl9QT0lOVCgnJywoLTQ5Ljg0Mzg2MDkyMTExLDE0LjE4MjQxNjY0MDczOCkpOwojMzczID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgyKSAKUEFSQU1FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKCkgUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgnMkQgU1BBQ0UnLCcnCiAgKSApOwojMzc0ID0gQURWQU5DRURfRkFDRSgnJywoIzM3NSksIzQ0LC5GLik7CiMzNzUgPSBGQUNFX0JPVU5EKCcnLCMzNzYsLkYuKTsKIzM3NiA9IEVER0VfTE9PUCgnJywoIzM3NywjMzc4LCMzOTksIzQwMCkpOwojMzc3ID0gT1JJRU5URURfRURHRSgnJywqLCosIzMyOSwuVC4pOwojMzc4ID0gT1JJRU5URURfRURHRSgnJywqLCosIzM3OSwuVC4pOwojMzc5ID0gRURHRV9DVVJWRSgnJywjMzA1LCMyNCwjMzgwLC5ULik7CiMzODAgPSBTVVJGQUNFX0NVUlZFKCcnLCMzODEsKCMzODUsIzM5MiksLlBDVVJWRV9TMS4pOwojMzgxID0gTElORSgnJywjMzgyLCMzODMpOwojMzgyID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiw0MC4sMjAuKSk7CiMzODMgPSBWRUNUT1IoJycsIzM4NCwxLik7CiMzODQgPSBESVJFQ1RJT04oJycsKDAuLC0xLiwtMC4pKTsKIzM4NSA9IFBDVVJWRSgnJywjNDQsIzM4Nik7CiMzODYgPSBERUZJTklUSU9OQUxfUkVQUkVTRU5UQVRJT04oJycsKCMzODcpLCMzOTEpOwojMzg3ID0gTElORSgnJywjMzg4LCMzODkpOwojMzg4ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiwtMjAuKSk7CiMzODkgPSBWRUNUT1IoJycsIzM5MCwxLik7CiMzOTAgPSBESVJFQ1RJT04oJycsKDEuLDAuKSk7CiMzOTEgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiMzOTIgPSBQQ1VSVkUoJycsIzcyLCMzOTMpOwojMzkzID0gREVGSU5JVElPTkFMX1JFUFJFU0VOVEFUSU9OKCcnLCgjMzk0KSwjMzk4KTsKIzM5NCA9IExJTkUoJycsIzM5NSwjMzk2KTsKIzM5NSA9IENBUlRFU0lBTl9QT0lOVCgnJywoLTQ5Ljg0Mzg2MDkyMTExLDE0LjE4MjQxNjY0MDczOCkpOwojMzk2ID0gVkVDVE9SKCcnLCMzOTcsMS4pOwojMzk3ID0gRElSRUNUSU9OKCcnLCgwLiwtMS4pKTsKIzM5OCA9ICggR0VPTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoMikgClBBUkFNRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgpIFJFUFJFU0VOVEFUSU9OX0NPTlRFWFQoJzJEIFNQQUNFJywnJwogICkgKTsKIzM5OSA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCMyMSwuRi4pOwojNDAwID0gT1JJRU5URURfRURHRSgnJywqLCosIzQwMSwuRi4pOwojNDAxID0gRURHRV9DVVJWRSgnJywjMzMwLCMyMiwjNDAyLC5ULik7CiM0MDIgPSBTVVJGQUNFX0NVUlZFKCcnLCM0MDMsKCM0MDcsIzQxNCksLlBDVVJWRV9TMS4pOwojNDAzID0gTElORSgnJywjNDA0LCM0MDUpOwojNDA0ID0gQ0FSVEVTSUFOX1BPSU5UKCcnLCgwLiw0MC4sMC4pKTsKIzQwNSA9IFZFQ1RPUignJywjNDA2LDEuKTsKIzQwNiA9IERJUkVDVElPTignJywoMC4sLTEuLC0wLikpOwojNDA3ID0gUENVUlZFKCcnLCM0NCwjNDA4KTsKIzQwOCA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzQwOSksIzQxMyk7CiM0MDkgPSBMSU5FKCcnLCM0MTAsIzQxMSk7CiM0MTAgPSBDQVJURVNJQU5fUE9JTlQoJycsKDAuLDAuKSk7CiM0MTEgPSBWRUNUT1IoJycsIzQxMiwxLik7CiM0MTIgPSBESVJFQ1RJT04oJycsKDEuLDAuKSk7CiM0MTMgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiM0MTQgPSBQQ1VSVkUoJycsIzEyNiwjNDE1KTsKIzQxNSA9IERFRklOSVRJT05BTF9SRVBSRVNFTlRBVElPTignJywoIzQxNiksIzQyMCk7CiM0MTYgPSBMSU5FKCcnLCM0MTcsIzQxOCk7CiM0MTcgPSBDQVJURVNJQU5fUE9JTlQoJycsKC00OS44NDM4NjA5MjExMSwxNC4xODI0MTY2NDA3MzgpKTsKIzQxOCA9IFZFQ1RPUignJywjNDE5LDEuKTsKIzQxOSA9IERJUkVDVElPTignJywoMC4sLTEuKSk7CiM0MjAgPSAoIEdFT01FVFJJQ19SRVBSRVNFTlRBVElPTl9DT05URVhUKDIpIApQQVJBTUVUUklDX1JFUFJFU0VOVEFUSU9OX0NPTlRFWFQoKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCcyRCBTUEFDRScsJycKICApICk7CiM0MjEgPSBBRFZBTkNFRF9GQUNFKCcnLCgjNDIyKSwjMTI2LC5GLik7CiM0MjIgPSBGQUNFX0JPVU5EKCcnLCM0MjMsLkYuKTsKIzQyMyA9IEVER0VfTE9PUCgnJywoIzQyNCwjNDI1LCM0MjYsIzQyNywjNDI4KSk7CiM0MjQgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMTEyLC5ULik7CiM0MjUgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMTk2LC5ULik7CiM0MjYgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMjc3LC5ULik7CiM0MjcgPSBPUklFTlRFRF9FREdFKCcnLCosKiwjMzUyLC5ULik7CiM0MjggPSBPUklFTlRFRF9FREdFKCcnLCosKiwjNDAxLC5ULik7CiM0MjkgPSBBRFZBTkNFRF9GQUNFKCcnLCgjNDMwKSwjNzIsLlQuKTsKIzQzMCA9IEZBQ0VfQk9VTkQoJycsIzQzMSwuVC4pOwojNDMxID0gRURHRV9MT09QKCcnLCgjNDMyLCM0MzMsIzQzNCwjNDM1LCM0MzYpKTsKIzQzMiA9IE9SSUVOVEVEX0VER0UoJycsKiwqLCM1NiwuVC4pOwojNDMzID0gT1JJRU5URURfRURHRSgnJywqLCosIzE0MiwuVC4pOwojNDM0ID0gT1JJRU5URURfRURHRSgnJywqLCosIzIyMSwuVC4pOwojNDM1ID0gT1JJRU5URURfRURHRSgnJywqLCosIzMwNCwuVC4pOwojNDM2ID0gT1JJRU5URURfRURHRSgnJywqLCosIzM3OSwuVC4pOwojNDM3ID0gKCBHRU9NRVRSSUNfUkVQUkVTRU5UQVRJT05fQ09OVEVYVCgzKSAKR0xPQkFMX1VOQ0VSVEFJTlRZX0FTU0lHTkVEX0NPTlRFWFQoKCM0NDEpKSBHTE9CQUxfVU5JVF9BU1NJR05FRF9DT05URVhUCigoIzQzOCwjNDM5LCM0NDApKSBSRVBSRVNFTlRBVElPTl9DT05URVhUKCdDb250ZXh0ICMxJywKICAnM0QgQ29udGV4dCB3aXRoIFVOSVQgYW5kIFVOQ0VSVEFJTlRZJykgKTsKIzQzOCA9ICggTEVOR1RIX1VOSVQoKSBOQU1FRF9VTklUKCopIFNJX1VOSVQoLk1JTExJLiwuTUVUUkUuKSApOwojNDM5ID0gKCBOQU1FRF9VTklUKCopIFBMQU5FX0FOR0xFX1VOSVQoKSBTSV9VTklUKCQsLlJBRElBTi4pICk7CiM0NDAgPSAoIE5BTUVEX1VOSVQoKikgU0lfVU5JVCgkLC5TVEVSQURJQU4uKSBTT0xJRF9BTkdMRV9VTklUKCkgKTsKIzQ0MSA9IFVOQ0VSVEFJTlRZX01FQVNVUkVfV0lUSF9VTklUKExFTkdUSF9NRUFTVVJFKDEuRS0wNyksIzQzOCwKICAnZGlzdGFuY2VfYWNjdXJhY3lfdmFsdWUnLCdjb25mdXNpb24gYWNjdXJhY3knKTsKIzQ0MiA9IFBST0RVQ1RfUkVMQVRFRF9QUk9EVUNUX0NBVEVHT1JZKCdwYXJ0JywkLCgjNykpOwpFTkRTRUM7CkVORC1JU08tMTAzMDMtMjE7Cg==\"\n\n// function to convert base64 to blob\nconst base64ToBlob = async (base64, type = 'text/html') => \n  fetch(`data:${type};base64,${base64}`)\n  .then(res => res.blob())\n\n// create blob from string above\nconst blobFile = await base64ToBlob(stepFile)\n\nlet shape = await importSTEP(blobFile)\nconsole.log(shape) // check that result is DS_Solid\nlet shapeRounded = shape.clone().fillet(8).mirror(\"XZ\",10)\n\nreturn [shape,shapeRounded]}\n```\n\n## 9.1 Define points based on directions and distances\n\n``` javascript\nfunction Polar(currentPoint,distance,angleDegToX)\n{\n    let newPoint = [];\n    let angleRad = angleDegToX * Math.PI/180;\n    newPoint[0]  = currentPoint[0] + distance * Math.cos(angleRad);\n    newPoint[1]  = currentPoint[1] + distance * Math.sin(angleRad);\n    return newPoint\n}\n\nfunction PolarX(currentPoint,xdistance,angleDegToX)\n{\n    let newPoint = [];\n    let angleRad = angleDegToX * Math.PI/180;\n    newPoint[0]  = currentPoint[0] + xdistance;\n    newPoint[1]  = currentPoint[1] + xdistance * Math.tan(angleRad);\n    return newPoint\n}\n\nfunction PolarY(currentPoint,ydistance,angleDegToX)\n{\n    let newPoint = [];\n    let angleRad = angleDegToX * Math.PI/180;\n    newPoint[0]  = currentPoint[0] + ydistance/Math.tan(angleRad);\n    newPoint[1]  = currentPoint[1] + ydistance;\n    return newPoint\n}\n``` \n\n## 9.2 Circles joined with tangent lines\n\nThis function can be used to draw to circle-arcs connected with tangent lines, as an outline for a lever or a droplet. The circle with `radius1` is centered on the origin, the second arc is centered along the x-axis at a distance called `distance`. \n\n\n![Creating a drop shape for a lever](https://github.com/raydeleu/ReplicadManual/blob/main/images/droplet1.png)\n\n``` javascript \nfunction dropView(radius1, radius2, distance)\n{\n    let sinus_angle = (radius1 - radius2) / distance\n    let angle = Math.asin(sinus_angle);\n\n    // points of outer contour of the lever\n    let p1 = [radius1 * Math.sin(angle), radius1 * Math.cos(angle)];\n    let p2 = [distance + radius2 * Math.sin(angle), radius2 * Math.cos(angle)];\n    let p3 = [distance + radius2, 0];\n    let p4 = [distance + radius2 * Math.sin(angle), - radius2 * Math.cos(angle)];\n    let p5 = [radius1 * Math.sin(angle), - radius1 * Math.cos(angle)];\n    let p6 = [- radius1, 0 ];\n\n    let dropDrawing = draw(p1)\n                    .lineTo(p2)\n                    .threePointsArcTo(p4,p3)\n                    .lineTo(p5)\n                    .threePointsArcTo(p1,p6)\n                    .close();\n    \n    return dropDrawing}\n```\n\n\n## Create a polar array \n\nMany CAD programs offer the function to create a polar array of shapes, for example adding holes in a circular pattern. The following script solves this (copied from https://replicad.xyz/docs/recipes/polar-array)\n\n``` javascript\nconst polarCopies = (shape, count, radius) => {\n  const base = shape.translate(0, radius);\n  const angle = 360 / count;\n\n  const copies = [];\n  for (let i = 0; i < count; i++) {\n    copies.push(base.clone().rotate(i * angle));\n  }\n  return copies;\n};\n```\n\nThe code only works properly if: \n\n* your original shape is centered at the origin [x,y] = [0,0]\n* the circular pattern is located around the origin \n\nThe script works for any shape and therefore both for 2D and 3D shapes. In the case of 3D, it will create the copies in the XY plane (as the default rotation is defined around the z-axis). \n\n\n## D.1 Three arm bracket\n\nThis is the shape from Solidworks Model Mania 2020. I had to make some adjustments to the model to make it work. The largest difference is that the cutout in each arm does end 1 mm before reaching the cylindrical part in the middle. \n\n![image](https://github.com/sgenoud/replicad/assets/38007983/101065c2-4504-4bcc-a2fd-a462ac15cdf8)\n\nThe model files can be found here: \nhttps://blogs.solidworks.com/tech/wp-content/uploads/sites/4/Model-Mania-2020-Phase1-drawing.png\nhttps://blogs.solidworks.com/tech/wp-content/uploads/sites/4/Model-Mania-2020-Phase2-drawing.png\n\nAs usual the fillets posed the biggest challenge. I solved this by rounding the cutout first before subtracting it from the main shape. Furthermore I cut the holes after filleting the shape to avoid the need to select the edges explicitly. \n\nThe code below contains some failed fillet experiments. The red shape shows the part that I used to create the cutouts in each arm. The green box shows a selection box that I tried to select only a few edges. Strangely enough this failed, whereas filleting the whole shape and then cutting the holes that should not be rounded succeeded. Note that I still had to restrict the rounding within a box (using the `e.InBox` method to avoid rounding the bottom of the shape. \n\n``` javascript\n// Three arm as created for Model Mania 2020\n// https://blogs.solidworks.com/tech/wp-content/uploads/sites/4/Model-Mania-2020-Phase1-drawing.png\n// https://blogs.solidworks.com/tech/wp-content/uploads/sites/4/Model-Mania-2020-Phase2-drawing.png\n// free interpretation as not all fillets were possible in Replicad\n// and cutout up to central cylinder posed a problem\n\nfunction main({Sketcher, \nsketchCircle,Lever,\nmakeCylinder,\nmakeBaseBox},{})\n{\n\nlet r1  = 11;\nlet r2  = 6;\nlet d   = 35;\nlet t   = 3;\nlet h   = 22;\nlet fl  = 30;\nlet bb = 16/2; \nlet sb = 4.5/2;\nlet cb = 8/2; \n\n// function to create a lever consisting of two circles connected with tangent lines \n// \n// radius1 = radius of circle that is located around the origin\n// radius2 = radius of circle that is located at distance D along x-axis\n// distance = distance between the two circles\n// leverheight = distance over which lever is extruded in z-direction\n// \n// note that this function creates a closed shape. If you want holes you have to create two cylinders at \n// the correct position, extrude these a bit more than the leverheight and subtract these from the shape.  \n\nfunction Lever(radius1, radius2, distance, leverHeight)\n{\n    let sinus_angle = (radius1 - radius2) / distance\n    let angle = Math.asin(sinus_angle);\n\n    // points of outer contour of the lever\n    let p1 = [radius1 * Math.sin(angle), radius1 * Math.cos(angle)];\n    let p2 = [distance + radius2 * Math.sin(angle), radius2 * Math.cos(angle)];\n    let p3 = [distance + radius2, 0];\n    let p4 = [distance + radius2 * Math.sin(angle), - radius2 * Math.cos(angle)];\n    let p5 = [radius1 * Math.sin(angle), - radius1 * Math.cos(angle)];\n    let p6 = [- radius1, 0 ];\n\n    let sketchLever = new Sketcher(\"XY\").movePointerTo(p1)\n                    .lineTo(p2)\n                    .threePointsArcTo(p4,p3)\n                    .lineTo(p5)\n                    .threePointsArcTo(p1,p6)\n                    .close();\n              \n    let leverBody = sketchLever.extrude(leverHeight);\n       \n    return leverBody\n}\n\n\n// function to create lever with holes with standard wallthickness around the holes\n// radii refer to outer radii, the holes will be radius - wallThickness\n// uses the function lever to create the basic shape \n\nfunction leverHoles(radius1,radius2,distance,leverHeight,wallThickness)\n{ \n    let leverBody = Lever(radius1,radius2,distance,leverHeight);\n\n    let orig_hole  = sketchCircle(radius1-wallThickness).extrude(leverHeight + 10);\n    let dist_hole =  sketchCircle(radius2-wallThickness).extrude(leverHeight + 10).translate([distance,0,0]);\n    let lever   = leverBody.cut(orig_hole)\n    lever       = lever.cut(dist_hole);\n    return lever\n}\n\n// function to cut part out of lever to make it lighter\n// generally the size of the radii is equal to the size of the holes in the lever\n\n\nfunction cutLever(r1,r2,d,h,ts,th)\n{\n    let cLever = Lever(r1-ts,r2,d,h).translate([0,0,th]);\n    cLever=cLever.cut(makeCylinder(r1+ts,h+2*th,[0,0,0],[0,0,1]));\n    cLever=cLever.cut(makeCylinder(r2+ts,h+2*th,[d,0,0],[0,0,1]));\n    return cLever\n}\n\n// create three arms, fuse them together and round the edges in z-direction\n\nlet arm1 = Lever(r1,r2,d,h);\nlet arm2 = Lever(r1,r2,d,h).rotate(120,[0,0,0],[0,0,1])\nlet arm3 = Lever(r1,r2,d,h).rotate(240,[0,0,0],[0,0,1])\nlet threeArm = arm1.fuse(arm2);\nthreeArm = threeArm.fuse(arm3).fillet(fl,(e)=>e.inDirection(\"Z\"));\n\n// cut the three arms so that they slope with 22 degrees towards the end\n\nlet side = new Sketcher(\"XZ\").movePointerTo([41,6])\n.lineTo([50,6]).lineTo([50,30]).lineTo([0,30])\n.lineTo([0,22]).lineTo([11,22]).lineTo([11,6+(30*Math.sin(22*Math.PI/180))])\n.close()\n\nlet sideCutter = side.revolve()\n// NOTE: sideCutter is rotated to avoid edge over first arm!!!\nsideCutter = sideCutter.rotate(60,[0,0,0],[0,0,1]);\nthreeArm = threeArm.cut(sideCutter,false,false)\n\n// fillet the top edges, leaving out the central axle\nthreeArm = threeArm.fillet(1,(e)=>e.inBox([50,50,2],[-50,-50,20]));\n\n// Phase 2: make arms lighter, note that fillet is applied in this stage already\nlet cutLever1 = cutLever(bb+1,cb,d,h,3,4).fillet(1);\nlet cutLever2 = cutLever(bb+1,cb,d,h,3,4).rotate(120,[0,0,0],[0,0,1]).fillet(1);\nlet cutLever3 = cutLever(bb+1,cb,d,h,3,4).rotate(240,[0,0,0],[0,0,1]).fillet(1);\nthreeArm = threeArm.cut(cutLever1);\nthreeArm = threeArm.cut(cutLever2);\nthreeArm = threeArm.cut(cutLever3);\n\nlet selBox = makeBaseBox(5,20,12).translate([22.5,0,9])\n// experiments to round edges\n//threeArm = threeArm.fillet(0.4,(e)=>e.inBox([20,10,3],[25,0,15]));\n//threeArm = threeArm.fillet(0.7,(e)=>e.inDirection(\"Z\"));\n//threeArm = threeArm.fillet(0.7,(e)=>e.inPlane(\"XY\"));\nthreeArm = threeArm.fillet(1,(e)=>e.inBox([50,50,2],[-50,-50,21]))\n\nlet smallBore1 = makeCylinder(sb,h,[0,0,0],[0,0,1]).translate([35,0,-5]).rotate(120,[0,0,0],[0,0,1])\nlet smallBore2 = makeCylinder(sb,h,[0,0,0],[0,0,1]).translate([35,0,-5]).rotate(240,[0,0,0],[0,0,1])\nlet smallBore3 = makeCylinder(sb,h,[0,0,0],[0,0,1]).translate([35,0,-5]).rotate(360,[0,0,0],[0,0,1])\nthreeArm = threeArm.cut(smallBore1)\nthreeArm = threeArm.cut(smallBore2)\nthreeArm = threeArm.cut(smallBore3)\n\nlet counterBore1 = makeCylinder(cb,h,[0,0,0],[0,0,1]).translate([35,0,4])\nlet counterBore2 = makeCylinder(cb,h,[0,0,0],[0,0,1]).translate([35,0,4]).rotate(120,[0,0,0],[0,0,1])\nlet counterBore3 = makeCylinder(cb,h,[0,0,0],[0,0,1]).translate([35,0,4]).rotate(240,[0,0,0],[0,0,1])\nthreeArm = threeArm.cut(counterBore1)\nthreeArm = threeArm.cut(counterBore2)\nthreeArm = threeArm.cut(counterBore3)\n\n// create holes for axles\nlet bigBore = sketchCircle(8).extrude(40).translate([0,0,-10]);\nthreeArm = threeArm.cut(bigBore);\n\nlet shapeArray =[{shape: threeArm, color: \"steelblue\"}\n//,{shape: sideCutter, color:\"grey\", opacity:0.5}\n,{shape: cutLever1, color:\"red\", opacity:0.5}\n,{shape: selBox, color:\"green\", opacity:0.5}\n]\n\nreturn shapeArray;\n\n}\n\n```\n\n## D.2 Angled bracket\n\nI created the angled bracket defined for the SolidWorks Model Mania 2001 challenge. It was indeed a challenge to model this with Replicad. I started out with combining shapes like cylinders and boxes,  but finally returned to an approach with drawings (sketches). As Solidworks supports constrained-based modelling the dimensions provided in the drawing https://blogs.solidworks.com/tech/wp-content/uploads/sites/4/Model-Mania-2001-Phase-1.jpg are not suited to create a drawing. Therefore I created three functions that allow to define points using angles and distances, either the polar distance or one of the X or Y distances. Using this function I defined points around the contour of each drawing. \n\nThe following drawing created in SolveSpace illustrates the drawing that I needed to recreate in Replicad. The part is called \"flange\" in the code below.\n\n![mm20012-side](https://github.com/sgenoud/replicad/assets/38007983/b3f4abfa-0c16-4d79-9f92-3499b5bccfb0)\n\nI did not solve the following issues: \n\n* The rib, shown in the drawing below, is defined by a height of 26 mm, following the curve of the flange and then a curve with radius 55 mm to join towards the base of the shape. I used the `tangentArc` for this curve, but this does not allow to define a radius. I eyeballed the length of the straight segment between the two curves and used this to define the point where the `tangentArc` starts. I plan to define some functions to take the tedious math out of these problems. \n\n![mm20012-rib](https://github.com/sgenoud/replicad/assets/38007983/e4e2dbca-fde3-4219-9190-df573f4df005)\n\n* After many attempts I was not able to create the fillets between the base block, the flange and the rib. The site https://github.com/alexneufeld/FreeCAD_modelmania/tree/main/2001 shows that it should be possible with FreeCad (based on OpenCascade), so I must be doing something wrong. \n\nHere is my end-result: \n\n![mm2001-rc-v2](https://github.com/sgenoud/replicad/assets/38007983/ae7ee1ea-ca23-4fae-85a1-ccd0cdf84baf)\n\nAnd here is the code: \n\n```javascript\nconst {draw,makeCylinder,makeBaseBox} = replicad\n\n// Number of functions to make drawing easier\nfunction Polar(currentPoint,distance,angleDegToX)\n{\n    let newPoint = [];\n    let angleRad = angleDegToX * Math.PI/180;\n    newPoint[0]  = currentPoint[0] + distance * Math.cos(angleRad);\n    newPoint[1]  = currentPoint[1] + distance * Math.sin(angleRad);\n    return newPoint\n}\n\nfunction PolarX(currentPoint,xdistance,angleDegToX)\n{\n    let newPoint = [];\n    let angleRad = angleDegToX * Math.PI/180;\n    newPoint[0]  = currentPoint[0] + xdistance;\n    newPoint[1]  = currentPoint[1] + xdistance * Math.tan(angleRad);\n    return newPoint\n}\n\nfunction PolarY(currentPoint,ydistance,angleDegToX)\n{\n    let newPoint = [];\n    let angleRad = angleDegToX * Math.PI/180;\n    newPoint[0]  = currentPoint[0] + ydistance/Math.tan(angleRad);\n    newPoint[1]  = currentPoint[1] + ydistance;\n    return newPoint\n}\n\nfunction main()\n{\n// Model Mania 2001 part 1\n\n// break part apart into several components\n\n// cylinder\nlet startPoint = [-146,0,64];\nlet cylinderAngleDeg = 45\nlet cylinderAngle = cylinderAngleDeg*Math.PI/180;\nlet cylinderDirection = [Math.cos(cylinderAngle),0,Math.sin(cylinderAngle)]\nlet cylinderHeight = 32; \nlet cylinderOuterRadius = 52/2;\nlet cylinderInnerRadius = 32/2\n\nlet cylinderOuter = makeCylinder(cylinderOuterRadius,\ncylinderHeight+1,startPoint,cylinderDirection) \n// add millimeter to intrude into the flange\nlet cylinderInner = makeCylinder(cylinderInnerRadius,\ncylinderHeight*2,startPoint,cylinderDirection)\ncylinderOuter = cylinderOuter.cut(cylinderInner.clone())\n// clone the inner cylinder as we want to re-use it to cut the flange\n\n// base\nlet baseHeight = 20;\nlet baseWidth = 96;\nlet baseLength = 64;\nlet baseBlock = makeBaseBox(baseHeight,baseWidth,baseLength)\n.translate([-baseHeight/2,0,0])\n\n// flange\nlet flangeWidth = 64;\nlet flangeRoundingTop = 64/2;\nlet flangeThickness = 12;\nlet flangeRounding = 15;\nlet flangeLength = 146\nlet pStart = [startPoint[0],startPoint[2]] // 2D representation\n\nlet p1 = Polar(pStart,cylinderHeight,cylinderAngleDeg)   // middle of cylinder\nlet p2 = Polar(p1,flangeRoundingTop,cylinderAngleDeg+90) // clockwise around\nlet p3 = Polar(p2,flangeThickness,cylinderAngleDeg)\nlet p4 = PolarY(p3,-p3[1]+baseLength,cylinderAngleDeg-90)   // note that Dy is negative! \nlet p5 = [-10,baseLength]\nlet p6 = [-10,baseLength-flangeThickness]\nlet p7 = PolarY(p1,-p1[1]+(baseLength-flangeThickness),cylinderAngleDeg-90)\n\nlet flange = draw(p1)\n.lineTo(p2)\n.lineTo(p3)\n.lineTo(p4)\n.customCorner(flangeRounding)\n.lineTo(p5)\n.lineTo(p6)\n.lineTo(p7)\n.customCorner(flangeRounding+flangeThickness)\n.close()\n.sketchOnPlane(\"XZ\")\n.extrude(flangeWidth)\n.translate([0,flangeWidth/2,0])\n.fillet(31.99,(e)=>e.atAngleWith(\"X\",45).ofLength(flangeThickness))\n\n// rib \nlet ribHeight = 26;\nlet ribRounding = 55;\n\nlet r1 = Polar(pStart,cylinderHeight-ribHeight,45)\nlet r2 = PolarY(r1,-r1[1]+(64-12-26),-45)\nlet r8 = Polar(r1,ribHeight,45)\nlet r3 = [r2[0]+25,r2[1]]\nlet r4 = [-20,0]\nlet r5 = [-10,0]\nlet r6 = [-10,52]\nlet r7 = PolarY(r8,+52-r8[1],-45)\n\nlet rib = draw(r1)\n.lineTo(r2)\n.customCorner(53)\n.lineTo(r3)\n.tangentArcTo(r4)  // not possible to enter a ribRounding, depends on r3[1]\n.lineTo(r5)\n.lineTo(r6)\n.lineTo(r7)\n.customCorner(27)\n.lineTo(r8)\n.close()\n.sketchOnPlane(\"XZ\")\n.extrude(12)\n.translate([0,6,0])\n\n// M6 outer 11,20mm depth 6mm dia 6.8 mm\nlet holeSpacing = 60;\nlet holeMarginSide = 18;\nlet holeRadius = 6/2;\nlet holeOuterRadius = 10/2;\nlet holeMarginFront = 32;\n\nlet holeCutter = makeCylinder(holeRadius,baseHeight*4,[0,-holeSpacing/2,holeMarginFront],[-1,0,0])\nlet holeCutter2 = holeCutter.clone().translate([0,holeSpacing,0])\nbaseBlock = baseBlock.cut(holeCutter).cut(holeCutter2) \n\nlet counterCutter = makeCylinder(holeOuterRadius,baseHeight*4,[-14,-holeSpacing/2,holeMarginFront],[-1,0,0])\nlet counterCutter2 = counterCutter.clone().translate([0,holeSpacing,0])\nbaseBlock = baseBlock.cut(counterCutter).cut(counterCutter2) \n\nbaseBlock = baseBlock.fuse(flange).fuse(rib).fuse(cylinderOuter)\nbaseBlock = baseBlock.cut(cylinderInner)\n.fillet(2,(e)=>e.inDirection(\"X\"))\n//.fillet(2,(e)=>e.inDirection(\"Y\"))\n.fillet(2,(e)=>e.atAngleWith(\"X\",45))\n//.fillet(1,(e)=>e.inBox([0,-10,50],[-40,10,60]))\n.rotate(90,[0,0,0],[0,1,0])\n\nreturn [{shape:baseBlock, color: \"steelblue\"}]\n}\n```\n\n## D.3 Plunge watering can\n\n<img width=\"539\" alt=\"plunge-v6\" src=\"https://user-images.githubusercontent.com/38007983/174858404-ee5f39ba-4d5c-4db0-8d36-e536db95e295.png\">\n\nI created this \"Plunge\" water carafe for plants designed by Robert Bronwasser (see https://www.robertbronwasser.com/project/spring/) in Replicad. It is not an exact copy but demonstrates the capabilities and partly also the limitations of the library. The model consists of three main parts which I called the \"body\", the \"filler\" and the \"spout\". The cone-like body is created as a body of revolution. The filler is built as a loft between three wires, where the middle wire coincides with the top of the body. The spout is a small cylinder at an angle. The shapes are combined in a boolean fuse operation and then filleted. I tried to create a hollow shape by identifying the filler opening and the spout opening, but I could not get that to work. So in the end I created a shell by removing only the opening of the spout. The filler was then opened using a \"cutter\". \n\nThe code and some remarks regarding kernel errors are shown below\"\n\n\n```` javascript\n // Model of the Plunge watering carafe designed by Robert Bronwasser\n\nfunction main({\n                Sketcher,\n                sketchCircle,\n                sketchFaceOffset,\n                makeCylinder,\n                sketchRectangle,\n                FaceFinder,\n            })\n{\n\n// side profile of the bottom of the carafe\nlet p0 = [0,0]\nlet p1 = [20,0]\nlet p2 = [30,5]\nlet p3 = [30,8]\nlet p4 = [8,100]   // radius of the top at 100 mm is 8 mm\nlet p5 = [0,100]\n\nlet sideview = new Sketcher(\"XZ\")\n.lineTo(p1)\n.lineTo(p2)\n.lineTo(p3)\n.lineTo(p4)\n.lineTo(p5)\n.close()\n\n// sketch is created on XZ plane, revolve is per default around z-axis\nlet body = sideview.revolve()\n\n// create cross sections of the filler for the carafe\n//          used a workaround to rotate and translate the sketch to the required position\nlet fillHole = sketchCircle(12).face().rotate(-20,[0,0,0],[0,1,0]).translate([-35,0,135])\nfillHole = sketchFaceOffset(fillHole,0);\nlet topBody = sketchCircle(8).face().translate([0,0,100]);   // radius 8 at 100 mm \ntopBody = sketchFaceOffset(topBody,0); \nlet fillBottom = sketchCircle(9).face().rotate(20,[0,0,0],[0,1,0]).translate([0,0,80]); \nfillBottom = sketchFaceOffset(fillBottom,0); \n\n// filler shape is created as a loft between the three wires\nlet filler    = fillHole.loftWith([topBody,fillBottom],{ruled: false});\n\n// create spout, a cylinder with radius 5, length \"lengthSpout\"\nlet angleSpout = 45\nlet lengthSpout = 70\nlet spout = makeCylinder(5,lengthSpout,[0,0,0],[0,0,1]).rotate(angleSpout,[0,0,0],[0,1,0]).translate([0,0,100])\n\n// // union the main body with the filler and fillet the junction with radius 30\nlet plunge = body.fuse(filler);\nplunge = plunge.fillet(30,(e)=>e.inPlane(\"XY\",100)) \n\n// union the shape with the sprout and fillet the junction with radius 10\nplunge = plunge.fuse(spout).fillet(10,(e)=>e.inBox([20,20,100],[-20,-20,120]));\n\n// Create a shell \nlet pointFiller = [-35,0,135]\nlet spoutOpening = []\nspoutOpening[0] = Math.cos(angleSpout*Math.PI/180)*lengthSpout\nspoutOpening[1] = 0\nspoutOpening[2] = 100 + Math.sin(angleSpout*Math.PI/180)*lengthSpout\n\nconst orifices = new FaceFinder().either([\n    (f) => f.containsPoint(pointFiller),\n    (f) => f.containsPoint(spoutOpening)]);\n\n// plunge = plunge.shell(-0.5,(f)=>f.inBox([20,20,130],[[-20,-20,155]])); // Kernel Error\n// plunge = plunge.shell(-0.5,(f)=>f.containsPoint(pointFiller)); // works!\n// plunge = plunge.shell(-0.5,orifices); // Kernel Error\nplunge = plunge.shell(-1,(f)=>f.containsPoint(spoutOpening)); // works!\n\n// create cutter boxes \n//      approach to open up another face by subtracting a box from the shape\nlet cutterFiller = sketchRectangle(40,30).extrude(20).rotate(-20,[0,0,0],[0,1,0]).translate([-30,0,135])\n// let cutterSpout = sketchRectangle(40,30).extrude(20).rotate(10,[0,0,0],[0,1,0]).translate([48,0,145])\n\nplunge = plunge.cut(cutterFiller)\n// plunge = plunge.cut(cutterSpout)  // resulted in Kernel error without the shell command\n\n// let plungeInner = makeOffset(plunge,-1)  // resulted in Kernel error\n// let hollowPlunge = plunge.cut(plungeInner)  // not possible as makeOffset failed\n\nlet shapeArray = [\n{shape: plunge, name: \"plunge\", color:\"steelblue\"}, \n// {shape: fillHole, color:\"black\"},   // note that after the loft these sketches are deleted? \n// {shape: topBody, color:\"black\"},\n// {shape: fillBottom, color: \"black\"},\n// {shape: filler, color: \"yellow\"},\n// {shape: sprout, color: \"blue\"},\n// {shape: cutterFiller},\n// {shape:cutterSpout},\n// {shape: test}\n]\n\nreturn shapeArray\n}\n\n````\n\n\n<img width=\"337\" alt=\"plunge_parts_2,png\" src=\"https://user-images.githubusercontent.com/38007983/175698315-75023470-fa37-4d2c-853d-b06dadee22d1.png\">\n\nUsing the new option to display a part with opacity I created this image that illustrates some parts that were used to construct the final shape. This option can be very useful to understand how parts are overlapping and why a boolean operation between the shapes could fail. The code above was adapted like this: \n\n```` javascript \nlet shapeArray = [\n//{shape: plunge, name: \"plunge\", color:\"steelblue\", opacity: 0.5}, \n// {shape: fillHole, color:\"black\"},   // note that after the loft these sketches are deleted? \n// {shape: topBody, color:\"black\"},\n// {shape: fillBottom, color: \"black\"},\n{shape: body, color: \"orange\",opacity:0.5},\n{shape: filler, color: \"red\"},\n{shape: spout, color: \"blue\"},\n{shape: cutterFiller, color: \"green\", opacity: 0.5},\n// {shape:cutterSpout},\n// {shape: test}\n]\n````\n## D.4 Slotted lever\n\nThis slotted lever was created using the design from Solidworks Model Mania, https://blogs.solidworks.com/tech/wp-content/uploads/sites/4/Model-Mania-2008-Phase-1.jpg.  \n\n![image](https://github.com/sgenoud/replicad/assets/38007983/d1bb8b31-f6dd-4b1d-9bfd-d51d0de9765f)\n\nI used an intersection of drawings to create the circular slot. The slot is based on an intersection between to circles and a circle-segment. The keyway for the main axle, called `axleHoleShape` is created by fusing two drawings. The shape is missing some fillets as OpenCascade was not able to create these without error. The code still contains two lines for fillets. By uncommenting one of the lines you can check the result, adding both fillets at the same time results in a kernel error.  \n\n``` javascript\nconst { draw, drawCircle, drawRectangle} = replicad;\n\nconst main = () => {\n\n// dimensions of slotted lever\nlet axleHoleRadius = 22/2;\nlet axleRadius = 35/2;\nlet keySlotHeight = 6;\nlet keySlotWidth  = 2.50;  \nlet axleWidth = 30;\nlet dist = 100;\nlet slotOuterRadius = 12\nlet slotAngle = 30/180*Math.PI\nlet dh = axleRadius - slotOuterRadius\nlet minAngle = Math.asin(-dh/dist);\nlet maxAngle = minAngle + slotAngle;\nlet startPoint = [Math.cos(minAngle)*(dist+slotOuterRadius),Math.sin(minAngle)*(dist+slotOuterRadius)]\nlet endPoint = [Math.cos(maxAngle)*(dist+slotOuterRadius),Math.sin(maxAngle)*(dist+slotOuterRadius)]\nlet startPointCircle = [Math.cos(minAngle)*(dist),Math.sin(minAngle)*(dist)]\nlet endPointCircle = [Math.cos(maxAngle)*(dist),Math.sin(maxAngle)*(dist)]\n\nlet axle = drawCircle(axleRadius)\n.sketchOnPlane(\"XZ\").extrude(axleWidth);\n\nlet plate = draw()\n.movePointerTo([0,-axleRadius+6])\n.lineTo([0,-axleRadius])\n.lineTo([100,-axleRadius])\n.lineTo([90,-axleRadius+6])\n.lineTo([38,-axleRadius+6])\n.tangentArc(-5,30)\n.tangentArc(50,28)\n.polarLineTo([100,33.5])\n.ellipseTo([0,axleRadius],175,175)\n.lineTo([0,axleRadius-6])\n.ellipseTo([0,-axleRadius+6],11,11)\n.close().sketchOnPlane(\"XZ\",3).extrude(14)\n\nlet slotOuter = drawCircle(dist+slotOuterRadius)\nlet slotInner = drawCircle(dist-slotOuterRadius)\nlet segment = draw().lineTo(startPoint).line(0,50).lineTo(endPoint).close()\nlet slotRing = slotOuter.cut(slotInner)  \nlet slotSegment = slotRing.intersect(segment)\nlet slotRoundStart = drawCircle(slotOuterRadius).translate(startPointCircle)\nlet slotRoundEnd = drawCircle(slotOuterRadius).translate(endPointCircle)\nslotSegment = slotSegment.fuse(slotRoundStart)\nslotSegment = slotSegment.fuse(slotRoundEnd)\nlet slotSegmentInner = slotSegment.offset(-6)\nlet slotSegmentOuter = slotSegment.cut(slotSegmentInner).sketchOnPlane(\"XZ\",2).extrude(16)\n\nlet axleHole = drawCircle(axleHoleRadius)\nlet keySlot  = drawRectangle(2*keySlotWidth,keySlotHeight)\n.translate(-axleHoleRadius,0)\nlet axleHoleShape = axleHole.fuse(keySlot).sketchOnPlane(\"XZ\",-10)\nlet axleCutter = axleHoleShape.extrude(30+20)\naxle = axle.cut(axleCutter)\n\naxle = axle.fuse(slotSegmentOuter)\naxle = axle.fuse(plate).fillet(0.8,(e)=>e.inPlane(\"XZ\",2))\naxle = axle.fillet(0.8,(e)=>e.inPlane(\"XZ\",2+16))\n//axle = axle.fillet(1,e=>e.containsPoint([0,-17,17.5]))\n//axle = axle.fillet(1,e=>e.containsPoint([0,3,17.5]))\n\nreturn [\n//{shape: axleCutter, color: \"silver\", opacity: 0.6},\n{shape: axle, color: \"steelblue\"}\n];\n};\n```\n\n\n\n## D.5 Holder for GPS receiver\n\nAfter almost losing my GNS  receiver, I decided to design a simple holder to hang the receiver on a lanyard. \n\n<img width=\"690\" alt=\"image\" src=\"https://github.com/sgenoud/replicad/assets/38007983/011d9314-ed00-4d82-a30d-57a29113cd21\">\n\nThe code is: \n\n``` javascript\n\nconst defaultParams = {             \n    // dimensions of GNS3000 GPS receiver\n    gnsLength:     79.25,\n    gnsWidth:      45.25,\n    gnsHeight:      11.4,\n    fit:            1.0,  // tolerance to fit receiver in holder\n    thickness:      2.0,  // thickness of holder around receiver\n    portionTop:     0.8, // height of holder compared to height of receiver, max 0.87    \n    portionSide:    0.85,  // percentage of side cutout compared to length\n    assimSide:      0    // asymmetry of side cutout (and increase in length)\n    }\n\nconst r = replicad\n\nfunction main(\n   {  },   // functions used in main, can be empty if r.function notation is used\n   { gnsLength, gnsWidth, gnsHeight, fit, \n   thickness, portionTop, portionSide,assimSide} )  // parameters to adjust the model\n\n  { \n      let length = gnsLength + fit + assimSide;\n      let width  = gnsWidth + fit;\n      let height = gnsHeight + fit;\n      let radius = gnsHeight/2;\n\n    // create shape of GNS3000 receiver  \n    let receiverBody = r.makeBaseBox(length,width,height)\n    .fillet(radius,(e)=>e.inDirection(\"X\"));\n    \n    // create holder by adding thickness to the shape of the GNS receiver\n    let holder = r.makeBaseBox(length+2*thickness,width+2*thickness,height+2*thickness)\n    .fillet(radius+thickness,(e)=>e.inDirection(\"X\"))\n    .translate(0,0,-thickness)\n      \n    // number of shapes to create cut-outs in the holder  \n    let cutterTop = r.makeBaseBox(length+4*thickness, width+4*thickness, height)\n    .translate(0,0,portionTop*height)\n    let cutterSide= r.makeBaseBox(length*portionSide, width+4*thickness, height)\n    .translate(assimSide,0,4)\n    let cutterBottom = r.makeBaseBox(length,width*0.8,height)\n    .fillet(3,(e)=>e.inDirection(\"X\"))\n    .translate(length/2,0,2.0)\n\n    // create two holes for a lanyard\n    let cylLength = thickness*10  // length of drill for lanyard holes\n    let cylRad    = 2             // radius of drill for lanyard holes \n    let holeDist = 7             // distance between lanyard holes\n    holeDist = holeDist/2        // half distance for symmetrical holes\n    let cutterLanyardL = r.makeCylinder(cylRad,cylLength,[-length/2-cylLength/2,holeDist,5],[1,0,0])\n    let cutterLanyardR = r.makeCylinder(cylRad,cylLength,[-length/2-cylLength/2,-holeDist,5],[1,0,0])\n    let cutterLanyard = r.makeCompound([cutterLanyardL,cutterLanyardR])\n\n    \n    holder = holder.cut(receiverBody)\n    holder = holder.cut(cutterTop)\n    holder = holder.cut(cutterSide)\n    holder = holder.cut(cutterBottom)\n    holder = holder.cut(cutterLanyard)\n    holder = holder.fillet(2.5,(e)=>e.inBox([length/2-5,50,3],[-length/2+5,-50,3+height]).inDirection(\"Y\"))\n    holder = holder.fillet(0.5)\n    holder = holder.translate(0,0,thickness)\n\n    let shapeArray = [\n        {shape: receiverBody, name:\"receiver\", color:\"grey\" },\n        {shape: cutterTop, name:\"cutterTop\", color: \"green\" , opacity: 0.5},\n        {shape: cutterSide, name:\"cutterSide\", color: \"green\", opacity:0.5},\n        {shape: cutterBottom, name:\"cutterBottom\", color: \"green\", opacity:0.5},\n        {shape: cutterLanyard, name:\"cutterLanyard\", color: \"green\", opacity:0.5},\n        {shape: holder, name:\"holder\", opacity: 1.0},\n    ]   \n\n    return  shapeArray\n   }\n\n```\n\nI tried the model earlier in CascadeStudio as I am a little bit more familiar with that environment. \n\n![image](https://github.com/sgenoud/replicad/assets/38007983/dafaa572-68c3-493c-bed1-9732fcbb10dc)\n\nAs I struggled with creating nice rounded edges on the top of the holder, I took the opportunity to remodel the part in Replicad. Although initially I had more success, selecting edges in Replicad was also difficult. I used the  ```inBox``` edge selection together with the ```inDirection``` statement for the edges on the side. At the end I rounded all edges with a small radius. \nHowever, I wonder how in Replicad a selection of just the outer edge would work. See the example in CascadeStudio  below: \n\n![image](https://github.com/sgenoud/replicad/assets/38007983/71e7d709-83dd-4041-b1bb-1e8f20f53928)\n\nThe new WorkBench supports the display of edge identifiers, but the ```inList``` does not seem to work for rounding edges. I still have to experiment whether the ```containsPoint``` would work. \n\n<img width=\"540\" alt=\"image\" src=\"https://github.com/sgenoud/replicad/assets/38007983/899e9b08-81fe-4a9d-adc8-62614d46b426\">\n\nHere is a second model for a holder for the GPS receiver. The first model required some force to click the receiver into the holder. In this second version the idea is that the receiver can slide into the holder from the top. I removed the top part from the holder so that the holder can be printed on a 3D printer without any supports. Furthermore having an unobstructed topside might aid the reception of the GPS signal. \n\n![image](https://github.com/sgenoud/replicad/assets/38007983/6df8aca1-b8a1-4207-a4ec-d2f9721462c5)\n\nThe code is listed below. Note that I experimented with several `Edgefinders` to create fillets. I used `inDirection`, `inPlane`, `containsPoint`, which all seem to work fine. The option `containsPoint` only works if the location of a point on the edge is known very accurately. Just using the coordinates displayed in the workbench upon highlighting a specific edge does not always work. The better approach is to pick a point that can be derived directly from the dimensions entered by the user. \n\n``` javascript\n\n\nconst r = replicad\n\nconst main = () => {\n\n  let lx = 45.25    // width of gns receiver\n  let ly = 79.25;   // length of gns receiver\n  let lz = 11.4;    // thickness of gns receiver\n  let lt = 0.5 ;    // tolerance for fit around the receiver    \n  let th = 2   ;    // thickness of holder around the receiver\n  \n  let wholder = 20  ;    // width of lanyard holder\n  let yholder = 10  ;    // amount that holder sticks out of body\n  let rlanhol = 2   ;    // radius of lanyard hole\n  let ycut   = 0.6  ; // portion of side length to be cut\n  let rlandist = 7  ; // distance between two holes for lanyard, set to 0 for single hole  \n\n  // add tolerances to the dimensions of object to be held\n  lx = lx + lt; \n  ly = ly + lt;\n  lz = lz + lt; \n\n  // shape of GNS receiver\n  let receiver = r.makeBaseBox(lx,ly,lz)\n  .fillet(((lz-lt)/2),(e)=>e.inDirection(\"Y\"))\n  .translate([0,0,th])\n\n  // shape of object to be held, length increased to cut upper part\n  let hollow = r.makeBaseBox(lx,ly+2*th,lz)\n  .fillet(((lz-lt)/2),(e)=>e.inDirection(\"Y\"))\n  .translate([0,th,th])\n\n  // shape of holder\n  let shape = r.makeBaseBox(lx+2*th,ly+2*th,lz+2*th)\n  .fillet((lz+2*th-lt)/2,(e)=>e.inDirection(\"Y\"))\n\n  let lanyardholder = r.makeBaseBox(wholder,ly+(2*th),th).translate([0,yholder,0])\n  shape = shape.fuse(lanyardholder)\n  \n  // define two objects to cut away parts of the holder\n  let cutter = r.makeBaseBox(lx*1.2,ly*ycut,lz*2).translate([0,0,2*th])\n  cutter = cutter.fillet(5,(e)=>e.inDirection(\"X\"))\n  let cutterTop = r.makeBaseBox(lx*1.2,ly*1.2,lz).translate([0,0,(lz+2*th)*0.87])\n\n  // create hollow holder with cutout on side\n  let shape1 = shape.cut(hollow)\n  let shapeUnrounded = shape1.cut(cutter)\n\n  // now round the outer edge of the cutout\n  // do this first as in this state you can select a complete loop with one point\n  let shapeRounded = shapeUnrounded\n  .fillet(1.0,(e)=>e.containsPoint([0, ly*ycut/2 , lz+2*th]))\n\n  // to round the holder for the lanyard we combine two finders \n  // selecting first the edges in the z direction and the out of \n  // these only select the ones at the proper distance\n  shapeRounded = shapeRounded.fillet(0.8*wholder/2,(e)=>e.inDirection(\"Z\").inPlane(\"XZ\",-(((ly+2*th)/2)+yholder)))\n \n  let lanyardCutterL = r.makeCylinder(rlanhol,th*4,[rlandist/2,ly/2+yholder/2+th,-2*th],[0,0,1])\n  let lanyardCutterR = r.makeCylinder(rlanhol,th*4,[-rlandist/2,ly/2+yholder/2+th,-2*th],[0,0,1])\n  shapeRounded = shapeRounded.cut(lanyardCutterL)\n  shapeRounded = shapeRounded.cut(lanyardCutterR)\n\n  // now cut the top part of the holder \n  // as this overhang is difficult for the 3D printer,\n  // then  round all remaining edges with a smaller radius\n  shapeRounded = shapeRounded.cut(cutterTop).fillet(0.6)\n\n  let shapeArray = \n  [ \n  {shape: receiver, name: \"receiver\", color: \"dimgrey\", opacity: 0.8},   \n  {shape: shapeRounded, name: \"holder\", color: \"steelblue\", opacity: 1.0},\n  ]\n    \nreturn shapeArray\n  }\n```\n\nAs I wanted to create a honeycomb pattern in my model for a GPS holder, I tried different approaches: \n* using a modifier in PrusaSlicer\n* using the blingmything app\n* using the library presented above\n\nThe modifier approach worked fine but did not allow me to achieve a nice symmetrical pattern. Furthermore it allowed only limited control over the geometry of the pattern. The pattern just replicates what would otherwise be the fill pattern for the 3D print. \nThe app at blingmything creates a nice symmetrical pattern and also allows to adjust the dimensions of the pattern. But it works on complete faces. The library presented above has the same drawback. \nAs I was not able to figure out how I could modify the library, I went the hard way:  \n\n![image](https://github.com/sgenoud/replicad/assets/38007983/f3d35f28-4895-4c06-89d2-8d1e7220c5f7)\n\nThis model is created by using a hexagonal column to create a hole, each time intersecting this column with a retangular volume before subtracing it from the shape. The result is as I wanted, but it takes some time to calculate. Using the method of the library the result appears much faster, so there is probably a way to combine the shapes first and then subtracting it in a single operation. \n\nThe code to the shape above is: \n\n``` javascript\n// Experiment to create a holder for GPS Receiver\n// added code to create honeycomb pattern \n// within a rectangular shape\n\nconst r = replicad\n\nconst main = () => {\n\n  // Dimensions of the GPS receiver\n  let lx = 45.25;      // width of gns receiver\n  let ly = 79.25;      // length of gns receiver\n  let lz = 11.4;       // thickness of gns receiver\n  let lt = 0.5 ;       // tolerance for fit around the receiver    \n  \n  let th = 2   ;       // thickness of holder around the receiver\n  let wholder = 20  ;    // width of lanyard holder\n  let yholder = 10  ;    // amount that holder sticks out of body\n\n  let rlanhol = 2   ;    // radius of lanyard hole\n  let ycut    = 0.6  ; // portion of side length to be cut\n\n  let rlandist = 0  ; // distance between two holes for lanyard, set to 0 for single hole  \n  \n  // code to create a hexagon face \n  function Hexagon(size)\n  { \n    let sketchHexagon \n    for(let i = 0 ; i <= 5 ; i += 1)\n    {\n        const angle = i * 2 * Math.PI / 6\n        const xvalue = size * Math.cos(angle);\n        const yvalue = size * Math.sin(angle);\n        const point = [xvalue,yvalue];\n\n        if (i === 0){\n            sketchHexagon = new r.Sketcher(\"XY\",-1).movePointerTo(point)\n        }\n        else {\n            sketchHexagon.lineTo(point)\n        }    \n    }\n    return sketchHexagon.close()\n    }\n\n    // code to create a hexagonal column, adding height to hexagon face\n    function hexColumn(size,height)\n    {\n      return Hexagon(size).extrude(height);\n    }\n\n  // add tolerances to the dimensions of object to be held\n  lx = lx + lt; \n  ly = ly + lt;\n  lz = lz + lt; \n\n  // shape of GNS receiver\n  let receiver = r.makeBaseBox(lx,ly,lz)\n  .fillet(((lz-lt)/2),(e)=>e.inDirection(\"Y\"))\n  .translate([0,0,th])\n\n  // shape of object to be held, length increased to cut upper part\n  let hollow = r.makeBaseBox(lx,ly+2*th,lz)\n  .fillet(((lz-lt)/2),(e)=>e.inDirection(\"Y\"))\n  .translate([0,th,th])\n\n  // shape of holder, selected only top edges for filleting\n  // so that the bottom is flat, which is better for 3D printing without supports\n  let shape = r.makeBaseBox(lx+2*th,ly+2*th,lz+2*th)\n  .fillet((lz+2*th-lt)/2,(e)=>e.inDirection(\"Y\").inPlane(\"XY\",lz+2*th))\n\n  // create a lip on the holder to attach it to a lanyard\n  let lanyardholder = r.makeBaseBox(wholder,ly+(2*th),th).translate([0,yholder,0])\n  shape = shape.fuse(lanyardholder)\n  \n  // define two objects to cut away parts of the holder\n  let cutter = r.makeBaseBox(lx*1.2,ly*ycut,lz*2).translate([0,0,2*th])\n  cutter = cutter.fillet(5,(e)=>e.inDirection(\"X\"))\n  let cutterTop = r.makeBaseBox(lx*1.2,ly*1.2,lz).translate([0,0,(lz+2*th)*0.87])\n\n  // create hollow holder with cutout on side\n  let shape1 = shape.cut(hollow)\n  let shapeUnrounded = shape1.cut(cutter)\n\n  // now round the outer edge of the cutout\n  // do this first as in this state you can select a complete loop with one point\n  let shapeRounded = shapeUnrounded\n  .fillet(1.0,(e)=>e.containsPoint([0, ly*ycut/2 , lz+2*th]))\n\n  // to round the lip for the lanyard we combine two finders \n  // selecting first the edges in the z direction,  out of \n  // these only select the ones at the proper distance\n  shapeRounded = shapeRounded.fillet(8,(e)=>e.inDirection(\"Z\").inPlane(\"XZ\",-(((ly+2*th)/2)+yholder)))\n \n  // punch two holes in the lip, with distance rlanhol 0 it becomes one hole\n  let lanyardCutterL = r.makeCylinder(rlanhol,th*4,[rlandist/2,ly/2+yholder/2+th,-2*th],[0,0,1])\n  let lanyardCutterR = r.makeCylinder(rlanhol,th*4,[-rlandist/2,ly/2+yholder/2+th,-2*th],[0,0,1])\n  shapeRounded = shapeRounded.cut(lanyardCutterL)\n  shapeRounded = shapeRounded.cut(lanyardCutterR)\n\n  // now cut the top part of the holder \n  // as a closed shape is difficult for the 3D printer,\n  // then  round all remaining edges with a smaller radius\n  // used a chamfer(0.4) instead of fillet(0.6)\n  shapeRounded = shapeRounded.cut(cutterTop).fillet(0.6)\n\n  // dimensions of honeycomb grid \n  let hc_width  = 35;\n  let hc_length = 65;\n  let hc_depth  = 10;  \n  // note that hexagons are defined at plane XY, -1\n\n  // number of rows and columns from center of rectangle \n  let rowNumber = 5;\n  let colNumber = 2;\n  // cellsize and wallthickness of honeycomb \n  let wallThickness = 1;\n  let cellSize = 5;\n    \n  let deg30 = Math.PI / 6\n  let delta_x = (1+Math.sin(deg30)) * cellSize + wallThickness*Math.cos(deg30)\n  let delta_y = 0.5*wallThickness + Math.cos(deg30)*cellSize\n\n \n  let point = [];\n  let cutColumn;\n  \n  for(let rowCount = 1 ; rowCount <= rowNumber; rowCount += 1)\n    {\n      for (let colCount = 1 ;  colCount <= colNumber ; colCount += 1)\n          {\n          // two cells are defined and then replicated in each quadrant \n          // around the center of the grid, so 8 holes are defined each time \n          // This way the grid is always nicely symmetrical. \n          point[1] = [(colCount-1) * 2 * delta_x,(rowCount-1) * delta_y * 2 ,0];\n          point[2] = [-(colCount-1) * 2 * delta_x,(rowCount-1) * delta_y * 2 ,0];\n          point[3]= [(colCount-1) * 2 * delta_x,-(rowCount-1) * delta_y * 2 ,0];\n          point[4] = [-(colCount-1) * 2 * delta_x,-(rowCount-1) * delta_y * 2 ,0];\n          point[5] = [(((colCount-1)*2)+1) * delta_x, (rowCount-1)*delta_y*2+delta_y,0];  \n          point[6] = [(((colCount-1)*2)+1) * -delta_x, (rowCount-1)*delta_y*2+delta_y,0];\n          point[7] = [(((colCount-1)*2)+1) * delta_x, -(rowCount-1)*delta_y*2+delta_y,0];\n          point[8] = [(((colCount-1)*2)+1) * -delta_x, -(rowCount-1)*delta_y*2+delta_y,0];\n          for (let j=1; j<=8; j+=1)\n            { \n              cutColumn = hexColumn(cellSize,5*th).translate(point[j]);\n              // the defined column is intersected with a box to limit the grid \n              // within a rectangular shape\n              cutColumn = cutColumn.intersect(r.makeBaseBox(hc_width,hc_length,hc_depth)) \n              shapeRounded = shapeRounded.cut(cutColumn);\n            }\n          }\n    }\n  \n  let shapeArray = \n  [ \n  {shape: receiver, name: \"receiver\", color: \"dimgrey\", opacity: 0.8},   \n  {shape: shapeRounded, name: \"holder\", color: \"steelblue\", opacity: 1.0}\n  ]\n    \nreturn shapeArray\n  \n}\n\n```\n\n\nreplicad-threejs-helper\nA set of simple function to help integrate replicad in a threejs project\n\nInstall\nyarn add replicad-threejs-helper\n(npm works as well, and there are some different builds that you can link from unpkg)\n\nAPI\nThis package offers a small set of functions to sync a set of BufferGeometry with meshed shapes from replicad.\n\nCreating geometries from a replicad object\nTypically you will create an array of replicad shapes that way (this is purely replicad code):\n\nconst meshed = shapes.map((shape, i) => ({\n  name: `shape ${i + 1}`,\n  faces: shape.mesh({ tolerance: 0.05, angularTolerance: 30 }),\n  edges: shape.meshEdges({ keepMesh: true }),\n}));\nYou can then synchronise them with a set of buffer geometries (for the faces and the edges):\n\nconst geometries = syncGeometries(meshed, []);\nThe geometries will contain an array of objects with two BufferGeometry, one for the faces (the body of the solid) and one for the lines (the edges).\n\nYou will then need to integrate these geometries in your threejs project.\n\nUpdating geometries\nIf you have changes to your geometries, instead of creating new ones you can do:\n\nconst updatedGeometries = syncGeometries(meshed, geometries);\nThis will reuse the geometries if the number of shape has not changed, and dispose of the old ones (and recreate new ones) if the number of shapes has changed.\n\nMore control\nInstead of updating both the edges and the faces you can use the simpler individual functions:\n\nconst facesGeometry = new BufferGeometry();\nconst updatedFaces = syncFaces(facesGeometry, replicadMeshedFaces);\nor for the edges\n\nconst edgesGeometry = new BufferGeometry();\nsyncLines(edgesGeometry, replicadMeshedEdges);\nHighlighting\nThese helpers also allow you to implement highlighting of faces or edges, using the groups functionality of three.\n\nFor this you will need to attach two materials for both your faces and your lines.\n\nYou can toggle a single face or edge with this helper:\n\ntoggleHighlight(facesGeometry, 2);\nor\n\ntoggleHighlight(edgesGeometry, 5);";